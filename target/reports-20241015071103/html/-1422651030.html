<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2820</td> 
     <td>-1422651030</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>13a454b27d55d11c6560b7ecf8a567e4768da827</td> 
     <td>let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to have it being executed in the future, or immediately we are continuing asynchronously</td> 
     <td>let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to have it being executed in the future, or immediately we are continuing asynchronously</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>process(Exchange, AsyncCallback)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback)</td> 
     <td> final RedeliveryData data = new RedeliveryData(); // do a defensive copy of the original Exchange, which is needed for redelivery so we can ensure the // original Exchange is being redelivered, and not a mutated Exchange data.original = defensiveCopyExchangeIfNeeded(exchange); // use looping to have redelivery attempts while (true) { // can we still run if (!isRunAllowed(data)) { log.trace("Run not allowed, will reject executing exchange: {}", exchange); if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } // we cannot process so invoke callback callback.done(data.sync); return data.sync; } // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we are exhausted, and whether redelivery is allowed boolean exhausted = isExhausted(exchange, data); boolean redeliverAllowed = isRedeliveryAllowed(data); // if we are exhausted or redelivery is not allowed, then deliver to failure processor (eg such as DLC) if (!redeliverAllowed || exhausted) { Processor target = null; boolean deliver = true; // the unit of work may have an optional callback associated we need to leverage SubUnitOfWorkCallback uowCallback = exchange.getUnitOfWork().getSubUnitOfWorkCallback(); if (uowCallback != null) { // signal to the callback we are exhausted uowCallback.onExhausted(exchange); // do not deliver to the failure processor as its been handled by the callback instead deliver = false; } if (deliver) { // should deliver to failure processor (either from onException or the dead letter channel) target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; } // we should always invoke the deliverToFailureProcessor as it prepares, logs and does a fair // bit of work for exhausted exchanges (its only the target processor which may be null if handled by a savepoint) boolean isDeadLetterChannel = isDeadLetterChannel() &amp;&amp; target == data.deadLetterProcessor; boolean sync = deliverToFailureProcessor(target, isDeadLetterChannel, exchange, data, callback); // we are breaking out return sync; } if (data.redeliveryCounter &gt; 0) { // calculate delay data.redeliveryDelay = determineRedeliveryDelay(exchange, data.currentRedeliveryPolicy, data.redeliveryDelay, data.redeliveryCounter); if (data.redeliveryDelay &gt; 0) { // okay there is a delay so create a scheduled task to have it executed in the future if (data.currentRedeliveryPolicy.isAsyncDelayedRedelivery() &amp;&amp; !exchange.isTransacted()) { // we are doing a redelivery then a thread pool must be configured (see the doStart method) ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this); // let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to // have it being executed in the future, or immediately // we are continuing asynchronously // mark we are routing async from now and that this redelivery task came from a synchronous routing data.sync = false; data.redeliverFromSync = true; AsyncRedeliveryTask task = new AsyncRedeliveryTask(exchange, callback, data); // schedule the redelivery task if (log.isTraceEnabled()) { log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", data.redeliveryDelay, exchange.getExchangeId()); } executorService.schedule(task, data.redeliveryDelay, TimeUnit.MILLISECONDS); return false; } else { // async delayed redelivery was disabled or we are transacted so we must be synchronous // as the transaction manager requires to execute in the same thread context try { data.currentRedeliveryPolicy.sleep(data.redeliveryDelay); } catch (InterruptedException e) { // we was interrupted so break out exchange.setException(e); // mark the exchange to stop continue routing when interrupted // as we do not want to continue routing (for example a task has been cancelled) exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE); callback.done(data.sync); return data.sync; } } } // prepare for redelivery prepareExchangeForRedelivery(exchange, data); // letting onRedeliver be executed deliverToOnRedeliveryProcessor(exchange, data); // emmit event we are doing redelivery EventHelper.notifyExchangeRedelivery(exchange.getContext(), exchange, data.redeliveryCounter); } // process the exchange (also redelivery) boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // if we are done then notify callback and exit if (isDone(exchange)) { callback.done(sync); return; } // error occurred so loop back around which we do by invoking the processAsyncErrorHandler // method which takes care of this in a asynchronous manner processAsyncErrorHandler(exchange, callback, data); } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } // we continue to route synchronously // if we are done then notify callback and exit boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1954</td> 
     <td>-1422651030</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>4d33c4ed377f1624cb052d3d2254da15c362fb06</td> 
     <td>None</td> 
     <td>let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to have it being executed in the future, or immediately we are continuing asynchronously</td> 
     <td>SATD_ADDED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> // use looping to have redelivery attempts while (true) { // can we still run if (!isRunAllowed()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } // we cannot process so invoke callback callback.done(data.sync); return data.sync; } // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // no we should not redeliver to the same output so either try an onException (if any given) // or the dead letter queue Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; // deliver to the failure processor (either an on exception or dead letter queue boolean sync = deliverToFailureProcessor(target, exchange, data, callback); // we are breaking out return sync; } if (data.redeliveryCounter &gt; 0) { // calculate delay data.redeliveryDelay = data.currentRedeliveryPolicy.calculateRedeliveryDelay(data.redeliveryDelay, data.redeliveryCounter); if (data.redeliveryDelay &gt; 0) { // okay there is a delay so create a scheduled task to have it executed in the future if (data.currentRedeliveryPolicy.isAsyncDelayedRedelivery() &amp;&amp; !exchange.isTransacted()) { // let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to // have it being executed in the future, or immediately // we are continuing asynchronously // mark we are routing async from now and that this redelivery task came from a synchronous routing data.sync = false; data.redeliverFromSync = true; AsyncRedeliveryTask task = new AsyncRedeliveryTask(exchange, callback, data); // schedule the redelivery task if (log.isTraceEnabled()) { log.trace("Scheduling redelivery task to run in " + data.redeliveryDelay + " millis for exchangeId: " + exchange.getExchangeId()); } executorService.schedule(task, data.redeliveryDelay, TimeUnit.MILLISECONDS); return false; } else { // async delayed redelivery was disabled or we are transacted so we must be synchronous // as the transaction manager requires to execute in the same thread context try { data.currentRedeliveryPolicy.sleep(data.redeliveryDelay); } catch (InterruptedException e) { // we was interrupted so break out exchange.setException(e); callback.done(data.sync); return data.sync; } } } // prepare for redelivery prepareExchangeForRedelivery(exchange); // letting onRedeliver be executed deliverToOnRedeliveryProcessor(exchange, data); } // process the exchange (also redelivery) boolean sync = AsyncProcessorHelper.process(outputAsync, exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // if we are done then notify callback and exit if (isDone(exchange)) { callback.done(sync); return; } // error occurred so loop back around which we do by invoking the processAsyncErrorHandler // method which takes care of this in a asynchronous manner processAsyncErrorHandler(exchange, callback, data); } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } // we continue to route synchronously // if we are done then notify callback and exit boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>