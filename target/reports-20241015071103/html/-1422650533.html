<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2801</td> <td>-1422650533</td><td>apache/camel</td><td>Claus Ibsen</td><td>6d05326fa18af21d8ce70a460eba741bfd5ba79a</td> <td>None</td> <td>We can't actually remove a published exchange from an active Disruptor.
Instead we prevent processing of the exchange by setting a Property on the exchange and the value
would be an AtomicBoolean. This is set by the Producer and the Consumer would look up that Property and
check the AtomicBoolean. If the AtomicBoolean says that we are good to proceed, it will process the
exchange. If false, it will simply disregard the exchange.
But since the Property map is a Concurrent one, maybe we don't need the AtomicBoolean. Check with Simon.
Also check the TimeoutHandler of the new Disruptor 3.0.0, consider making the switch to the latest version.</td> <td>SATD_ADDED</td> <td>process(Exchange, AsyncCallback)</td> <td>public boolean process(final Exchange exchange, final AsyncCallback callback)</td> <td>
    WaitForTaskToComplete wait = waitForTaskToComplete;
    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {
        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);
    }
    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {
        // do not handover the completion as we wait for the copy to complete, and copy its result back when it done
        final Exchange copy = prepareCopy(exchange, false);
        // latch that waits until we are complete
        final CountDownLatch latch = new CountDownLatch(1);
        // we should wait for the reply so install a on completion so we know when its complete
        copy.addOnCompletion(new SynchronizationAdapter() {

            @Override
            public void onDone(final Exchange response) {
                // check for timeout, which then already would have invoked the latch
                if (latch.getCount() == 0) {
                    if (log.isTraceEnabled()) {
                        log.trace("{}. Timeout occurred so response will be ignored: {}", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                } else {
                    if (log.isTraceEnabled()) {
                        log.trace("{} with response: {}", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                    try {
                        ExchangeHelper.copyResults(exchange, response);
                    } finally {
                        // always ensure latch is triggered
                        latch.countDown();
                    }
                }
            }

            @Override
            public boolean allowHandover() {
                // do not allow handover as we want to seda producer to have its completion triggered
                // at this point in the routing (at this leg), instead of at the very last (this ensure timeout is honored)
                return false;
            }

            @Override
            public String toString() {
                return "onDone at endpoint: " + endpoint;
            }
        });
        doPublish(copy);
        if (timeout > 0) {
            if (log.isTraceEnabled()) {
                log.trace("Waiting for task to complete using timeout (ms): {} at [{}]", timeout, endpoint.getEndpointUri());
            }
            // lets see if we can get the task done before the timeout
            boolean done = false;
            try {
                done = latch.await(timeout, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            // ignore
            }
            if (!done) {
                // Remove timed out Exchange from disruptor endpoint.
                // We can't actually remove a published exchange from an active Disruptor.
                // Instead we prevent processing of the exchange by setting a Property on the exchange and the value
                // would be an AtomicBoolean. This is set by the Producer and the Consumer would look up that Property and
                // check the AtomicBoolean. If the AtomicBoolean says that we are good to proceed, it will process the
                // exchange. If false, it will simply disregard the exchange.
                // But since the Property map is a Concurrent one, maybe we don't need the AtomicBoolean. Check with Simon.
                // Also check the TimeoutHandler of the new Disruptor 3.0.0, consider making the switch to the latest version.
                exchange.setProperty(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE, true);
                exchange.setException(new ExchangeTimedOutException(exchange, timeout));
                // count down to indicate timeout
                latch.countDown();
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace("Waiting for task to complete (blocking) at [{}]", endpoint.getEndpointUri());
            }
            // no timeout then wait until its done
            try {
                latch.await();
            } catch (InterruptedException e) {
            // ignore
            }
        }
    } else {
        // no wait, eg its a InOnly then just publish to the ringbuffer and return
        // handover the completion so its the copy which performs that, as we do not wait
        final Exchange copy = prepareCopy(exchange, true);
        doPublish(copy);
    }
    // we use OnCompletion on the Exchange to callback and wait for the Exchange to be done
    // so we should just signal the callback we are done synchronously
    callback.done(true);
    return true;
</td> </tr></table></body></html>