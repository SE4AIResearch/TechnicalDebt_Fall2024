<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5449</td> <td>-1009652277</td><td>apache/hadoop</td><td>Eli Collins</td><td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> <td>None</td> <td>Total 1 map slot should be accounted for.</td> <td>SATD_ADDED</td> <td>testClusterBlockingForLackOfMemory()</td> <td>public void testClusterBlockingForLackOfMemory() throws IOException</td> <td>
    LOG.debug("Starting the scheduler.");
    taskTrackerManager = new FakeTaskTrackerManager(3, 2, 2);
    ArrayList<FakeQueueInfo> queues = new ArrayList<FakeQueueInfo>();
    queues.add(new FakeQueueInfo("default", 100.0f, true, 25));
    taskTrackerManager.addQueues(new String[] { "default" });
    scheduler.setTaskTrackerManager(taskTrackerManager);
    // enabled memory-based scheduling
    // Normal jobs 1GB maps/reduces. 2GB limit on maps/reduces
    scheduler.getConf().setLong(JTConfig.JT_MAX_MAPMEMORY_MB, 2 * 1024);
    scheduler.getConf().setLong(MRConfig.MAPMEMORY_MB, 1 * 1024);
    scheduler.getConf().setLong(JTConfig.JT_MAX_REDUCEMEMORY_MB, 2 * 1024);
    scheduler.getConf().setLong(MRConfig.REDUCEMEMORY_MB, 1 * 1024);
    taskTrackerManager.setFakeQueues(queues);
    scheduler.start();
    LOG.debug("Submit one normal memory(1GB maps/reduces) job of " + "2 map, 2 reduce tasks.");
    JobConf jConf = new JobConf(conf);
    jConf.setMemoryForMapTask(1 * 1024);
    jConf.setMemoryForReduceTask(1 * 1024);
    jConf.setNumMapTasks(2);
    jConf.setNumReduceTasks(2);
    jConf.setQueueName("default");
    jConf.setUser("u1");
    FakeJobInProgress job1 = taskTrackerManager.submitJobAndInit(JobStatus.PREP, jConf);
    // Fill a tt with this job's tasks.
    Map<String, String> expectedStrings = new HashMap<String, String>();
    expectedStrings.put(CapacityTestUtils.MAP, "attempt_test_0001_m_000001_0 on tt1");
    expectedStrings.put(CapacityTestUtils.REDUCE, "attempt_test_0001_r_000001_0 on tt1");
    checkMultipleTaskAssignment(taskTrackerManager, scheduler, "tt1", expectedStrings);
    // Total 1 map slot should be accounted for.
    checkOccupiedSlots("default", TaskType.MAP, 1, 1, 16.7f);
    checkOccupiedSlots("default", TaskType.REDUCE, 1, 1, 16.7f);
    assertEquals(JobQueue.getJobQueueSchedInfo(1, 1, 0, 1, 1, 0), job1.getSchedulingInfo().toString());
    checkMemReservedForTasksOnTT("tt1", 1 * 1024L, 1 * 1024L);
    expectedStrings.clear();
    expectedStrings.put(CapacityTestUtils.MAP, "attempt_test_0001_m_000002_0 on tt2");
    expectedStrings.put(CapacityTestUtils.REDUCE, "attempt_test_0001_r_000002_0 on tt2");
    // fill another TT with the rest of the tasks of the job
    checkMultipleTaskAssignment(taskTrackerManager, scheduler, "tt2", expectedStrings);
    LOG.debug("Submit one high memory(2GB maps/reduces) job of " + "2 map, 2 reduce tasks.");
    jConf = new JobConf(conf);
    jConf.setMemoryForMapTask(2 * 1024);
    jConf.setMemoryForReduceTask(2 * 1024);
    jConf.setNumMapTasks(2);
    jConf.setNumReduceTasks(2);
    jConf.setQueueName("default");
    jConf.setUser("u1");
    FakeJobInProgress job2 = taskTrackerManager.submitJobAndInit(JobStatus.PREP, jConf);
    // Have another TT run one task of each type of the high RAM
    // job. This will fill up the TT.
    expectedStrings.clear();
    expectedStrings.put(CapacityTestUtils.MAP, "attempt_test_0002_m_000001_0 on tt3");
    expectedStrings.put(CapacityTestUtils.REDUCE, "attempt_test_0002_r_000001_0 on tt3");
    checkMultipleTaskAssignment(taskTrackerManager, scheduler, "tt3", expectedStrings);
    checkOccupiedSlots("default", TaskType.MAP, 1, 4, 66.7f);
    checkOccupiedSlots("default", TaskType.REDUCE, 1, 4, 66.7f);
    assertEquals(JobQueue.getJobQueueSchedInfo(1, 2, 0, 1, 2, 0), job2.getSchedulingInfo().toString());
    checkMemReservedForTasksOnTT("tt3", 2 * 1024L, 2 * 1024L);
    LOG.debug("Submit one normal memory(1GB maps/reduces) job of " + "1 map, 1 reduce tasks.");
    jConf = new JobConf(conf);
    jConf.setMemoryForMapTask(1 * 1024);
    jConf.setMemoryForReduceTask(1 * 1024);
    jConf.setNumMapTasks(1);
    jConf.setNumReduceTasks(1);
    jConf.setQueueName("default");
    jConf.setUser("u1");
    FakeJobInProgress job3 = taskTrackerManager.submitJobAndInit(JobStatus.PREP, jConf);
    // Send a TT with insufficient space for task assignment,
    // This will cause a reservation for the high RAM job.
    assertNull(scheduler.assignTasks(tracker("tt1")));
    // reserved tasktrackers contribute to occupied slots for maps and reduces
    checkOccupiedSlots("default", TaskType.MAP, 1, 6, 100.0f);
    checkOccupiedSlots("default", TaskType.REDUCE, 1, 6, 100.0f);
    checkMemReservedForTasksOnTT("tt1", 1 * 1024L, 1 * 1024L);
    LOG.info(job2.getSchedulingInfo());
    assertEquals(JobQueue.getJobQueueSchedInfo(1, 2, 2, 1, 2, 2), job2.getSchedulingInfo().toString());
    assertEquals(JobQueue.getJobQueueSchedInfo(0, 0, 0, 0, 0, 0), job3.getSchedulingInfo().toString());
    // Reservations are already done for job2. So job3 should go ahead.
    expectedStrings.clear();
    expectedStrings.put(CapacityTestUtils.MAP, "attempt_test_0003_m_000001_0 on tt2");
    expectedStrings.put(CapacityTestUtils.REDUCE, "attempt_test_0003_r_000001_0 on tt2");
    checkMultipleTaskAssignment(taskTrackerManager, scheduler, "tt2", expectedStrings);
</td> </tr></table></body></html>