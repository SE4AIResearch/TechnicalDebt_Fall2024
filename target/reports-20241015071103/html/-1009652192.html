<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5534</td> <td>-1009652192</td><td>apache/hadoop</td><td>Eli Collins</td><td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> <td>None</td> <td>we do not 'reserve' slots on tasktrackers anymore since the user is
already over the limit
Note: some of the code from above is repeated here. This is on
purpose as it improves overall readability.
Note: we walk through jobs again. Some of these jobs, which weren't
considered in the first pass, shouldn't be considered here again,
but we still check for their viability to keep the code simple. In
some cases, for high mem jobs that have nothing to run, we call
obtainNewTask() unnecessarily. Should this be a problem, we can
create a list of jobs to look at (those whose users were over
limit) in the first pass and walk through that list only.</td> <td>SATD_ADDED</td> <td>toString()</td> <td>public String toString()</td> <td>
    // note that we do not call updateContextObjects() here for performance
    // reasons. This means that the data we print out may be slightly
    // stale. This data is updated whenever assignTasks() is called
    // If this doesn't happen, the data gets stale. If we see
    // this often, we may need to detect this situation and call
    // updateContextObjects(), or just call it each time.
    return scheduler.getDisplayInfo(queueName);
</td> </tr></table></body></html>