<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4806</td> 
     <td>1242677840</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>7a45eb305cb24ac2c50f5a39e985ef205bdbf107</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>updateGitlinks(ReviewDb, Branch.NameKey, Collection<submodulesubscription>
        ) 
      </submodulesubscription></td> 
     <td>private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<submodulesubscription>
        updates) throws SubmoduleException 
      </submodulesubscription></td> 
     <td> PersonIdent author = null; Repository pdb = null; RevWalk recRw = null; StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n"); try { boolean sameAuthorForAll = true; pdb = repoManager.openRepository(subscriber.getParentKey()); if (pdb.getRef(subscriber.get()) == null) { throw new SubmoduleException("The branch was probably deleted from the subscriber repository"); } DirCache dc = readTree(pdb, pdb.getRef(subscriber.get())); DirCacheEditor ed = dc.editor(); for (SubmoduleSubscription s : updates) { try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey()); RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) { Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get()); if (ref == null) { ed.add(new DeletePath(s.getPath())); continue; } final ObjectId updateTo = ref.getObjectId(); RevCommit newCommit = rw.parseCommit(updateTo); if (author == null) { author = newCommit.getAuthorIdent(); } else if (!author.equals(newCommit.getAuthorIdent())) { sameAuthorForAll = false; } DirCacheEntry dce = dc.getEntry(s.getPath()); ObjectId oldId = null; if (dce != null) { if (!dce.getFileMode().equals(FileMode.GITLINK)) { log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode."); continue; } oldId = dce.getObjectId(); } else { // This submodule did not exist before. We do not want to add // the full submodule history to the commit message, so omit it. oldId = updateTo; } ed.add(new PathEdit(s.getPath()) { @Override public void apply(DirCacheEntry ent) { ent.setFileMode(FileMode.GITLINK); ent.setObjectId(updateTo); } }); msgbuf.append("Project: " + s.getSubmodule().getParentKey().get()); msgbuf.append(" " + s.getSubmodule().getShortName()); msgbuf.append(" " + updateTo.getName()); msgbuf.append("\n\n"); try { rw.markStart(newCommit); if (oldId != null) { rw.markUninteresting(rw.parseCommit(oldId)); } for (RevCommit c : rw) { msgbuf.append(c.getFullMessage() + "\n\n"); } } catch (IOException e) { logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e); } } } ed.finish(); if (!sameAuthorForAll || author == null) { author = myIdent; } ObjectInserter oi = pdb.newObjectInserter(); ObjectId tree = dc.writeTree(oi); ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId(); CommitBuilder commit = new CommitBuilder(); commit.setTreeId(tree); commit.setParentIds(new ObjectId[] { currentCommitId }); commit.setAuthor(author); commit.setCommitter(myIdent); commit.setMessage(msgbuf.toString()); oi.insert(commit); oi.flush(); ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build()); final RefUpdate rfu = pdb.updateRef(subscriber.get()); rfu.setForceUpdate(false); rfu.setNewObjectId(commitId); rfu.setExpectedOldObjectId(currentCommitId); rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true); switch(rfu.update()) { case NEW: case FAST_FORWARD: gitRefUpdated.fire(subscriber.getParentKey(), rfu); changeHooks.doRefUpdatedHook(subscriber, rfu, account); // TODO since this is performed "in the background" no mail will be // sent to inform users about the updated branch break; default: throw new IOException(rfu.getResult().name()); } recRw = new RevWalk(pdb); // Recursive call: update subscribers of the subscriber updateSuperProjects(db, Sets.newHashSet(subscriber)); } catch (IOException e) { throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e); } finally { if (recRw != null) { recRw.close(); } if (pdb != null) { pdb.close(); } } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4398</td> 
     <td>1242677840</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Edwin Kempin</td> 
     <td>721131a17d0d7f20efc8e484407953e8b7e07cca</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>updateGitlinks(Branch.NameKey, RevWalk, Map<branch.namekey, objectid>
        , Map 
       <branch.namekey, string>
         , String) 
       </branch.namekey,> 
      </branch.namekey,></td> 
     <td>private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<branch.namekey, objectid>
        modules, final Map 
       <branch.namekey, string>
         paths, final String msg) throws SubmoduleException 
       </branch.namekey,> 
      </branch.namekey,></td> 
     <td> PersonIdent author = null; final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated " + subscriber.getParentKey().get()); Repository pdb = null; RevWalk recRw = null; try { boolean sameAuthorForAll = true; for (final Map.Entry<branch.namekey, objectid>
        me : modules.entrySet()) { RevCommit c = myRw.parseCommit(me.getValue()); msgbuf.append("\nProject: "); msgbuf.append(me.getKey().getParentKey().get()); msgbuf.append(" " + me.getValue().getName()); msgbuf.append("\n"); if (modules.size() == 1 &amp;&amp; msg != null) { msgbuf.append(msg); } else { msgbuf.append(c.getShortMessage()); } msgbuf.append("\n"); if (author == null) { author = c.getAuthorIdent(); } else if (!author.equals(c.getAuthorIdent())) { sameAuthorForAll = false; } } if (!sameAuthorForAll || author == null) { author = myIdent; } pdb = repoManager.openRepository(subscriber.getParentKey()); if (pdb.getRef(subscriber.get()) == null) { throw new SubmoduleException("The branch was probably deleted from the subscriber repository"); } final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId(); DirCache dc = readTree(pdb, pdb.getRef(subscriber.get())); DirCacheEditor ed = dc.editor(); for (final Map.Entry 
       <branch.namekey, objectid>
         me : modules.entrySet()) { ed.add(new PathEdit(paths.get(me.getKey())) { public void apply(DirCacheEntry ent) { ent.setFileMode(FileMode.GITLINK); ent.setObjectId(me.getValue().copy()); } }); } ed.finish(); ObjectInserter oi = pdb.newObjectInserter(); ObjectId tree = dc.writeTree(oi); final CommitBuilder commit = new CommitBuilder(); commit.setTreeId(tree); commit.setParentIds(new ObjectId[] { currentCommitId }); commit.setAuthor(author); commit.setCommitter(myIdent); commit.setMessage(msgbuf.toString()); oi.insert(commit); ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build()); final RefUpdate rfu = pdb.updateRef(subscriber.get()); rfu.setForceUpdate(false); rfu.setNewObjectId(commitId); rfu.setExpectedOldObjectId(currentCommitId); rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true); switch(rfu.update()) { case NEW: case FAST_FORWARD: replication.fire(subscriber.getParentKey(), rfu.getName()); // TODO since this is performed "in the background" no mail will be // sent to inform users about the updated branch break; default: throw new IOException(rfu.getResult().name()); } recRw = new RevWalk(pdb); // Recursive call: update subscribers of the subscriber updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString()); } catch (IOException e) { logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e); } finally { if (recRw != null) { recRw.release(); } if (pdb != null) { pdb.close(); } } 
       </branch.namekey,> 
      </branch.namekey,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4397</td> 
     <td>1242677840</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Edwin Kempin</td> 
     <td>1b761b71738ef0c2b246a737c45c9b0a2bdbadcd</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>updateGitlinks(Branch.NameKey, RevWalk, Map<branch.namekey, objectid>
        , Map 
       <branch.namekey, string>
         , String) 
       </branch.namekey,> 
      </branch.namekey,></td> 
     <td>private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<branch.namekey, objectid>
        modules, final Map 
       <branch.namekey, string>
         paths, final String msg) throws SubmoduleException 
       </branch.namekey,> 
      </branch.namekey,></td> 
     <td> PersonIdent author = null; final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated " + subscriber.getParentKey().get()); Repository pdb = null; RevWalk recRw = null; try { boolean sameAuthorForAll = true; for (final Map.Entry<branch.namekey, objectid>
        me : modules.entrySet()) { RevCommit c = myRw.parseCommit(me.getValue()); msgbuf.append("\nProject: "); msgbuf.append(me.getKey().getParentKey().get()); msgbuf.append(" " + me.getValue().getName()); msgbuf.append("\n"); if (modules.size() == 1 &amp;&amp; msg != null) { msgbuf.append(msg); } else { msgbuf.append(c.getShortMessage()); } msgbuf.append("\n"); if (author == null) { author = c.getAuthorIdent(); } else if (!author.equals(c.getAuthorIdent())) { sameAuthorForAll = false; } } if (!sameAuthorForAll || author == null) { author = myIdent; } pdb = repoManager.openRepository(subscriber.getParentKey()); if (pdb.getRef(subscriber.get()) == null) { throw new SubmoduleException("The branch was probably deleted from the subscriber repository"); } final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId(); DirCache dc = readTree(pdb, pdb.getRef(subscriber.get())); DirCacheEditor ed = dc.editor(); for (final Map.Entry 
       <branch.namekey, objectid>
         me : modules.entrySet()) { ed.add(new PathEdit(paths.get(me.getKey())) { public void apply(DirCacheEntry ent) { ent.setFileMode(FileMode.GITLINK); ent.setObjectId(me.getValue().copy()); } }); } ed.finish(); ObjectInserter oi = pdb.newObjectInserter(); ObjectId tree = dc.writeTree(oi); final CommitBuilder commit = new CommitBuilder(); commit.setTreeId(tree); commit.setParentIds(new ObjectId[] { currentCommitId }); commit.setAuthor(author); commit.setCommitter(myIdent); commit.setMessage(msgbuf.toString()); oi.insert(commit); ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build()); final RefUpdate rfu = pdb.updateRef(subscriber.get()); rfu.setForceUpdate(false); rfu.setNewObjectId(commitId); rfu.setExpectedOldObjectId(currentCommitId); rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true); switch(rfu.update()) { case NEW: case FAST_FORWARD: replication.fire(subscriber.getParentKey(), rfu.getName()); // TODO since this is performed "in the background" no mail will be // sent to inform users about the updated branch break; default: throw new IOException(rfu.getResult().name()); } recRw = new RevWalk(pdb); // Recursive call: update subscribers of the subscriber updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString()); } catch (IOException e) { logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e); } finally { if (recRw != null) { recRw.release(); } if (pdb != null) { pdb.close(); } } 
       </branch.namekey,> 
      </branch.namekey,></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4357</td> 
     <td>1242677840</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Fredrik Luthander</td>
     <td>d15704079c2f820995ee70e7403dfa7ebcb3d791</td> 
     <td>None</td> 
     <td>TODO since this is performed \"in the background\" no mail will be sent to inform users about the updated branch</td> 
     <td>SATD_ADDED</td> 
     <td>updateGitlinks(Branch.NameKey, Map<branch.namekey, objectid>
       , Map
       <branch.namekey, string>
        , String)
       </branch.namekey,>
      </branch.namekey,></td> 
     <td>private void updateGitlinks(final Branch.NameKey subscriber, final Map<branch.namekey, objectid>
        modules, final Map
       <branch.namekey, string>
         paths, final String msg) throws SubmoduleException
       </branch.namekey,>
      </branch.namekey,></td> 
     <td> PersonIdent author = null; final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated " + subscriber.getParentKey().get()); Repository pdb = null; try { boolean sameAuthorForAll = true; for (final Map.Entry<branch.namekey, objectid>
        me : modules.entrySet()) { RevCommit c = rw.parseCommit(me.getValue()); msgbuf.append("\nProject: "); msgbuf.append(me.getKey().getParentKey().get()); msgbuf.append(" " + me.getValue().getName()); msgbuf.append("\n"); if (modules.size() == 1 &amp;&amp; msg != null) { msgbuf.append(msg); } else { msgbuf.append(c.getShortMessage()); } msgbuf.append("\n"); if (author == null) { author = c.getAuthorIdent(); } else if (!author.equals(c.getAuthorIdent())) { sameAuthorForAll = false; } } if (!sameAuthorForAll || author == null) { author = myIdent; } pdb = repoManager.openRepository(subscriber.getParentKey()); if (pdb.getRef(subscriber.get()) == null) { throw new SubmoduleException("The branch was probably deleted from the subscriber repository"); } final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId(); DirCache dc = readTree(pdb, pdb.getRef(subscriber.get())); DirCacheEditor ed = dc.editor(); for (final Map.Entry
       <branch.namekey, objectid>
         me : modules.entrySet()) { ed.add(new PathEdit(paths.get(me.getKey())) { public void apply(DirCacheEntry ent) { ent.setFileMode(FileMode.GITLINK); ent.setObjectId(me.getValue().copy()); } }); } ed.finish(); ObjectInserter oi = pdb.newObjectInserter(); ObjectId tree = dc.writeTree(oi); final CommitBuilder commit = new CommitBuilder(); commit.setTreeId(tree); commit.setParentIds(new ObjectId[] { currentCommitId }); commit.setAuthor(author); commit.setCommitter(myIdent); commit.setMessage(msgbuf.toString()); oi.insert(commit); ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build()); final RefUpdate rfu = pdb.updateRef(subscriber.get()); rfu.setForceUpdate(false); rfu.setNewObjectId(commitId); rfu.setExpectedOldObjectId(currentCommitId); rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true); switch(rfu.update()) { case NEW: case FAST_FORWARD: replication.scheduleUpdate(subscriber.getParentKey(), rfu.getName()); // TODO since this is performed "in the background" no mail will be // sent to inform users about the updated branch break; default: throw new IOException(rfu.getResult().name()); } // Recursive call: update subscribers of the subscriber updateSuperProjects(subscriber, commitId, msgbuf.toString()); } catch (IOException e) { logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e); } finally { if (pdb != null) { pdb.close(); } } 
       </branch.namekey,>
      </branch.namekey,></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>