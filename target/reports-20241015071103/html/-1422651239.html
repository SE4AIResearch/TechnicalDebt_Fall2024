<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2001</td> 
     <td>-1422651239</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>3b6fdf1f67f949b7636b30ba6f5a0ea522f3e293</td> 
     <td>TODO: We should also consider processors which are not services then we can manage all processors as well otherwise its only the processors which is a Service</td> 
     <td>callback that we are staring these services</td> 
     <td>SATD_REMOVED</td> 
     <td>warmUp()</td> 
     <td>public synchronized void warmUp() throws Exception</td> 
     <td> if (warmUpDone.compareAndSet(false, true)) { for (Route route : routes) { if (LOG.isTraceEnabled()) { LOG.trace("Starting route services: " + route); } List<service>
        services = route.getServices(); // callback that we are staring these services route.onStartingServices(services); // gather list of services to start as we need to start child services as well Set 
       <service>
         list = new LinkedHashSet 
        <service>
          (); for (Service service : services) { doGetChildServices(list, service); } // split into consumers and child services as we need to start the consumers // afterwards to avoid them being active while the others start List 
         <service>
           childServices = new ArrayList 
          <service>
            (); for (Service service : list) { if (service instanceof Consumer) { inputs.put(route, (Consumer) service); } else { childServices.add(service); } } startChildService(route, childServices); } // ensure lifecycle strategy is invoked which among others enlist the route in JMX for (LifecycleStrategy strategy : camelContext.getLifecycleStrategies()) { strategy.onRoutesAdd(routes); } // add routes to camel context camelContext.addRouteCollection(routes); } 
          </service> 
         </service> 
        </service> 
       </service> 
      </service></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1998</td> 
     <td>-1422651239</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>1dc65f4a6b79f27582d05d8902639707f2a598b4</td> 
     <td>TODO: We should also consider processors which are not services then we can manage all processors as well otherwise its only the processors which is a Service</td> 
     <td>TODO: We should also consider processors which are not services then we can manage all processors as well otherwise its only the processors which is a Service</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>warmUp()</td> 
     <td>public void warmUp() throws Exception</td> 
     <td> camelContext.addRouteCollection(routes); for (LifecycleStrategy strategy : camelContext.getLifecycleStrategies()) { strategy.onRoutesAdd(routes); } for (Route route : routes) { if (LOG.isTraceEnabled()) { LOG.trace("Starting route services: " + route); } // TODO: We should also consider processors which are not services then we can manage all processors as well // otherwise its only the processors which is a Service List<service>
        services = route.getServices(); // callback that we are staring these services route.onStartingServices(services); // gather list of services to start as we need to start child services as well List 
       <service>
         list = new ArrayList 
        <service>
          (); for (Service service : services) { doGetChildServices(list, service); } // split into consumers and child services as we need to start the consumers // afterwards to avoid them being active while the others start List 
         <service>
           childServices = new ArrayList 
          <service>
            (); for (Service service : list) { if (service instanceof Consumer) { inputs.put(route, (Consumer) service); } else { childServices.add(service); } } startChildService(route, childServices); } warmUpDone.set(true); 
          </service> 
         </service> 
        </service> 
       </service> 
      </service></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1574</td> 
     <td>-1422651239</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>43b328d9de9907552dd2e9a2c2045786387a578c</td> 
     <td>None</td> 
     <td>TODO: We should also consider processors which are not services then we can manage all processors as well otherwise its only the processors which is a Service</td> 
     <td>SATD_ADDED</td> 
     <td>doStart()</td> 
     <td>protected void doStart() throws Exception</td> 
     <td> camelContext.addRouteCollection(routes); for (LifecycleStrategy strategy : camelContext.getLifecycleStrategies()) { strategy.onRoutesAdd(routes); } for (Route route : routes) { if (LOG.isTraceEnabled()) { LOG.trace("Starting route services: " + route); } // TODO: We should also consider processors which are not services then we can manage all processors as well // otherwise its only the processors which is a Service List<service>
        services = route.getServices(); // callback that we are staring these services route.onStartingServices(services); // gather list of services to start as we need to start child services as well List
       <service>
         list = new ArrayList
        <service>
         (); for (Service service : services) { doGetChildServies(list, service); } // split into consumers and child services as we need to start the consumers // afterwards to avoid them being active while the others start List
         <service>
           childServices = new ArrayList
          <service>
           (); for (Service service : list) { if (service instanceof Consumer) { inputs.put(route, (Consumer) service); } else { childServices.add(service); } } startChildService(route, childServices); // start the route itself ServiceHelper.startService(route); // fire event EventHelper.notifyRouteStarted(camelContext, route); } if (startInputs) { // start the input consumers for (Map.Entry
           <route, consumer>
             entry : inputs.entrySet()) { Route route = entry.getKey(); Consumer consumer = entry.getValue(); startChildService(route, consumer); } } 
           </route,>
          </service>
         </service>
        </service>
       </service>
      </service></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>