<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5563</td> <td>-1009652163</td><td>apache/hadoop</td><td>Eli Collins</td><td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> <td>None</td> <td>Do a small regular read. Very likely this will leave unread
data on the socket and make the socket uncacheable.</td> <td>SATD_ADDED</td> <td>run()</td> <td>public void run()</td> <td>
    for (int i = 0; i < N_ITERATIONS; ++i) {
        int startOff = rand.nextInt((int) fileSize);
        int len = 0;
        try {
            double p = rand.nextDouble();
            if (p < PROPORTION_NON_POSITIONAL_READ) {
                // Do a small regular read. Very likely this will leave unread
                // data on the socket and make the socket uncacheable.
                len = Math.min(rand.nextInt(64), (int) fileSize - startOff);
                read(startOff, len);
                bytesRead += len;
            } else {
                // Do a positional read most of the time.
                len = rand.nextInt((int) (fileSize - startOff));
                pRead(startOff, len);
                bytesRead += len;
            }
        } catch (Exception ex) {
            LOG.error(getName() + ": Error while testing read at " + startOff + " length " + len);
            error = true;
            fail(ex.getMessage());
        }
    }
</td> </tr></table></body></html>