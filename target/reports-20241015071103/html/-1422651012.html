<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1987</td> <td>-1422651012</td><td>apache/camel</td><td>Ashwin J. Karpe</td><td>e61a65ed2ee41c78c324d795d7d1c8da3077ce3e</td> <td>None</td> <td>Test whether user's role is authorized to perform functions in the permissions list</td> <td>SATD_ADDED</td> <td>wrap(RouteContext, Processor)</td> <td>public Processor wrap(RouteContext routeContext, final Processor processor)</td> <td>
    return new AsyncProcessor() {

        public boolean process(Exchange exchange, final AsyncCallback callback) {
            boolean sync = false;
            try {
                applySecurityPolicy(exchange);
            } catch (Exception e) {
                exchange.setException(e);
            }
            // If here, then user is authenticated and authorized
            // Now let the original processor continue routing
            AsyncProcessor ap = AsyncProcessorTypeConverter.convert(processor);
            sync = ap.process(exchange, new AsyncCallback() {

                public void done(boolean doneSync) {
                    // we only have to handle async completion of this policy
                    if (doneSync) {
                        return;
                    }
                    callback.done(false);
                }
            });
            if (!sync) {
                // if async, continue routing async
                return false;
            }
            // we are done synchronously, so do our after work and invoke the callback
            callback.done(true);
            return true;
        }

        public void process(Exchange exchange) throws Exception {
            applySecurityPolicy(exchange);
            processor.process(exchange);
        }

        private void applySecurityPolicy(Exchange exchange) throws Exception {
            ByteSource encryptedToken = (ByteSource) exchange.getIn().getHeader("SHIRO_SECURITY_TOKEN");
            ByteSource decryptedToken = getCipherService().decrypt(encryptedToken.getBytes(), getPassPhrase());
            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(decryptedToken.getBytes());
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
            ShiroSecurityToken securityToken = (ShiroSecurityToken) objectInputStream.readObject();
            objectInputStream.close();
            byteArrayInputStream.close();
            Subject currentUser = SecurityUtils.getSubject();
            // Authenticate user if not authenticated
            try {
                authenticateUser(currentUser, securityToken);
                // Test whether user's role is authorized to perform functions in the permissions list
                authorizeUser(currentUser, exchange);
            } finally {
                if (alwaysReauthenticate) {
                    currentUser.logout();
                    currentUser = null;
                }
            }
        }
    };
</td> </tr></table></body></html>