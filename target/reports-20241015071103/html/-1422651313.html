<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1895</td> 
     <td>-1422651313</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>a24f83b12e90ce52f41c256dea6e4b9b7528ee2a</td> 
     <td>whether we should trace it or not, some nodes should be skipped as they are abstract intermediate steps for instance related to on completion</td> 
     <td>whether we should trace it or not, some nodes should be skipped as they are abstract intermediate steps for instance related to on completion</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>process(Exchange, AsyncCallback)</td> 
     <td>public boolean process(Exchange exchange, AsyncCallback callback)</td> 
     <td> // do not trace if tracing is disabled if (!tracer.isEnabled() || (routeContext != null &amp;&amp; !routeContext.isTracing())) { return super.process(exchange, callback); } // interceptor will also trace routes supposed only for TraceEvents so we need to skip // logging TraceEvents to avoid infinite looping if (exchange.getProperty(Exchange.TRACE_EVENT, false, Boolean.class)) { // but we must still process to allow routing of TraceEvents to eg a JPA endpoint return super.process(exchange, callback); } boolean shouldLog = shouldLogNode(node) &amp;&amp; shouldLogExchange(exchange); // whether we should trace it or not, some nodes should be skipped as they are abstract // intermediate steps for instance related to on completion boolean trace = true; boolean sync = true; // okay this is a regular exchange being routed we might need to log and trace try { // before if (shouldLog) { // traced holds the information about the current traced route path if (exchange.getUnitOfWork() != null) { TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes(); if (node instanceof OnCompletionDefinition || node instanceof OnExceptionDefinition) { // skip any of these as its just a marker definition trace = false; } else if (ProcessorDefinitionHelper.isFirstChildOfType(OnCompletionDefinition.class, node)) { // special for on completion tracing traceOnCompletion(traced, exchange); } else if (ProcessorDefinitionHelper.isFirstChildOfType(OnExceptionDefinition.class, node)) { // special for on exception traceOnException(traced, exchange); } else if (ProcessorDefinitionHelper.isFirstChildOfType(CatchDefinition.class, node)) { // special for do catch traceDoCatch(traced, exchange); } else if (ProcessorDefinitionHelper.isFirstChildOfType(FinallyDefinition.class, node)) { // special for do finally traceDoFinally(traced, exchange); } else if (ProcessorDefinitionHelper.isFirstChildOfType(AggregateDefinition.class, node)) { // special for aggregate traceAggregate(traced, exchange); } else { // regular so just add it traced.addTraced(new DefaultRouteNode(node, super.getProcessor())); } } else { if (LOG.isTraceEnabled()) { LOG.trace("Cannot trace as this Exchange does not have an UnitOfWork: " + exchange); } } } // log and trace the processor Object traceState = null; if (shouldLog &amp;&amp; trace) { logExchange(exchange); // either call the in or generic trace method depending on OUT has been enabled or not if (tracer.isTraceOutExchanges()) { traceState = traceExchangeIn(exchange); } else { traceExchange(exchange); } } try { // special for interceptor where we need to keep booking how far we have routed in the intercepted processors if (node.getParent() instanceof InterceptDefinition &amp;&amp; exchange.getUnitOfWork() != null) { TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes(); traceIntercept((InterceptDefinition) node.getParent(), traced, exchange); } // process the exchange try { sync = super.process(exchange, callback); } catch (Exception e) { exchange.setException(e); } } finally { // after (trace out) if (shouldLog &amp;&amp; tracer.isTraceOutExchanges()) { logExchange(exchange); traceExchangeOut(exchange, traceState); } } } catch (Exception e) { // some exception occurred in trace logic if (shouldLogException(exchange)) { logException(exchange, e); } exchange.setException(e); } callback.done(sync); return sync; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1643</td> 
     <td>-1422651313</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>a3b8bbb956f700264da57c7e9d8f95d1f5625d3c</td> 
     <td>whether we should trace it or not, some nodes should be skipped as they are abstract intermedidate steps for instance related to on completion</td> 
     <td>whether we should trace it or not, some nodes should be skipped as they are abstract intermediate steps for instance related to on completion</td> 
     <td>SATD_CHANGED</td> 
     <td>process(Exchange)</td> 
     <td>public void process(final Exchange exchange) throws Exception</td> 
     <td> // do not trace if tracing is disabled if (!tracer.isEnabled() || (routeContext != null &amp;&amp; !routeContext.isTracing())) { super.proceed(exchange); return; } // interceptor will also trace routes supposed only for TraceEvents so we need to skip // logging TraceEvents to avoid infinite looping if (exchange.getProperty(Exchange.TRACE_EVENT, Boolean.class) != null) { // but we must still process to allow routing of TraceEvents to eg a JPA endpoint super.process(exchange); return; } boolean shouldLog = shouldLogNode(node) &amp;&amp; shouldLogExchange(exchange); // whether we should trace it or not, some nodes should be skipped as they are abstract // intermediate steps for instance related to on completion boolean trace = true; // okay this is a regular exchange being routed we might need to log and trace try { // before if (shouldLog) { // traced holds the information about the current traced route path if (exchange.getUnitOfWork() != null) { TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes(); if (node instanceof OnCompletionDefinition || node instanceof OnExceptionDefinition || node instanceof TryDefinition) { // skip any of these as its just a marker definition trace = false; } else if (exchange.getProperty(Exchange.ON_COMPLETION) != null) { // special for on completion tracing traceOnCompletion(traced, exchange); } else { // regular so just add it traced.addTraced(new DefaultRouteNode(node, super.getProcessor())); } } else { LOG.trace("Cannot trace as this Exchange does not have an UnitOfWork: " + exchange); } } // log and trace the processor if (shouldLog &amp;&amp; trace) { logExchange(exchange); traceExchange(exchange); } // special for interceptor where we need to keep booking how far we have routed in the intercepted processors if (node.getParent() instanceof InterceptDefinition &amp;&amp; exchange.getUnitOfWork() != null) { TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes(); traceIntercept((InterceptDefinition) node.getParent(), traced, exchange); } // process the exchange super.proceed(exchange); // after (trace out) if (shouldLog &amp;&amp; tracer.isTraceOutExchanges()) { logExchange(exchange); traceExchange(exchange); } } catch (Exception e) { if (shouldLogException(exchange)) { logException(exchange, e); } throw e; } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1440</td> 
     <td>-1422651313</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>c4e4e78eb90a7685d9549c3769af24120a4109c2</td> 
     <td>TODO: refactor into smaller methods TODO: add code comments about why we do this</td> 
     <td>whether we should trace it or not, some nodes should be skipped as they are abstract intermedidate steps for instance related to on completion</td> 
     <td>SATD_CHANGED</td> 
     <td>process(Exchange)</td> 
     <td>public void process(final Exchange exchange) throws Exception</td> 
     <td> // interceptor will also trace routes supposed only for TraceEvents so we need to skip // logging TraceEvents to avoid infinite looping if (exchange instanceof TraceEventExchange || exchange.getProperty(TRACE_EVENT, Boolean.class) != null) { // but we must still process to allow routing of TraceEvents to eg a JPA endpoint super.process(exchange); return; } boolean shouldLog = shouldLogNode(node) &amp;&amp; shouldLogExchange(exchange); // okay this is a regular exchange being routed we might need to log and trace try { // before if (shouldLog) { // whether we should trace it or not, some nodes should be skipped as they are abstract // intermedidate steps for instance related to on completion boolean trace = true; // if traceable then register this as the previous node, now it has been logged if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) { TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork(); if (node instanceof OnExceptionDefinition) { // special for on exception so we can see it in the trace logs trace = beforeOnException((OnExceptionDefinition) node, tuow, exchange); } else if (node instanceof OnCompletionDefinition) { // special for on completion so we can see it in the trace logs trace = beforeOnCompletion((OnCompletionDefinition) node, tuow, exchange); } else { // regular so just add it tuow.addTraced(new DefaultRouteNode(node, super.getProcessor())); } } // log and trace the processor if (trace) { logExchange(exchange); traceExchange(exchange); } // some nodes need extra work to trace it if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) { TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork(); if (node instanceof InterceptDefinition) { // special for intercept() as we would like to trace the processor that was intercepted // as well, otherwise we only see the intercepted route, but we need the both to be logged/traced afterIntercept((InterceptDefinition) node, tuow, exchange); } } } // process the exchange super.proceed(exchange); // after (trace out) if (shouldLog &amp;&amp; tracer.isTraceOutExchanges()) { logExchange(exchange); traceExchange(exchange); } } catch (Exception e) { if (shouldLogException(exchange)) { logException(exchange, e); } throw e; } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1439</td> 
     <td>-1422651313</td>
     <td>apache/camel</td>
     <td>Moulliard Charles</td>
     <td>ddf65794901c42c5dfcbf93653e83087f3650964</td> 
     <td>None</td> 
     <td>TODO: refactor into smaller methods TODO: add code comments about why we do this</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange)</td> 
     <td>public void process(final Exchange exchange) throws Exception</td> 
     <td> // interceptor will also trace routes supposed only for TraceEvents so we need to skip // logging TraceEvents to avoid infinite looping if (exchange instanceof TraceEventExchange || exchange.getProperty(TRACE_EVENT, Boolean.class) != null) { // but we must still process to allow routing of TraceEvents to eg a JPA endpoint super.process(exchange); return; } boolean shouldLog = shouldLogNode(node) &amp;&amp; shouldLogExchange(exchange); // okay this is a regular exchange being routed we might need to log and trace try { // before if (shouldLog) { // TODO: refactor into smaller methods // TODO: add code comments about why we do this boolean trace = true; // if traceable then register this as the previous node, now it has been logged if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) { TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork(); // special for on exception so we can see it in the trace logs if (node instanceof OnExceptionDefinition) { // lets see if this is the first time for this exception int index = tuow.getAndIncrement(node); if (index == 0) { Expression exp = new Expression() { public <t>
        T evaluate(Exchange exchange, Class
       <t>
         type) { String label = "OnException"; if (exchange.getProperty(Exchange.EXCEPTION_CAUGHT) != null) { label += "[" + exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class).getClass().getSimpleName() + "]"; } return exchange.getContext().getTypeConverter().convertTo(type, label); } }; // yes its first time then do some special to log and trace the start of onException tuow.addTraced(new DefaultRouteNode(node, exp)); // log and trace the processor that was onException so we can see it logExchange(exchange); traceExchange(exchange); } tuow.addTraced(new DefaultRouteNode(node, super.getProcessor())); } else if (node instanceof OnCompletionDefinition) { trace = tuow.getLastNode() != null; if (exchange.getProperty(Exchange.ON_COMPLETION) != null) { // we should trace the onCompletion route int index = tuow.getAndIncrement(node); if (index == 0) { // yes its first time then do some special to log and trace the start of onCompletion Expression exp = new Expression() { public 
        <t>
          T evaluate(Exchange exchange, Class
         <t>
           type) { String label = "OnCompletion[" + exchange.getProperty(Exchange.CORRELATION_ID) + "]"; return exchange.getContext().getTypeConverter().convertTo(type, label); } }; tuow.addTraced(new DefaultRouteNode(node, exp)); tuow.addTraced(new DefaultRouteNode(node, super.getProcessor())); // log and trace the processor that was onCompletion so we can see it logExchange(exchange); traceExchange(exchange); } else { tuow.addTraced(new DefaultRouteNode(node, super.getProcessor())); } } } else { tuow.addTraced(new DefaultRouteNode(node, super.getProcessor())); } } // log and trace the processor if (trace) { logExchange(exchange); traceExchange(exchange); } // some nodes need extra work to trace it if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) { TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork(); // special for intercept() as we would like to trace the processor that was intercepted // as well, otherwise we only see the intercepted route, but we need the both to be logged/traced if (node instanceof InterceptDefinition) { // get the intercepted processor from the definition // we need to use the UoW to have its own index of how far we got into the list // of intercepted processors the intercept definition holds as the intercept // definition is a single object that is shared by concurrent thread being routed // so each exchange has its own private counter InterceptDefinition intercept = (InterceptDefinition) node; Processor last = intercept.getInterceptedProcessor(tuow.getAndIncrement(intercept)); if (last != null) { tuow.addTraced(new DefaultRouteNode(node, last)); // log and trace the processor that was intercepted so we can see it logExchange(exchange); traceExchange(exchange); } } } } // process the exchange super.proceed(exchange); // after (trace out) if (shouldLog &amp;&amp; tracer.isTraceOutExchanges()) { logExchange(exchange); traceExchange(exchange); } } catch (Exception e) { if (shouldLogException(exchange)) { logException(exchange, e); } throw e; } 
         </t>
        </t>
       </t>
      </t></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>