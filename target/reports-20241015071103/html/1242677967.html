<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4595</td> <td>1242677967</td><td>GerritCodeReview/gerrit</td><td>Dave Borowitz</td><td>05b254feb29c83f73f23410edbe104bcf37e164b</td> <td>None</td> <td>indexed data should depend on what user is doing the indexing.</td> <td>SATD_ADDED</td> <td>configure()</td> <td>protected void configure()</td> <td>
    install(PatchListCacheImpl.module());
    install(dbInjector.getInstance(AuthModule.class));
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(new ReviewDbModule());
    install(ProjectCacheImpl.module());
    install(new PluginModule());
    install(new PrologModule());
    install(new DefaultCacheFactory.Module());
    install(NoSshKeyCache.module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(GroupCacheImpl.module());
    install(new AccessControlModule());
    install(SectionSortCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            install(new LuceneIndexModule(version, threads, outputBase));
            break;
        case SOLR:
            install(new SolrIndexModule(false, threads, outputBase));
            break;
        default:
            install(new NoIndexModule());
    }
    // No need to support live plugin removal or other live updates of
    // caches behind our back, so don't worry about cache removal.
    bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
    }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
    // Assume the current user is always the Gerrit internal user; no
    // indexed data should depend on what user is doing the indexing.
    bind(CurrentUser.class).to(InternalUser.class);
    bind(ChangeHooks.class).to(DisabledChangeHooks.class);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ProjectControl.GenericFactory.class);
    factory(CapabilityControl.Factory.class);
    factory(IncludingGroupMembership.Factory.class);
    factory(InternalUser.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    install(GroupIncludeCacheImpl.module());
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(EmailSender.class).toInstance(new EmailSender() {

        @Override
        public boolean isEnabled() {
            return false;
        }

        @Override
        public boolean canEmail(String address) {
            return false;
        }

        @Override
        public void send(Address from, Collection<Address> rcpt, Map<String, EmailHeader> headers, String body) throws EmailException {
        }
    });
</td> </tr></table></body></html>