<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1415</td> 
     <td>-1422651327</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>b2bee1a966adb03063c9e6e3e22bfd5ebf2ae52c</td> 
     <td>TODO: divde into onException and deadLetterQueue no then move it to the dead letter queue</td> 
     <td>no we should not redeliver to the same output so either try an onException (if any given) or the dead letter queue</td> 
     <td>SATD_REMOVED</td> 
     <td>processErrorHandler(Exchange, RedeliveryData)</td> 
     <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); return; } } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return; } // did previous processing cause an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // no we should not redeliver to the same output so either try an onException (if any given) // or the dead letter queue Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; // deliver to the failure processor (either an on exception or dead letter queue deliverToFailureProcessor(target, exchange, data); // prepare the exchange for failure before returning prepareExchangeAfterFailure(exchange, data); // and then return return; } // if we are redelivering then sleep before trying again if (shouldRedeliver &amp;&amp; data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange (also redelivery) try { output.process(exchange); } catch (Exception e) { exchange.setException(e); } // only done if the exchange hasn't failed // and it has not been handled by the failure processor boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange); if (done) { return; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1409</td> 
     <td>-1422651327</td>
     <td>apache/camel</td>
     <td>William Tam</td>
     <td>7aa107f96e03eed7f231a5799019de46296df91f</td> 
     <td>None</td> 
     <td>TODO: divde into onException and deadLetterQueue no then move it to the dead letter queue</td> 
     <td>SATD_ADDED</td> 
     <td>processErrorHandler(Exchange, RedeliveryData)</td> 
     <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); return; } } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // TODO: divde into onException and deadLetterQueue // no then move it to the dead letter queue deliverToFailureProcessor(exchange, data); // prepare the exchange for failure prepareExchangeAfterFailure(exchange, data); // we could not process the exchange succesfully so break return; } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange try { output.process(exchange); } catch (Exception e) { exchange.setException(e); } // only process if the exchange hasn't failed // and it has not been handled by the error processor boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange); if (done) { return; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>