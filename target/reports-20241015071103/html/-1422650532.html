<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2802</td> <td>-1422650532</td><td>apache/camel</td><td>Claus Ibsen</td><td>6d05326fa18af21d8ce70a460eba741bfd5ba79a</td> <td>None</td> <td>Consumer threads are managed at the endpoint to achieve the optimal performance.
However, both multiple consumers (pub-sub style multicasting) as well as 'worker-pool' consumers dividing
exchanges amongst them are scheduled on their own threads and are provided with all exchanges.
To prevent duplicate exchange processing by worker-pool event handlers, they are all given an ordinal,
which can be used to determine whether he should process the exchange, or leave it for his brethren.
see http://code.google.com/p/disruptor/wiki/FrequentlyAskedQuestions#How_do_you_arrange_a_Disruptor_with_multiple_consumers_so_that_e</td> <td>SATD_ADDED</td> <td>onEvent(ExchangeEvent, long, boolean)</td> <td>public void onEvent(final ExchangeEvent event, final long sequence, final boolean endOfBatch) throws Exception</td> <td>
    // Consumer threads are managed at the endpoint to achieve the optimal performance.
    // However, both multiple consumers (pub-sub style multicasting) as well as 'worker-pool' consumers dividing
    // exchanges amongst them are scheduled on their own threads and are provided with all exchanges.
    // To prevent duplicate exchange processing by worker-pool event handlers, they are all given an ordinal,
    // which can be used to determine whether he should process the exchange, or leave it for his brethren.
    // see http://code.google.com/p/disruptor/wiki/FrequentlyAskedQuestions#How_do_you_arrange_a_Disruptor_with_multiple_consumers_so_that_e
    if (sequence % concurrentConsumers == ordinal) {
        try {
            process(event);
        } catch (Exception e) {
            final Exchange exchange = event.getExchange();
            if (exchange != null) {
                getExceptionHandler().handleException("Error processing exchange", exchange, e);
            } else {
                getExceptionHandler().handleException(e);
            }
        }
    }
</td> </tr></table></body></html>