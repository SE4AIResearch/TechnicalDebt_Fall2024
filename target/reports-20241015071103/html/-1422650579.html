<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2752</td> 
     <td>-1422650579</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>b67f5f903275776f619d536c172682965e14dcd3</td> 
     <td>TODO: keep alive should be something we can control</td> 
     <td>configure connection to accordingly to keep alive configuration favor using the header from the message</td> 
     <td>SATD_REMOVED</td> 
     <td>toNettyResponse(Message, NettyHttpConfiguration)</td> 
     <td>public HttpResponse toNettyResponse(Message message, NettyHttpConfiguration configuration) throws Exception</td> 
     <td> LOG.trace("toNettyResponse: {}", message); // the message body may already be a Netty HTTP response if (message.getBody() instanceof HttpResponse) { return (HttpResponse) message.getBody(); } // the response code is 200 for OK and 500 for failed boolean failed = message.getExchange().isFailed(); int defaultCode = failed ? 500 : 200; int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class); HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code)); LOG.trace("HTTP Status Code: {}", code); TypeConverter tc = message.getExchange().getContext().getTypeConverter(); // append headers // must use entrySet to ensure case of keys is preserved for (Map.Entry<string, object>
        entry : message.getHeaders().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); // use an iterator as there can be multiple values. (must not use a delimiter) final Iterator<!--?--> it = ObjectHelper.createIterator(value, null); while (it.hasNext()) { String headerValue = tc.convertTo(String.class, it.next()); if (headerValue != null &amp;&amp; headerFilterStrategy != null &amp;&amp; !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) { LOG.trace("HTTP-Header: {}={}", key, headerValue); response.addHeader(key, headerValue); } } } Object body = message.getBody(); Exception cause = message.getExchange().getException(); if (body != null || cause != null) { // support bodies as native Netty ChannelBuffer buffer; // if there was an exception then use that as body if (cause != null) { if (configuration.isTransferException()) { // we failed due an exception, and transfer it as java serialized object ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(cause); oos.flush(); IOHelper.close(oos, bos); // the body should be the serialized java object of the exception body = ChannelBuffers.copiedBuffer(bos.toByteArray()); // force content type to be serialized java object message.setHeader(Exchange.CONTENT_TYPE, NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT); } else { // we failed due an exception so print it as plain text StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); cause.printStackTrace(pw); // the body should then be the stacktrace body = ChannelBuffers.copiedBuffer(sw.toString().getBytes()); // force content type to be text/plain as that is what the stacktrace is message.setHeader(Exchange.CONTENT_TYPE, "text/plain"); } // and mark the exception as failure handled, as we handled it by returning it as the response ExchangeHelper.setFailureHandled(message.getExchange()); } if (body instanceof ChannelBuffer) { buffer = (ChannelBuffer) body; } else { // try to convert to buffer first buffer = message.getBody(ChannelBuffer.class); if (buffer == null) { // fallback to byte array as last resort byte[] data = message.getBody(byte[].class); if (data != null) { buffer = ChannelBuffers.copiedBuffer(data); } else { // and if byte array fails then try String String str = message.getMandatoryBody(String.class); buffer = ChannelBuffers.copiedBuffer(str.getBytes()); } } } if (buffer != null) { response.setContent(buffer); int len = buffer.readableBytes(); // set content-length response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, len); LOG.trace("Content-Length: {}", len); } } // set the content type in the response. String contentType = MessageHelper.getContentType(message); if (contentType != null) { // set content-type response.setHeader(HttpHeaders.Names.CONTENT_TYPE, contentType); LOG.trace("Content-Type: {}", contentType); } // configure connection to accordingly to keep alive configuration // favor using the header from the message String connection = message.getHeader(HttpHeaders.Names.CONNECTION, String.class); if (connection == null) { // fallback and use the keep alive from the configuration if (configuration.isKeepAlive()) { connection = HttpHeaders.Values.KEEP_ALIVE; } else { connection = HttpHeaders.Values.CLOSE; } } response.setHeader(HttpHeaders.Names.CONNECTION, connection); LOG.trace("Connection: {}", connection); return response; 
      </string,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2745</td> 
     <td>-1422650579</td> 
     <td>apache/camel</td> 
     <td>Babak Vahdat</td> 
     <td>ac6a8c16e797fe163984c99bb65d17b468edd1b5</td> 
     <td>TODO: keep alive should be something we can control</td> 
     <td>TODO: keep alive should be something we can control</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>toNettyResponse(Message)</td> 
     <td>public HttpResponse toNettyResponse(Message message) throws Exception</td> 
     <td> LOG.trace("toNettyResponse: {}", message); // the message body may already be a Netty HTTP response if (message.getBody() instanceof HttpResponse) { return (HttpResponse) message.getBody(); } // the status code is default 200, but a header can override that Integer code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, 200, Integer.class); HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code)); LOG.trace("HTTP Status Code: {}", code); TypeConverter tc = message.getExchange().getContext().getTypeConverter(); // append headers // must use entrySet to ensure case of keys is preserved for (Map.Entry<string, object>
        entry : message.getHeaders().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); // use an iterator as there can be multiple values. (must not use a delimiter) final Iterator<!--?--> it = ObjectHelper.createIterator(value, null); while (it.hasNext()) { String headerValue = tc.convertTo(String.class, it.next()); if (headerValue != null &amp;&amp; headerFilterStrategy != null &amp;&amp; !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) { LOG.trace("HTTP-Header: {}={}", key, headerValue); response.addHeader(key, headerValue); } } } Object body = message.getBody(); if (body != null) { // support bodies as native Netty ChannelBuffer buffer; if (body instanceof ChannelBuffer) { buffer = (ChannelBuffer) body; } else { // try to convert to buffer first buffer = message.getBody(ChannelBuffer.class); if (buffer == null) { // fallback to byte array as last resort byte[] data = message.getMandatoryBody(byte[].class); buffer = ChannelBuffers.copiedBuffer(data); } } if (buffer != null) { response.setContent(buffer); int len = buffer.readableBytes(); // set content-length response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, len); LOG.trace("Content-Length: {}", len); } } // set the content type in the response. String contentType = MessageHelper.getContentType(message); if (contentType != null) { // set content-type response.setHeader(HttpHeaders.Names.CONTENT_TYPE, contentType); LOG.trace("Content-Type: {}", contentType); } // TODO: keep alive should be something we can control String keepAlive = HttpHeaders.Values.CLOSE; response.setHeader(HttpHeaders.Names.CONNECTION, keepAlive); LOG.trace("Connection: {}", keepAlive); return response; 
      </string,></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>2738</td> 
     <td>-1422650579</td>
     <td>apache/camel</td>
     <td>Moulliard Charles</td>
     <td>7012efdef4ac214d3d125c5e3ec34c706ad54efd</td> 
     <td>None</td> 
     <td>TODO: keep alive should be something we can control</td> 
     <td>SATD_ADDED</td> 
     <td>fromCamelMessage(Message)</td> 
     <td>public HttpResponse fromCamelMessage(Message message) throws Exception</td> 
     <td> // the status code is default 200, but a header can override that Integer code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, 200, Integer.class); HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code)); TypeConverter tc = message.getExchange().getContext().getTypeConverter(); // append headers // must use entrySet to ensure case of keys is preserved for (Map.Entry<string, object>
        entry : message.getHeaders().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); // use an iterator as there can be multiple values. (must not use a delimiter) final Iterator<!--?--> it = ObjectHelper.createIterator(value, null); while (it.hasNext()) { String headerValue = tc.convertTo(String.class, it.next()); if (headerValue != null &amp;&amp; headerFilterStrategy != null &amp;&amp; !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) { response.addHeader(key, headerValue); } } } Object body = message.getBody(); if (body != null) { // support bodies as native Netty ChannelBuffer buffer; if (body instanceof ChannelBuffer) { buffer = (ChannelBuffer) body; } else { // try to convert to buffer first buffer = message.getBody(ChannelBuffer.class); if (buffer == null) { // fallback to byte array as last resort byte[] data = message.getMandatoryBody(byte[].class); buffer = ChannelBuffers.copiedBuffer(data); } } if (buffer != null) { response.setContent(buffer); response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.readableBytes()); } } // set the content type in the response. String contentType = MessageHelper.getContentType(message); if (contentType != null) { response.setHeader(HttpHeaders.Names.CONTENT_TYPE, contentType); } // TODO: keep alive should be something we can control response.setHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE); return response; 
      </string,></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>