<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4362</td> 
     <td>1242677843</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>1c4013638518442628a4ea6bfd94dbc13ad42aea</td> 
     <td>Send an update on every wakeup (manual or spurious), but only move the spinner every maxInterval.</td> 
     <td>Send an update on every wakeup (manual or spurious), but only move the spinner every maxInterval.</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>waitFor(Future<!--?-->, long, TimeUnit)</td> 
     <td>public void waitFor(final Future<!--?--> workerFuture, final long timeoutTime, final TimeUnit timeoutUnit) throws ExecutionException</td> 
     <td> long overallStart = System.nanoTime(); long deadline; if (timeoutTime &gt; 0) { deadline = overallStart + NANOSECONDS.convert(timeoutTime, timeoutUnit); } else { deadline = 0; } synchronized (this) { long left = maxIntervalNanos; while (!done) { long start = System.nanoTime(); try { NANOSECONDS.timedWait(this, left); } catch (InterruptedException e) { throw new ExecutionException(e); } // Send an update on every wakeup (manual or spurious), but only move // the spinner every maxInterval. long now = System.nanoTime(); if (deadline &gt; 0 &amp;&amp; now &gt; deadline) { log.warn(String.format("MultiProgressMonitor worker killed after %sms", TimeUnit.MILLISECONDS.convert(now - overallStart, NANOSECONDS))); workerFuture.cancel(true); break; } left -= now - start; if (left &lt;= 0) { moveSpinner(); left = maxIntervalNanos; } sendUpdate(); if (!done &amp;&amp; workerFuture.isDone()) { // The worker may not have called end() explicitly, which is likely a // programming error. log.warn("MultiProgressMonitor worker did not call end()" + " before returning"); end(); } } sendDone(); } // The loop exits as soon as the worker calls end(), but we give it another // maxInterval to finish up and return. try { workerFuture.get(maxIntervalNanos, NANOSECONDS); } catch (InterruptedException e) { throw new ExecutionException(e); } catch (CancellationException e) { throw new ExecutionException(e); } catch (TimeoutException e) { workerFuture.cancel(true); throw new ExecutionException(e); } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4361</td> 
     <td>1242677843</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>06cb1d25266b5a0c303c3802d9ab150d84a929e4</td> 
     <td>None</td> 
     <td>Send an update on every wakeup (manual or spurious), but only move the spinner every maxInterval.</td> 
     <td>SATD_ADDED</td> 
     <td>waitFor(Future<!--?-->)</td> 
     <td>public void waitFor(Future<!--?--> workerFuture) throws ExecutionException</td> 
     <td> synchronized (this) { long left = maxIntervalNanos; while (!done) { long start = System.nanoTime(); try { NANOSECONDS.timedWait(this, left); } catch (InterruptedException e) { throw new ExecutionException(e); } // Send an update on every wakeup (manual or spurious), but only move // the spinner every maxInterval. left -= System.nanoTime() - start; if (left &lt;= 0) { moveSpinner(); left = maxIntervalNanos; } sendUpdate(); if (!done &amp;&amp; workerFuture.isDone()) { // The worker may not have called end() explicitly, which is likely a // programming error. log.warn("MultiProgressMonitor worker did not call end()" + " before returning"); end(); } } sendDone(); } // The loop exits as soon as the worker calls end(), but we give it another // maxInterval to finish up and return. try { workerFuture.get(maxIntervalNanos, NANOSECONDS); } catch (InterruptedException e) { throw new ExecutionException(e); } catch (CancellationException e) { throw new ExecutionException(e); } catch (TimeoutException e) { workerFuture.cancel(true); throw new ExecutionException(e); } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>