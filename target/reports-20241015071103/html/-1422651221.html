<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2288</td> 
     <td>-1422651221</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>fbae11ccebefa8bea7e1ead2977ec167e18182d9</td> 
     <td>this works the best when this logic is executed when the exchange is done</td> 
     <td>this works the best when this logic is executed when the exchange is done</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>throttle(Route, Exchange)</td> 
     <td>protected void throttle(Route route, Exchange exchange)</td> 
     <td> // this works the best when this logic is executed when the exchange is done Consumer consumer = route.getConsumer(); int size = getSize(consumer, exchange); boolean stop = maxInflightExchanges &gt; 0 &amp;&amp; size &gt; maxInflightExchanges; if (log.isTraceEnabled()) { log.trace("{} &gt; 0 &amp;&amp; {} &gt; {} evaluated as {}", new Object[] { maxInflightExchanges, size, maxInflightExchanges, stop }); } if (stop) { try { lock.lock(); stopConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } // reload size in case a race condition with too many at once being invoked // so we need to ensure that we read the most current size and start the consumer if we are already to low size = getSize(consumer, exchange); boolean start = size &lt;= resumeInflightExchanges; if (log.isTraceEnabled()) { log.trace("{} &lt;= {} evaluated as {}", new Object[] { size, resumeInflightExchanges, start }); } if (start) { try { lock.lock(); startConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1611</td> 
     <td>-1422651221</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>5ec848067c1d16a6adddb3bf82f411da3a8d056c</td> 
     <td>this works the best when this logic is executed when the exchange is done</td> 
     <td>this works the best when this logic is executed when the exchange is done</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>onExchangeDone(Route, Exchange)</td> 
     <td>public void onExchangeDone(Route route, Exchange exchange)</td> 
     <td> // this works the best when this logic is executed when the exchange is done Consumer consumer = route.getConsumer(); int size = getSize(consumer, exchange); if (maxInflightExchanges &gt; 0 &amp;&amp; size &gt; maxInflightExchanges) { try { lock.lock(); stopConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } // reload size in case a race condition with too many at once being invoked // so we need to ensure that we read the most current size and start the consumer if we are already to low size = getSize(consumer, exchange); if (size &lt;= resumeInflightExchanges) { try { lock.lock(); startConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1603</td> 
     <td>-1422651221</td>
     <td>apache/camel</td>
     <td>Hadrian Zbarcea</td>
     <td>ddcf018f2cfbd5c4befc858cb0a88e82046e790e</td> 
     <td>None</td> 
     <td>this works the best when this logic is executed when the exchange is done</td> 
     <td>SATD_ADDED</td> 
     <td>onExchangeDone(Route, Exchange)</td> 
     <td>public void onExchangeDone(Route route, Exchange exchange)</td> 
     <td> // this works the best when this logic is executed when the exchange is done Consumer consumer = route.getConsumer(); int size = getSize(consumer, exchange); if (maxInflightExchanges &gt; 0 &amp;&amp; size &gt; maxInflightExchanges) { try { lock.lock(); stopConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } // reload size in case a race condition with too many at once being invoked // so we need to ensure that we read the most current side and start the consumer if we hit to low size = getSize(consumer, exchange); if (size &lt;= resumeInflightExchanges) { try { lock.lock(); startConsumer(size, consumer); } catch (Exception e) { handleException(e); } finally { lock.unlock(); } } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>