<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1968</td> <td>-1422651021</td><td>apache/camel</td><td>Claus Ibsen</td><td>5a57b334d860c19332f81e7b84947e452341a18c</td> <td>now we should routing asynchronously to not block while waiting for the reply
TODO:
we need a thread pool to use for continue routing messages, just like a seda consumer
and we need options to configure it as well so you can indicate how many threads to use
TODO: Also consider requestTimeout</td> <td>continue routing asynchronously (reply will be processed async when its received)</td> <td>SATD_REMOVED</td> <td>processInOut(Exchange, AsyncCallback)</td> <td>protected boolean processInOut(final Exchange exchange, final AsyncCallback callback)</td> <td>
    final org.apache.camel.Message in = exchange.getIn();
    String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class);
    // remove the header so it wont be propagated
    in.removeHeader(JmsConstants.JMS_DESTINATION_NAME);
    if (destinationName == null) {
        destinationName = endpoint.getDestinationName();
    }
    Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class);
    // remove the header so it wont be propagated
    in.removeHeader(JmsConstants.JMS_DESTINATION);
    if (destination == null) {
        destination = endpoint.getDestination();
    }
    if (destination != null) {
        // prefer to use destination over destination name
        destinationName = null;
    }
    initReplyManager();
    // note due to JMS transaction semantics we cannot use a single transaction
    // for sending the request and receiving the response
    final Destination replyTo = replyManager.getReplyTo();
    if (replyTo == null) {
        throw new RuntimeExchangeException("Failed to resolve replyTo destination", exchange);
    }
    // when using message id as correlation id, we need at first to use a provisional correlation id
    // which we then update to the real JMSMessageID when the message has been sent
    // this is done with the help of the MessageSentCallback
    final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();
    final String provisionalCorrelationId = msgIdAsCorrId ? getUuidGenerator().generateUuid() : null;
    MessageSentCallback messageSentCallback = null;
    if (msgIdAsCorrId) {
        messageSentCallback = new UseMessageIdAsCorrelationIdMessageSentCallback(replyManager, provisionalCorrelationId, endpoint.getRequestTimeout());
    }
    final ValueHolder<MessageSentCallback> sentCallback = new ValueHolder<MessageSentCallback>(messageSentCallback);
    final String originalCorrelationId = in.getHeader("JMSCorrelationID", String.class);
    if (originalCorrelationId == null && !msgIdAsCorrId) {
        in.setHeader("JMSCorrelationID", getUuidGenerator().generateUuid());
    }
    MessageCreator messageCreator = new MessageCreator() {

        public Message createMessage(Session session) throws JMSException {
            Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);
            message.setJMSReplyTo(replyTo);
            replyManager.setReplyToSelectorHeader(in, message);
            String correlationId = determineCorrelationId(message, provisionalCorrelationId);
            replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, endpoint.getRequestTimeout());
            return message;
        }
    };
    doSend(true, destinationName, destination, messageCreator, sentCallback.get());
    // after sending then set the OUT message id to the JMSMessageID so its identical
    setMessageId(exchange);
    // continue routing asynchronously (reply will be processed async when its received)
    return false;
</td> </tr></table></body></html>