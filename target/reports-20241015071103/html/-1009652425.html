<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>5980</td> 
     <td>-1009652425</td>
     <td>apache/hadoop</td>
     <td>Steve Loughran</td>
     <td>28e6a4e44a3e920dcaf858f9a74a6358226b3a63</td> 
     <td>This really shouldn't happen...</td> 
     <td>This really shouldn't happen...</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>doGet(HttpServletRequest, HttpServletResponse)</td> 
     <td>public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException</td> 
     <td> try { ServletContext context = getServletContext(); final FSImage nnImage = NameNodeHttpServer.getFsImageFromContext(context); final GetImageParams parsedParams = new GetImageParams(request, response); final Configuration conf = (Configuration) getServletContext().getAttribute(JspHelper.CURRENT_CONF); if (UserGroupInformation.isSecurityEnabled() &amp;&amp; !isValidRequestor(request.getRemoteUser(), conf)) { response.sendError(HttpServletResponse.SC_FORBIDDEN, "Only Namenode and Secondary Namenode may access this servlet"); LOG.warn("Received non-NN/SNN request for image or edits from " + request.getRemoteHost()); return; } String myStorageInfoString = nnImage.getStorage().toColonSeparatedString(); String theirStorageInfoString = parsedParams.getStorageInfoString(); if (theirStorageInfoString != null &amp;&amp; !myStorageInfoString.equals(theirStorageInfoString)) { response.sendError(HttpServletResponse.SC_FORBIDDEN, "This namenode has storage info " + myStorageInfoString + " but the secondary expected " + theirStorageInfoString); LOG.warn("Received an invalid request file transfer request " + "from a secondary with storage info " + theirStorageInfoString); return; } UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<void>
       () { @Override public Void run() throws Exception { if (parsedParams.isGetImage()) { long txid = parsedParams.getTxId(); File imageFile = nnImage.getStorage().getFsImageName(txid); if (imageFile == null) { throw new IOException("Could not find image with txid " + txid); } setVerificationHeaders(response, imageFile); // send fsImage TransferFsImage.getFileServer(response.getOutputStream(), imageFile, getThrottler(conf)); } else if (parsedParams.isGetEdit()) { long startTxId = parsedParams.getStartTxId(); long endTxId = parsedParams.getEndTxId(); File editFile = nnImage.getStorage().findFinalizedEditsFile(startTxId, endTxId); setVerificationHeaders(response, editFile); // send edits TransferFsImage.getFileServer(response.getOutputStream(), editFile, getThrottler(conf)); } else if (parsedParams.isPutImage()) { final long txid = parsedParams.getTxId(); if (!currentlyDownloadingCheckpoints.add(txid)) { throw new IOException("Another checkpointer is already in the process of uploading a" + " checkpoint made at transaction ID " + txid); } try { if (nnImage.getStorage().findImageFile(txid) != null) { throw new IOException("Another checkpointer already uploaded an checkpoint " + "for txid " + txid); } // issue a HTTP get request to download the new fsimage MD5Hash downloadImageDigest = reloginIfNecessary().doAs(new PrivilegedExceptionAction
       <md5hash>
        () { @Override public MD5Hash run() throws Exception { return TransferFsImage.downloadImageToStorage(parsedParams.getInfoServer(), txid, nnImage.getStorage(), true); } }); nnImage.saveDigestAndRenameCheckpointImage(txid, downloadImageDigest); // Now that we have a new checkpoint, we might be able to // remove some old ones. nnImage.purgeOldStorage(); } finally { currentlyDownloadingCheckpoints.remove(txid); } } return null; } // We may have lost our ticket since the last time we tried to open // an http connection, so log in just in case. private UserGroupInformation reloginIfNecessary() throws IOException { // This method is only called on the NN, therefore it is safe to // use these key values. return UserGroupInformation.loginUserFromKeytabAndReturnUGI(SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), NameNode.getAddress(conf).getHostName()), conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)); } }); } catch (Exception ie) { String errMsg = "GetImage failed. " + StringUtils.stringifyException(ie); response.sendError(HttpServletResponse.SC_GONE, errMsg); throw new IOException(errMsg); } finally { response.getOutputStream().close(); } 
       </md5hash>
      </void></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>5297</td> 
     <td>-1009652425</td>
     <td>apache/hadoop</td>
     <td>Eli Collins</td>
     <td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> 
     <td>None</td> 
     <td>This really shouldn't happen...</td> 
     <td>SATD_ADDED</td> 
     <td>isValidRequestor(String, Configuration)</td> 
     <td>protected boolean isValidRequestor(String remoteUser, Configuration conf) throws IOException</td> 
     <td> if (remoteUser == null) { // This really shouldn't happen... LOG.warn("Received null remoteUser while authorizing access to getImage servlet"); return false; } String[] validRequestors = { SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), NameNode.getAddress(conf).getHostName()), SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_NAMENODE_USER_NAME_KEY), NameNode.getAddress(conf).getHostName()), SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_KRB_HTTPS_USER_NAME_KEY), SecondaryNameNode.getHttpAddress(conf).getHostName()), SecurityUtil.getServerPrincipal(conf.get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_USER_NAME_KEY), SecondaryNameNode.getHttpAddress(conf).getHostName()) }; for (String v : validRequestors) { if (v != null &amp;&amp; v.equals(remoteUser)) { if (LOG.isDebugEnabled()) LOG.debug("isValidRequestor is allowing: " + remoteUser); return true; } } if (LOG.isDebugEnabled()) LOG.debug("isValidRequestor is rejecting: " + remoteUser); return false; </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>