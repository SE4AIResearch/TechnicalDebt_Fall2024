<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>3881</td> <td>-1422649944</td><td>apache/camel</td><td>Claus Ibsen</td><td>b5631c2e67da6dd32706ad6eea669e9bf1536b98</td> <td>None</td> <td>Potentially EntityManager could be in an inconsistent state after transaction rollback,
so disposing it to have it recreated in next poll. cf. Java Persistence API 3.3.2 Transaction Rollback</td> <td>SATD_ADDED</td> <td>poll()</td> <td>protected int poll() throws Exception</td> <td>
    // must reset for each poll
    shutdownRunningTask = null;
    pendingExchanges = 0;
    // Recreate EntityManager in case it is disposed due to transaction rollback
    if (entityManager == null) {
        entityManager = entityManagerFactory.createEntityManager();
        LOG.trace("Recreated EntityManager {} on {}", entityManager, this);
    }
    Object messagePolled = transactionTemplate.execute(new TransactionCallback<Object>() {

        public Object doInTransaction(TransactionStatus status) {
            if (getEndpoint().isJoinTransaction()) {
                entityManager.joinTransaction();
            }
            Queue<DataHolder> answer = new LinkedList<DataHolder>();
            Query query = getQueryFactory().createQuery(entityManager);
            configureParameters(query);
            LOG.trace("Created query {}", query);
            List<?> results = query.getResultList();
            LOG.trace("Got result list from query {}", results);
            for (Object result : results) {
                DataHolder holder = new DataHolder();
                holder.manager = entityManager;
                holder.result = result;
                holder.exchange = createExchange(result);
                answer.add(holder);
            }
            PersistenceException cause = null;
            int messagePolled = 0;
            try {
                messagePolled = processBatch(CastUtils.cast(answer));
            } catch (Exception e) {
                if (e instanceof PersistenceException) {
                    cause = (PersistenceException) e;
                } else {
                    cause = new PersistenceException(e);
                }
            }
            if (cause != null) {
                if (!isTransacted()) {
                    LOG.warn("Error processing last message due: {}. Will commit all previous successful processed message, and ignore this last failure.", cause.getMessage(), cause);
                } else {
                    // Potentially EntityManager could be in an inconsistent state after transaction rollback,
                    // so disposing it to have it recreated in next poll. cf. Java Persistence API 3.3.2 Transaction Rollback
                    LOG.info("Disposing EntityManager {} on {} due to coming transaction rollback", entityManager, this);
                    entityManager.close();
                    entityManager = null;
                    // rollback all by throwning exception
                    throw cause;
                }
            }
            // commit
            LOG.debug("Flushing EntityManager");
            entityManager.flush();
            // must clear after flush
            entityManager.clear();
            return messagePolled;
        }
    });
    return getEndpoint().getCamelContext().getTypeConverter().convertTo(int.class, messagePolled);
</td> </tr></table></body></html>