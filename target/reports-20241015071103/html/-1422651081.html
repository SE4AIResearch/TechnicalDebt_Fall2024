<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1843</td> <td>-1422651081</td><td>apache/camel</td><td>Claus Ibsen</td><td>24a09408139ef14448f94388099b8f5f54a3b3ea</td> <td>None</td> <td>toAsync should fix up itself at first</td> <td>SATD_ADDED</td> <td>afterPropertiesSet()</td> <td>public void afterPropertiesSet() throws Exception</td> <td>
    if (ObjectHelper.isEmpty(getId())) {
        throw new IllegalArgumentException("Id must be set");
    }
    if (properties != null) {
        getContext().setProperties(properties.asMap());
    }
    // set the resolvers first
    PackageScanClassResolver packageResolver = getBeanForType(PackageScanClassResolver.class);
    if (packageResolver != null) {
        LOG.info("Using custom PackageScanClassResolver: " + packageResolver);
        getContext().setPackageScanClassResolver(packageResolver);
    }
    ClassResolver classResolver = getBeanForType(ClassResolver.class);
    if (classResolver != null) {
        LOG.info("Using custom ClassResolver: " + classResolver);
        getContext().setClassResolver(classResolver);
    }
    FactoryFinderResolver factoryFinderResolver = getBeanForType(FactoryFinderResolver.class);
    if (factoryFinderResolver != null) {
        LOG.info("Using custom FactoryFinderResolver: " + factoryFinderResolver);
        getContext().setFactoryFinderResolver(factoryFinderResolver);
    }
    ExecutorServiceStrategy executorServiceStrategy = getBeanForType(ExecutorServiceStrategy.class);
    if (executorServiceStrategy != null) {
        LOG.info("Using custom ExecutorServiceStrategy: " + executorServiceStrategy);
        getContext().setExecutorServiceStrategy(executorServiceStrategy);
    }
    // set the custom registry if defined
    Registry registry = getBeanForType(Registry.class);
    if (registry != null) {
        LOG.info("Using custom Registry: " + registry);
        getContext().setRegistry(registry);
    }
    // setup property placeholder so we got it as early as possible
    initPropertyPlaceholder();
    // setup JMX agent at first
    initJMXAgent();
    Tracer tracer = getBeanForType(Tracer.class);
    if (tracer != null) {
        // use formatter if there is a TraceFormatter bean defined
        TraceFormatter formatter = getBeanForType(TraceFormatter.class);
        if (formatter != null) {
            tracer.setFormatter(formatter);
        }
        LOG.info("Using custom Tracer: " + tracer);
        getContext().addInterceptStrategy(tracer);
    }
    HandleFault handleFault = getBeanForType(HandleFault.class);
    if (handleFault != null) {
        LOG.info("Using custom HandleFault: " + handleFault);
        getContext().addInterceptStrategy(handleFault);
    }
    Delayer delayer = getBeanForType(Delayer.class);
    if (delayer != null) {
        LOG.info("Using custom Delayer: " + delayer);
        getContext().addInterceptStrategy(delayer);
    }
    InflightRepository inflightRepository = getBeanForType(InflightRepository.class);
    if (delayer != null) {
        LOG.info("Using custom InflightRepository: " + inflightRepository);
        getContext().setInflightRepository(inflightRepository);
    }
    ManagementStrategy managementStrategy = getBeanForType(ManagementStrategy.class);
    if (managementStrategy != null) {
        LOG.info("Using custom ManagementStrategy: " + managementStrategy);
        getContext().setManagementStrategy(managementStrategy);
    }
    EventFactory eventFactory = getBeanForType(EventFactory.class);
    if (eventFactory != null) {
        LOG.info("Using custom EventFactory: " + eventFactory);
        getContext().getManagementStrategy().setEventFactory(eventFactory);
    }
    // set the event notifier strategies if defined
    Map<String, EventNotifier> eventNotifiers = getContext().getRegistry().lookupByType(EventNotifier.class);
    if (eventNotifiers != null && !eventNotifiers.isEmpty()) {
        for (String id : eventNotifiers.keySet()) {
            EventNotifier notifier = eventNotifiers.get(id);
            // do not add if already added, for instance a tracer that is also an InterceptStrategy class
            if (!getContext().getManagementStrategy().getEventNotifiers().contains(notifier)) {
                LOG.info("Using custom EventNotifier with id: " + id + " and implementation: " + notifier);
                getContext().getManagementStrategy().addEventNotifier(notifier);
            }
        }
    }
    ShutdownStrategy shutdownStrategy = getBeanForType(ShutdownStrategy.class);
    if (shutdownStrategy != null) {
        LOG.info("Using custom ShutdownStrategy: " + shutdownStrategy);
        getContext().setShutdownStrategy(shutdownStrategy);
    }
    // add global interceptors
    Map<String, InterceptStrategy> interceptStrategies = getContext().getRegistry().lookupByType(InterceptStrategy.class);
    if (interceptStrategies != null && !interceptStrategies.isEmpty()) {
        for (String id : interceptStrategies.keySet()) {
            InterceptStrategy strategy = interceptStrategies.get(id);
            // do not add if already added, for instance a tracer that is also an InterceptStrategy class
            if (!getContext().getInterceptStrategies().contains(strategy)) {
                LOG.info("Using custom InterceptStrategy with id: " + id + " and implementation: " + strategy);
                getContext().addInterceptStrategy(strategy);
            }
        }
    }
    // set the lifecycle strategy if defined
    Map<String, LifecycleStrategy> lifecycleStrategies = getContext().getRegistry().lookupByType(LifecycleStrategy.class);
    if (lifecycleStrategies != null && !lifecycleStrategies.isEmpty()) {
        for (String id : lifecycleStrategies.keySet()) {
            LifecycleStrategy strategy = lifecycleStrategies.get(id);
            // do not add if already added, for instance a tracer that is also an InterceptStrategy class
            if (!getContext().getLifecycleStrategies().contains(strategy)) {
                LOG.info("Using custom LifecycleStrategy with id: " + id + " and implementation: " + strategy);
                getContext().addLifecycleStrategy(strategy);
            }
        }
    }
    // set the default thread pool profile if defined
    initThreadPoolProfiles(getContext());
    // Set the application context and camelContext for the beanPostProcessor
    if (beanPostProcessor != null) {
        if (beanPostProcessor instanceof ApplicationContextAware) {
            ((ApplicationContextAware) beanPostProcessor).setApplicationContext(applicationContext);
        }
        if (beanPostProcessor instanceof CamelBeanPostProcessor) {
            ((CamelBeanPostProcessor) beanPostProcessor).setCamelContext(getContext());
        }
    }
    initSpringCamelContext(getContext());
    // must init route refs before we prepare the routes below
    initRouteRefs();
    // do special preparation for some concepts such as interceptors and policies
    // this is needed as JAXB does not build exactly the same model definition as Spring DSL would do
    // using route builders. So we have here a little custom code to fix the JAXB gaps
    for (RouteDefinition route : routes) {
        // abstracts is the cross cutting concerns
        List<ProcessorDefinition> abstracts = new ArrayList<ProcessorDefinition>();
        // upper is the cross cutting concerns such as interceptors, error handlers etc
        List<ProcessorDefinition> upper = new ArrayList<ProcessorDefinition>();
        // lower is the regular route
        List<ProcessorDefinition> lower = new ArrayList<ProcessorDefinition>();
        prepareRouteForInit(route, abstracts, lower);
        // toAsync should fix up itself at first
        initToAsync(lower);
        // interceptors should be first for the cross cutting concerns
        initInterceptors(route, upper);
        // then on completion
        initOnCompletions(abstracts, upper);
        // then transactions
        initTransacted(abstracts, lower);
        // then on exception
        initOnExceptions(abstracts, upper);
        // rebuild route as upper + lower
        route.clearOutput();
        route.getOutputs().addAll(upper);
        route.getOutputs().addAll(lower);
        // configure parents
        initParent(route);
    }
    if (dataFormats != null) {
        getContext().setDataFormats(dataFormats.asMap());
    }
    // lets force any lazy creation
    getContext().addRouteDefinitions(routes);
    if (LOG.isDebugEnabled()) {
        LOG.debug("Found JAXB created routes: " + getRoutes());
    }
    findRouteBuilders();
    installRoutes();
</td> </tr></table></body></html>