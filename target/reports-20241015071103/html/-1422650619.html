<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2668</td> <td>-1422650619</td><td>apache/camel</td><td>Claus Ibsen</td><td>aafec85863dea3bf8a758b6fea0f78ea6251ce4a</td> <td>None</td> <td>TODO lets exclude fields with @Inject?</td> <td>SATD_ADDED</td> <td>bindAnnotationInjector(Class<A>, EncounterProvider<AnnotationMemberProvider>)</td> <td>private void bindAnnotationInjector(final Class<A> annotationType, final EncounterProvider<AnnotationMemberProvider> memberProviderProvider)</td> <td>
    bindListener(any(), new TypeListener() {

        Provider<? extends AnnotationMemberProvider> providerProvider;

        public <I> void hear(TypeLiteral<I> injectableType, TypeEncounter<I> encounter) {
            Set<Field> boundFields = Sets.newHashSet();
            Map<MethodKey, Method> boundMethods = Maps.newHashMap();
            TypeLiteral<?> startType = injectableType;
            while (true) {
                Class<?> type = startType.getRawType();
                if (type == Object.class) {
                    break;
                }
                Field[] fields = type.getDeclaredFields();
                for (Field field : fields) {
                    if (boundFields.add(field)) {
                        bindAnnotationInjectorToField(encounter, startType, field);
                    }
                }
                Method[] methods = type.getDeclaredMethods();
                for (final Method method : methods) {
                    MethodKey key = new MethodKey(method);
                    if (boundMethods.get(key) == null) {
                        boundMethods.put(key, method);
                        bindAnnotationInjectionToMember(encounter, startType, method);
                    }
                }
                Class<?> supertype = type.getSuperclass();
                if (supertype == Object.class) {
                    break;
                }
                startType = startType.getSupertype(supertype);
            }
        }

        protected <I> void bindAnnotationInjectionToMember(final TypeEncounter<I> encounter, final TypeLiteral<?> type, final Method method) {
            // TODO lets exclude methods with @Inject?
            final A annotation = method.getAnnotation(annotationType);
            if (annotation != null) {
                if (providerProvider == null) {
                    providerProvider = memberProviderProvider.get(encounter);
                }
                encounter.register(new MembersInjector<I>() {

                    public void injectMembers(I injectee) {
                        AnnotationMemberProvider provider = providerProvider.get();
                        int size = method.getParameterTypes().length;
                        Object[] values = new Object[size];
                        for (int i = 0; i < size; i++) {
                            Class<?> paramType = getParameterType(type, method, i);
                            Object value = provider.provide(annotation, type, method, paramType, i);
                            checkInjectedValueType(value, paramType, encounter);
                            // if we have a null value then assume the
                            // injection point cannot be satisfied
                            // which is the spring @Autowired way of doing
                            // things
                            if (value == null && !provider.isNullParameterAllowed(annotation, method, paramType, i)) {
                                return;
                            }
                            values[i] = value;
                        }
                        try {
                            method.setAccessible(true);
                            method.invoke(injectee, values);
                        } catch (IllegalAccessException e) {
                            throw new ProvisionException("Failed to inject method " + method + ". Reason: " + e, e);
                        } catch (InvocationTargetException ie) {
                            Throwable e = ie.getTargetException();
                            throw new ProvisionException("Failed to inject method " + method + ". Reason: " + e, e);
                        }
                    }
                });
            }
        }

        protected <I> void bindAnnotationInjectorToField(final TypeEncounter<I> encounter, final TypeLiteral<?> type, final Field field) {
            // TODO lets exclude fields with @Inject?
            final A annotation = field.getAnnotation(annotationType);
            if (annotation != null) {
                if (providerProvider == null) {
                    providerProvider = memberProviderProvider.get(encounter);
                }
                encounter.register(new InjectionListener<I>() {

                    public void afterInjection(I injectee) {
                        AnnotationMemberProvider provider = providerProvider.get();
                        Object value = provider.provide(annotation, type, field);
                        checkInjectedValueType(value, field.getType(), encounter);
                        try {
                            field.setAccessible(true);
                            field.set(injectee, value);
                        } catch (IllegalAccessException e) {
                            throw new ProvisionException("Failed to inject field " + field + ". Reason: " + e, e);
                        }
                    }
                });
            }
        }
    });
</td> </tr></table></body></html>