<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>796</td> 
     <td>-1422651817</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>24343aa3c3f8f618334af2bff67c159fbbb0233b</td> 
     <td>Figure out how long we should wait to resend this message.</td> 
     <td>okay we will give it another go so clear the exception so we can try again</td> 
     <td>SATD_REMOVED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // if the exchange is transacted then let the underlying system handle the redelivery etc. // this DeadLetterChannel is only for non transacted exchanges if (exchange.isTransacted() &amp;&amp; exchange.getException() != null) { if (LOG.isDebugEnabled()) { LOG.debug("This is a transacted exchange, bypassing this DeadLetterChannel: " + this + " for exchange: " + exchange); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { Throwable e = exchange.getException(); // set the original caused exception exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, e); logger.log("Failed delivery for exchangeId: " + exchange.getExchangeId() + ". On delivery attempt: " + data.redeliveryCounter + " caught: " + e, e); data.redeliveryCounter = incrementRedeliveryCounter(exchange, e); // find the error handler to use (if any) ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e); if (exceptionPolicy != null) { data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy); Processor processor = exceptionPolicy.getErrorHandler(); if (processor != null) { data.failureProcessor = processor; } } } // should we redeliver or not? if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) { // we did not success with the redelivery so now we let the failure processor handle it setFailureHandled(exchange, true); // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor); boolean sync = afp.process(exchange, new AsyncCallback() { public void done(boolean sync) { restoreExceptionOnExchange(exchange); callback.done(data.sync); } }); restoreExceptionOnExchange(exchange); logger.log("Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Handled by the failure processor: " + data.failureProcessor); return sync; } // should we redeliver if (data.redeliveryCounter &gt; 0) { // okay we will give it another go so clear the exception so we can try again if (exchange.getException() != null) { exchange.setException(null); } // wait until we should redeliver data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; if (exchange.getException() != null) { process(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>430</td> 
     <td>-1422651817</td>
     <td>apache/camel</td>
     <td>Guillaume Nodet</td>
     <td>0ea40fae717241f5322d95b60233f982ae810040</td> 
     <td>Figure out how long we should wait to resend this message.</td> 
     <td>Figure out how long we should wait to resend this message.</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // We can't keep retrying if the route is being shutdown. if (isStopping() || isStopped()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } if (exchange.getException() != null) { Throwable e = exchange.getException(); // Reset it since we are handling it. exchange.setException(null); logger.log("On delivery attempt: " + data.redeliveryCounter + " caught: " + e, e); data.redeliveryCounter = incrementRedeliveryCounter(exchange, e); ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e); if (exceptionPolicy != null) { data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy); Processor processor = exceptionPolicy.getErrorHandler(); if (processor != null) { data.failureProcessor = processor; } } } if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) { setFailureHandled(exchange, true); AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor); return afp.process(exchange, new AsyncCallback() { public void done(boolean sync) { callback.done(data.sync); } }); } if (data.redeliveryCounter &gt; 0) { // Figure out how long we should wait to resend this message. data.redeliveryDelay = data.currentRedeliveryPolicy.getRedeliveryDelay(data.redeliveryDelay); sleep(data.redeliveryDelay); } exchange.setException(null); boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; if (exchange.getException() != null) { process(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occured so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>