<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1282</td> 
     <td>-1422651552</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>b64e8a8c4b15c88b0cb86c5b64f1ed1c8d1292cd</td> 
     <td>TODO Call the Timer for the asyncProcessor</td> 
     <td>process the exchange</td> 
     <td>SATD_REMOVED</td> 
     <td>processErrorHandler(Exchange, RedeliveryData)</td> 
     <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { deliverToFaultProcessor(exchange, data); // we should not try redeliver so we are finished return; } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange try { output.process(exchange); } catch (Exception e) { exchange.setException(e); } // only process if the exchange hasn't failed // and it has not been handled by the error processor boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange); if (done) { return; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1213</td> 
     <td>-1422651552</td> 
     <td>apache/camel</td> 
     <td>James Strachan</td> 
     <td>f599b0649a49dbbaf02e7fb299228054921f99cb</td> 
     <td>TODO Call the Timer for the asyncProcessor</td> 
     <td>TODO Call the Timer for the asyncProcessor</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { return deliverToFaultProcessor(exchange, callback, data); } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, callback, data); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (exchange.getException() != null &amp;&amp; !ExchangeHelper.isFailureHandled(exchange)) { // TODO Call the Timer for the asyncProcessor asyncProcess(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>909</td> 
     <td>-1422651552</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>6cfab4aa18242325a2b8a688b7012c4efe8b8847</td> 
     <td>None</td> 
     <td>TODO Call the Timer for the asyncProcessor</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // if the exchange is transacted then let the underlying system handle the redelivery etc. // this DeadLetterChannel is only for non transacted exchanges if (exchange.isTransacted() &amp;&amp; exchange.getException() != null) { if (LOG.isDebugEnabled()) { LOG.debug("This is a transacted exchange, bypassing this DeadLetterChannel: " + this + " for exchange: " + exchange); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { return deliverToFaultProcessor(exchange, callback, data); } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { // okay we will give it another go so clear the exception so we can try again if (exchange.getException() != null) { exchange.setException(null); } // wait until we should redeliver data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (exchange.getException() != null &amp;&amp; !isFailureHandled(exchange)) { // TODO Call the Timer for the asyncProcessor asyncProcess(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>