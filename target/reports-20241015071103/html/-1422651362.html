<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1341</td> 
     <td>-1422651362</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>49bc0a2a15816490c0b2bd25ab15249d32c74321</td> 
     <td>TODO: Support exchange headers for wait and timeout values, see Exchange constants</td> 
     <td>compute if we should wait for task to complete or not</td> 
     <td>SATD_REMOVED</td> 
     <td>process(Exchange)</td> 
     <td>public void process(final Exchange exchange) throws Exception</td> 
     <td> final Processor output = getProcessor(); if (output == null) { // no output then return return; } // use a new copy of the exchange to route async final Exchange copy = exchange.newCopy(); // let it execute async and return the Future Callable<exchange>
        task = new Callable
       <exchange>
        () { public Exchange call() throws Exception { // must use a copy of the original exchange for processing async output.process(copy); return copy; } }; // sumbit the task Future
        <exchange>
          future = getExecutorService().submit(task); // compute if we should wait for task to complete or not boolean wait = waitTaskComplete; if (exchange.getIn().getHeader(Exchange.ASYNC_WAIT) != null) { wait = exchange.getIn().getHeader(Exchange.ASYNC_WAIT, Boolean.class); } if (wait) { // wait for task to complete Exchange response = future.get(); ExchangeHelper.copyResults(exchange, response); } else { // no we do not expect a reply so lets continue, set a handle to the future task // in case end user need it later exchange.getOut().setBody(future); } 
        </exchange>
       </exchange>
      </exchange></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1338</td> 
     <td>-1422651362</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>11a82c5954c50dd1cc81347ff0088cb035738c62</td> 
     <td>None</td> 
     <td>TODO: Support exchange headers for wait and timeout values, see Exchange constants</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange)</td> 
     <td>public void process(final Exchange exchange) throws Exception</td> 
     <td> final Processor output = getProcessor(); if (output == null) { // no output then return return; } // use a new copy of the exchange to route async final Exchange copy = exchange.newCopy(); // let it execute async and return the Future Callable<exchange>
        task = new Callable
       <exchange>
        () { public Exchange call() throws Exception { // must use a copy of the original exchange for processing async output.process(copy); return copy; } }; // sumbit the task Future
        <exchange>
          future = getExecutorService().submit(task); // TODO: Support exchange headers for wait and timeout values, see Exchange constants if (waitTaskComplete) { // wait for task to complete Exchange response = future.get(); // if we are out capable then set the response on the original exchange if (ExchangeHelper.isOutCapable(exchange)) { ExchangeHelper.copyResults(exchange, response); } } else { // no we do not expect a reply so lets continue, set a handle to the future task // in case end user need it later exchange.getOut().setBody(future); } 
        </exchange>
       </exchange>
      </exchange></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>