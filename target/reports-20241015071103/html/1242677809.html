<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4640</td> 
     <td>1242677809</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>4c27b10dc5def4aeac2fd5560a00478acc456db9</td> 
     <td>If two or more projects contains \"query\" as substring create an OrPredicate holding predicates for all these projects, otherwise if only one contains that, return only that one predicate by itself.</td> 
     <td>Skip.</td> 
     <td>SATD_REMOVED</td> 
     <td>defaultField(String)</td> 
     <td>protected Predicate<changedata>
        defaultField(String query)
      </changedata></td> 
     <td> if (query.startsWith("refs/")) { return ref(query); } else if (DEF_CHANGE.matcher(query).matches()) { return change(query); } List<predicate>
       <changedata>
        &gt; predicates = Lists.newArrayListWithCapacity(9); try { predicates.add(commit(query)); } catch (IllegalArgumentException e) { // Skip. } try { predicates.add(owner(query)); } catch (OrmException | QueryParseException e) { // Skip. } try { predicates.add(reviewer(query)); } catch (OrmException | QueryParseException e) { // Skip. } try { predicates.add(file(query)); } catch (QueryParseException e) { // Skip. } try { predicates.add(label(query)); } catch (OrmException | QueryParseException e) { // Skip. } try { predicates.add(message(query)); } catch (QueryParseException e) { // Skip. } try { predicates.add(comment(query)); } catch (QueryParseException e) { // Skip. } try { predicates.add(projects(query)); } catch (QueryParseException e) { // Skip. } predicates.add(ref(query)); predicates.add(branch(query)); predicates.add(topic(query)); return Predicate.or(predicates); 
       </changedata>
      </predicate></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4304</td> 
     <td>1242677809</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>7dfa0d28668c27bf41f2b269d220444d001655a4</td> 
     <td>None</td> 
     <td>If two or more projects contains \"query\" as substring create an OrPredicate holding predicates for all these projects, otherwise if only one contains that, return only that one predicate by itself.</td> 
     <td>SATD_ADDED</td> 
     <td>defaultField(String)</td> 
     <td>protected Predicate<changedata>
        defaultField(String query) throws QueryParseException
      </changedata></td> 
     <td> if (query.startsWith("refs/")) { return ref(query); } else if (DEF_CHANGE.matcher(query).matches()) { return change(query); } else if (PAT_COMMIT.matcher(query).matches()) { return commit(query); } else if (PAT_EMAIL.matcher(query).find()) { try { return Predicate.or(owner(query), reviewer(query)); } catch (OrmException err) { throw error("Cannot lookup user", err); } } else if (PAT_LABEL.matcher(query).find()) { return label(query); } else { // Try to match a project name by substring query. final List<projectpredicate>
        predicate = new ArrayList
       <projectpredicate>
        (); try { for (final Project p : args.dbProvider.get().projects().all()) { if (p.getName().toLowerCase().contains(query.toLowerCase())) { predicate.add(new ProjectPredicate(args.dbProvider, p.getName())); } } // If two or more projects contains "query" as substring create an // OrPredicate holding predicates for all these projects, otherwise if // only one contains that, return only that one predicate by itself. if (predicate.size() == 1) { return predicate.get(0); } else if (predicate.size() &gt; 1) { return Predicate.or(predicate); } } catch (OrmException e) { throw error("Cannot lookup project.", e); } throw error("Unsupported query:" + query); } 
       </projectpredicate>
      </projectpredicate></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>