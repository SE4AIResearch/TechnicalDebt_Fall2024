<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4914</td> 
     <td>1242677792</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>3ecfd766745eba6ef59324de29c86e6c66b289ab</td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>loadCommentsAndHistory(ChangeNotes, ChangeType, String, String)</td> 
     <td>private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException</td> 
     <td> Map<patch.key, patch>
        byKey = new HashMap&lt;&gt;(); if (loadHistory) { // This seems like a cheap trick. It doesn't properly account for a // file that gets renamed between patch set 1 and patch set 2. We // will wind up packing the wrong Patch object because we didn't do // proper rename detection between the patch sets. // history = new ArrayList&lt;&gt;(); for (PatchSet ps : psUtil.byChange(db, notes)) { if (!control.isPatchVisible(ps, db)) { continue; } String name = fileName; if (psa != null) { switch(changeType) { case COPIED: case RENAMED: if (ps.getId().equals(psa)) { name = oldName; } break; case MODIFIED: case DELETED: case ADDED: case REWRITE: break; } } Patch p = new Patch(new Patch.Key(ps.getId(), name)); history.add(p); byKey.put(p.getKey(), p); } if (edit != null &amp;&amp; edit.isPresent()) { Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName)); history.add(p); byKey.put(p.getKey(), p); } } if (loadComments &amp;&amp; edit == null) { AccountInfoCacheFactory aic = aicFactory.create(); comments = new CommentDetail(psa, psb); switch(changeType) { case ADDED: case MODIFIED: loadPublished(byKey, aic, newName); break; case DELETED: loadPublished(byKey, aic, newName); break; case COPIED: case RENAMED: if (psa != null) { loadPublished(byKey, aic, oldName); } loadPublished(byKey, aic, newName); break; case REWRITE: break; } CurrentUser user = control.getUser(); if (user.isIdentifiedUser()) { Account.Id me = user.getAccountId(); switch(changeType) { case ADDED: case MODIFIED: loadDrafts(byKey, aic, me, newName); break; case DELETED: loadDrafts(byKey, aic, me, newName); break; case COPIED: case RENAMED: if (psa != null) { loadDrafts(byKey, aic, me, oldName); } loadDrafts(byKey, aic, me, newName); break; case REWRITE: break; } } comments.setAccountInfoCache(aic.create()); } 
      </patch.key,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4508</td> 
     <td>1242677792</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn Pearce</td> 
     <td>010daed12ddf2a7d4f8c87342a8f5ca7191bb12f</td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>loadCommentsAndHistory(ChangeType, String, String)</td> 
     <td>private void loadCommentsAndHistory(final ChangeType changeType, final String oldName, final String newName) throws OrmException</td> 
     <td> history = new ArrayList<patch>
        (); comments = new CommentDetail(psa, psb); final Map 
       <patch.key, patch>
         byKey = new HashMap 
        <patch.key, patch>
          (); final AccountInfoCacheFactory aic = aicFactory.create(); // This seems like a cheap trick. It doesn't properly account for a // file that gets renamed between patch set 1 and patch set 2. We // will wind up packing the wrong Patch object because we didn't do // proper rename detection between the patch sets. // for (final PatchSet ps : db.patchSets().byChange(changeId)) { String name = patchKey.get(); if (psa != null) { switch(changeType) { case COPIED: case RENAMED: if (ps.getId().equals(psa)) { name = oldName; } break; case MODIFIED: case DELETED: case ADDED: case REWRITE: break; } } final Patch p = new Patch(new Patch.Key(ps.getId(), name)); history.add(p); byKey.put(p.getKey(), p); } switch(changeType) { case ADDED: case MODIFIED: loadPublished(byKey, aic, newName); break; case DELETED: loadPublished(byKey, aic, newName); break; case COPIED: case RENAMED: if (psa != null) { loadPublished(byKey, aic, oldName); } loadPublished(byKey, aic, newName); break; case REWRITE: break; } final CurrentUser user = control.getCurrentUser(); if (user instanceof IdentifiedUser) { final Account.Id me = ((IdentifiedUser) user).getAccountId(); switch(changeType) { case ADDED: case MODIFIED: loadDrafts(byKey, aic, me, newName); break; case DELETED: loadDrafts(byKey, aic, me, newName); break; case COPIED: case RENAMED: if (psa != null) { loadDrafts(byKey, aic, me, oldName); } loadDrafts(byKey, aic, me, newName); break; case REWRITE: break; } } comments.setAccountInfoCache(aic.create()); 
        </patch.key,> 
       </patch.key,> 
      </patch></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4505</td> 
     <td>1242677792</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Colby Ranger</td> 
     <td>fd4af1bb50c2516de7766b70ea0de75c176749c3</td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>loadCommentsAndHistory(ChangeType, String, String)</td> 
     <td>private void loadCommentsAndHistory(final ChangeType changeType, final String oldName, final String newName) throws OrmException</td> 
     <td> history = new ArrayList<patch>
        (); comments = new CommentDetail(psa, psb); final Map 
       <patch.key, patch>
         byKey = new HashMap 
        <patch.key, patch>
          (); final AccountInfoCacheFactory aic = aicFactory.create(); // This seems like a cheap trick. It doesn't properly account for a // file that gets renamed between patch set 1 and patch set 2. We // will wind up packing the wrong Patch object because we didn't do // proper rename detection between the patch sets. // for (final PatchSet ps : db.patchSets().byChange(changeId)) { String name = patchKey.get(); if (psa != null) { switch(changeType) { case COPIED: case RENAMED: if (ps.getId().equals(psa)) { name = oldName; } break; case MODIFIED: case DELETED: case ADDED: case REWRITE: break; } } final Patch p = new Patch(new Patch.Key(ps.getId(), name)); history.add(p); byKey.put(p.getKey(), p); } switch(changeType) { case ADDED: case MODIFIED: loadPublished(byKey, aic, newName); break; case DELETED: loadPublished(byKey, aic, newName); break; case COPIED: case RENAMED: if (psa != null) { loadPublished(byKey, aic, oldName); } loadPublished(byKey, aic, newName); break; case REWRITE: break; } final CurrentUser user = control.getCurrentUser(); if (user instanceof IdentifiedUser) { final Account.Id me = ((IdentifiedUser) user).getAccountId(); switch(changeType) { case ADDED: case MODIFIED: loadDrafts(byKey, aic, me, newName); break; case DELETED: loadDrafts(byKey, aic, me, newName); break; case COPIED: case RENAMED: if (psa != null) { loadDrafts(byKey, aic, me, oldName); } loadDrafts(byKey, aic, me, newName); break; case REWRITE: break; } } comments.setAccountInfoCache(aic.create()); 
        </patch.key,> 
       </patch.key,> 
      </patch></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4504</td> 
     <td>1242677792</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn Pearce</td> 
     <td>2c29e73e6ba82067b923b04ff0f7bc8c88af3168</td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>loadCommentsAndHistory(ChangeType, String, String)</td> 
     <td>private void loadCommentsAndHistory(final ChangeType changeType, final String oldName, final String newName) throws OrmException</td> 
     <td> history = new ArrayList<patch>
        (); comments = new CommentDetail(psa, psb); final Map 
       <patch.key, patch>
         byKey = new HashMap 
        <patch.key, patch>
          (); final AccountInfoCacheFactory aic = aicFactory.create(); // This seems like a cheap trick. It doesn't properly account for a // file that gets renamed between patch set 1 and patch set 2. We // will wind up packing the wrong Patch object because we didn't do // proper rename detection between the patch sets. // for (final PatchSet ps : db.patchSets().byChange(changeId)) { String name = patchKey.get(); if (psa != null) { switch(changeType) { case COPIED: case RENAMED: if (ps.getId().equals(psa)) { name = oldName; } break; case MODIFIED: case DELETED: case ADDED: case REWRITE: break; } } final Patch p = new Patch(new Patch.Key(ps.getId(), name)); history.add(p); byKey.put(p.getKey(), p); } switch(changeType) { case ADDED: case MODIFIED: loadPublished(byKey, aic, newName); break; case DELETED: loadPublished(byKey, aic, newName); break; case COPIED: case RENAMED: if (psa != null) { loadPublished(byKey, aic, oldName); } loadPublished(byKey, aic, newName); break; case REWRITE: break; } final CurrentUser user = control.getCurrentUser(); if (user instanceof IdentifiedUser) { final Account.Id me = ((IdentifiedUser) user).getAccountId(); switch(changeType) { case ADDED: case MODIFIED: loadDrafts(byKey, aic, me, newName); break; case DELETED: loadDrafts(byKey, aic, me, newName); break; case COPIED: case RENAMED: if (psa != null) { loadDrafts(byKey, aic, me, oldName); } loadDrafts(byKey, aic, me, newName); break; case REWRITE: break; } } comments.setAccountInfoCache(aic.create()); 
        </patch.key,> 
       </patch.key,> 
      </patch></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4266</td> 
     <td>1242677792</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>598e9de527a6a47ae9f60a08c1ce88a1165fa98f</td> 
     <td>None</td> 
     <td>This seems like a cheap trick. It doesn't properly account for a file that gets renamed between patch set 1 and patch set 2. We will wind up packing the wrong Patch object because we didn't do proper rename detection between the patch sets. </td> 
     <td>SATD_ADDED</td> 
     <td>loadCommentsAndHistory(ChangeType, String, String)</td> 
     <td>private void loadCommentsAndHistory(final ChangeType changeType, final String oldName, final String newName) throws OrmException</td> 
     <td> history = new ArrayList<patch>
       (); comments = new CommentDetail(psa, psb); final Map
       <patch.key, patch>
         byKey = new HashMap
        <patch.key, patch>
         (); final AccountInfoCacheFactory aic = aicFactory.create(); // This seems like a cheap trick. It doesn't properly account for a // file that gets renamed between patch set 1 and patch set 2. We // will wind up packing the wrong Patch object because we didn't do // proper rename detection between the patch sets. // for (final PatchSet ps : db.patchSets().byChange(changeId)) { String name = patchKey.get(); if (psa != null) { switch(changeType) { case COPIED: case RENAMED: if (ps.getId().equals(psa)) { name = oldName; } break; } } final Patch p = new Patch(new Patch.Key(ps.getId(), name)); history.add(p); byKey.put(p.getKey(), p); } switch(changeType) { case ADDED: case MODIFIED: loadPublished(byKey, aic, newName); break; case DELETED: loadPublished(byKey, aic, oldName); break; case COPIED: case RENAMED: if (psa != null) { loadPublished(byKey, aic, oldName); } loadPublished(byKey, aic, newName); break; } final CurrentUser user = control.getCurrentUser(); if (user instanceof IdentifiedUser) { final Account.Id me = ((IdentifiedUser) user).getAccountId(); switch(changeType) { case ADDED: case MODIFIED: loadDrafts(byKey, aic, me, newName); break; case DELETED: loadDrafts(byKey, aic, me, oldName); break; case COPIED: case RENAMED: if (psa != null) { loadDrafts(byKey, aic, me, oldName); } loadDrafts(byKey, aic, me, newName); break; } } comments.setAccountInfoCache(aic.create()); 
        </patch.key,>
       </patch.key,>
      </patch></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>