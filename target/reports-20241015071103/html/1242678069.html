<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4782</td> <td>1242678069</td><td>GerritCodeReview/gerrit</td><td>Dave Borowitz</td><td>c6853e158b9988089f931bdbf8d77985994a68fc</td> <td>None</td> <td>Only one parent is new in this push. If it is the only parent, just use
that parent's group. If there are multiple parents, perhaps this commit
is a merge of a side branch. This commit belongs in that parent's group
in that case.</td> <td>SATD_ADDED</td> <td>visit(RevCommit)</td> <td> void visit(RevCommit c)</td> <td>
    checkState(!done, "visit() called after getGroups()");
    Set<RevCommit> interestingParents = getInterestingParents(c);
    if (interestingParents.size() == 0) {
        // All parents are uninteresting: treat this commit as the root of a new
        // group of related changes.
        groups.put(c, c.name());
        return;
    } else if (interestingParents.size() == 1) {
        // Only one parent is new in this push. If it is the only parent, just use
        // that parent's group. If there are multiple parents, perhaps this commit
        // is a merge of a side branch. This commit belongs in that parent's group
        // in that case.
        groups.putAll(c, groups.get(interestingParents.iterator().next()));
        return;
    }
    // Multiple parents, merging at least two branches containing new commits in
    // this push.
    Set<String> thisCommitGroups = new TreeSet<>();
    Set<String> parentGroupsNewInThisPush = Sets.newLinkedHashSetWithExpectedSize(interestingParents.size());
    for (RevCommit p : interestingParents) {
        Collection<String> parentGroups = groups.get(p);
        if (parentGroups.isEmpty()) {
            throw new IllegalStateException(String.format("no group assigned to parent %s of commit %s", p.name(), c.name()));
        }
        for (String parentGroup : parentGroups) {
            if (isGroupFromExistingPatchSet(p, parentGroup)) {
                // This parent's group is from an existing patch set, i.e. the parent
                // not new in this push. Use this group for the commit.
                thisCommitGroups.add(parentGroup);
            } else {
                // This parent's group is new in this push.
                parentGroupsNewInThisPush.add(parentGroup);
            }
        }
    }
    Iterable<String> toAlias;
    if (thisCommitGroups.isEmpty()) {
        // All parent groups were new in this push. Pick the first one and alias
        // other parents' groups to this first parent.
        String firstParentGroup = parentGroupsNewInThisPush.iterator().next();
        thisCommitGroups = ImmutableSet.of(firstParentGroup);
        toAlias = Iterables.skip(parentGroupsNewInThisPush, 1);
    } else {
        // For each parent group that was new in this push, alias it to the actual
        // computed group(s) for this commit.
        toAlias = parentGroupsNewInThisPush;
    }
    groups.putAll(c, thisCommitGroups);
    for (String pg : toAlias) {
        groupAliases.putAll(pg, thisCommitGroups);
    }
</td> </tr></table></body></html>