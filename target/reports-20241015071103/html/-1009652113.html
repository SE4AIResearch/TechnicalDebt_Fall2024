<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5640</td> <td>-1009652113</td><td>apache/hadoop</td><td>Arun Murthy</td><td>714edd65acb8d78640ea062e84ffe83c1e363738</td> <td>None</td> <td>Exception while writing to the client. Connection closure from
the other end is mostly the case and we do not care much about
it. But other things can go wrong, especially in transferTo(),
which we do not want to ignore.

The message parsing below should not be considered as a good
coding example. NEVER do it to drive a program logic. NEVER.
It was done here because the NIO throws an IOException for EPIPE.</td> <td>SATD_ADDED</td> <td>sendChunks(ByteBuffer, int, OutputStream)</td> <td>private int sendChunks(ByteBuffer pkt, int maxChunks, OutputStream out) throws IOException</td> <td>
    // Sends multiple chunks in one packet with a single write().
    int len = (int) Math.min(endOffset - offset, (((long) bytesPerChecksum) * ((long) maxChunks)));
    int numChunks = (len + bytesPerChecksum - 1) / bytesPerChecksum;
    int packetLen = len + numChunks * checksumSize + 4;
    boolean lastDataPacket = offset + len == endOffset && len > 0;
    pkt.clear();
    PacketHeader header = new PacketHeader(packetLen, offset, seqno, (len == 0), len);
    header.putInBuffer(pkt);
    int checksumOff = pkt.position();
    int checksumLen = numChunks * checksumSize;
    byte[] buf = pkt.array();
    if (checksumSize > 0 && checksumIn != null) {
        try {
            checksumIn.readFully(buf, checksumOff, checksumLen);
        } catch (IOException e) {
            LOG.warn(" Could not read or failed to veirfy checksum for data" + " at offset " + offset + " for block " + block + " got : " + StringUtils.stringifyException(e));
            IOUtils.closeStream(checksumIn);
            checksumIn = null;
            if (corruptChecksumOk) {
                if (checksumOff < checksumLen) {
                    // Just fill the array with zeros.
                    Arrays.fill(buf, checksumOff, checksumLen, (byte) 0);
                }
            } else {
                throw e;
            }
        }
        // write in progress that we need to use to get last checksum
        if (lastDataPacket && lastChunkChecksum != null) {
            int start = checksumOff + checksumLen - checksumSize;
            byte[] updatedChecksum = lastChunkChecksum.getChecksum();
            if (updatedChecksum != null) {
                System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);
            }
        }
    }
    int dataOff = checksumOff + checksumLen;
    if (blockInPosition < 0) {
        // normal transfer
        IOUtils.readFully(blockIn, buf, dataOff, len);
        if (verifyChecksum) {
            int dOff = dataOff;
            int cOff = checksumOff;
            int dLeft = len;
            for (int i = 0; i < numChunks; i++) {
                checksum.reset();
                int dLen = Math.min(dLeft, bytesPerChecksum);
                checksum.update(buf, dOff, dLen);
                if (!checksum.compare(buf, cOff)) {
                    long failedPos = offset + len - dLeft;
                    throw new ChecksumException("Checksum failed at " + failedPos, failedPos);
                }
                dLeft -= dLen;
                dOff += dLen;
                cOff += checksumSize;
            }
        }
    // writing is done below (mainly to handle IOException)
    }
    try {
        if (blockInPosition >= 0) {
            // use transferTo(). Checks on out and blockIn are already done.
            SocketOutputStream sockOut = (SocketOutputStream) out;
            // first write the packet
            sockOut.write(buf, 0, dataOff);
            // no need to flush. since we know out is not a buffered stream.
            sockOut.transferToFully(((FileInputStream) blockIn).getChannel(), blockInPosition, len);
            blockInPosition += len;
        } else {
            // normal transfer
            out.write(buf, 0, dataOff + len);
        }
    } catch (IOException e) {
        /* Exception while writing to the client. Connection closure from
       * the other end is mostly the case and we do not care much about
       * it. But other things can go wrong, especially in transferTo(),
       * which we do not want to ignore.
       *
       * The message parsing below should not be considered as a good
       * coding example. NEVER do it to drive a program logic. NEVER.
       * It was done here because the NIO throws an IOException for EPIPE.
       */
        String ioem = e.getMessage();
        if (!ioem.startsWith("Broken pipe") && !ioem.startsWith("Connection reset")) {
            LOG.error("BlockSender.sendChunks() exception: ", e);
        }
        throw ioeToSocketException(e);
    }
    if (throttler != null) {
        // rebalancing so throttle
        throttler.throttle(packetLen);
    }
    return len;
</td> </tr></table></body></html>