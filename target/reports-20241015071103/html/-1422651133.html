<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2255</td> 
     <td>-1422651133</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>340e5da400ef6e7f30ceb2265d974cd653e7ccdf</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createErrorHandler(RouteContext, Exchange, Processor)</td> 
     <td>protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor)</td> 
     <td> Processor answer; if (routeContext != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again // create key for cache final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor); // lookup cached first to reuse and preserve memory answer = errorHandlers.get(key); if (answer != null) { LOG.trace("Using existing error handler for: {}", processor); return answer; } LOG.trace("Creating error handler for: {}", processor); ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) try { processor = builder.createErrorHandler(routeContext, processor); } catch (Exception e) { throw ObjectHelper.wrapRuntimeCamelException(e); } // and wrap in unit of work processor so the copy exchange also can run under UoW answer = createUnitOfWorkProcessor(processor, exchange); // add to cache errorHandlers.putIfAbsent(key, answer); } else { // and wrap in unit of work processor so the copy exchange also can run under UoW answer = createUnitOfWorkProcessor(processor, exchange); } return answer; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2118</td> 
     <td>-1422651133</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>4796eb29f9a0378c0ea69ba480e78d303303518e</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createErrorHandler(RouteContext, Processor)</td> 
     <td>protected Processor createErrorHandler(RouteContext routeContext, Processor processor)</td> 
     <td> Processor answer; if (routeContext != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again // create key for cache final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor); // lookup cached first to reuse and preserve memory answer = errorHandlers.get(key); if (answer != null) { if (LOG.isTraceEnabled()) { LOG.trace("Using existing error handler for: " + processor); } return answer; } if (LOG.isTraceEnabled()) { LOG.trace("Creating error handler for: " + processor); } ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) try { processor = builder.createErrorHandler(routeContext, processor); } catch (Exception e) { throw ObjectHelper.wrapRuntimeCamelException(e); } // and wrap in unit of work processor so the copy exchange also can run under UoW answer = new UnitOfWorkProcessor(processor); // add to cache errorHandlers.putIfAbsent(key, answer); } else { // and wrap in unit of work processor so the copy exchange also can run under UoW answer = new UnitOfWorkProcessor(processor); } return answer; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2116</td> 
     <td>-1422651133</td> 
     <td>apache/camel</td> 
     <td>Ashwin J. Karpe</td> 
     <td>39cf1c051994e8359b1e9436923f2b2edea2c95a</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createErrorHandler(Exchange, Processor)</td> 
     <td>protected Processor createErrorHandler(Exchange exchange, Processor processor)</td> 
     <td> Processor answer = processor; if (exchange.getUnitOfWork() != null &amp;&amp; exchange.getUnitOfWork().getRouteContext() != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again RouteContext routeContext = exchange.getUnitOfWork().getRouteContext(); // create key for cache final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor); // lookup cached first to reuse and preserve memory answer = errorHandlers.get(key); if (answer != null) { if (LOG.isTraceEnabled()) { LOG.trace("Using existing error handler for: " + processor); } return answer; } if (LOG.isTraceEnabled()) { LOG.trace("Creating error handler for: " + processor); } ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) try { processor = builder.createErrorHandler(routeContext, processor); // and wrap in unit of work processor so the copy exchange also can run under UoW answer = new UnitOfWorkProcessor(processor); } catch (Exception e) { throw ObjectHelper.wrapRuntimeCamelException(e); } // add to cache errorHandlers.putIfAbsent(key, answer); } return answer; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1918</td> 
     <td>-1422651133</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>2fb8090dd3b18feb0f35f3c53b95535946874ad0</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createProcessorExchangePair(int, Processor, Exchange)</td> 
     <td>protected ProcessorExchangePair createProcessorExchangePair(int index, Processor processor, Exchange exchange)</td> 
     <td> Processor prepared = processor; // set property which endpoint we send to setToEndpoint(exchange, prepared); // rework error handling to support fine grained error handling if (exchange.getUnitOfWork() != null &amp;&amp; exchange.getUnitOfWork().getRouteContext() != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again RouteContext routeContext = exchange.getUnitOfWork().getRouteContext(); ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) try { prepared = builder.createErrorHandler(routeContext, prepared); } catch (Exception e) { throw ObjectHelper.wrapRuntimeCamelException(e); } } return new DefaultProcessorExchangePair(index, processor, prepared, exchange); </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1740</td> 
     <td>-1422651133</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>cb59b662bfc011453aa2e12907ee650542966233</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createProcessorExchangePair(Processor, Exchange)</td> 
     <td>protected static ProcessorExchangePair createProcessorExchangePair(Processor processor, Exchange exchange)</td> 
     <td> Processor prepared = processor; // set property which endpoint we send to setToEndpoint(exchange, prepared); // rework error handling to support fine grained error handling if (exchange.getUnitOfWork() != null &amp;&amp; exchange.getUnitOfWork().getRouteContext() != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again RouteContext routeContext = exchange.getUnitOfWork().getRouteContext(); ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) try { prepared = builder.createErrorHandler(routeContext, prepared); } catch (Exception e) { throw ObjectHelper.wrapRuntimeCamelException(e); } } return new ProcessorExchangePair(processor, prepared, exchange); </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>