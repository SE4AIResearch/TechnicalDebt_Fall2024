<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2652</td> 
     <td>-1422650632</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>1b2f65732abf3ce2a800c5c10d0cf6a0392eca1a</td> 
     <td>warn if using concurrent consumer with shared reply queue as that may not work properly</td> 
     <td>warn if using concurrent consumer with shared reply queue as that may not work properly</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>createListenerContainer()</td> 
     <td>protected AbstractMessageListenerContainer createListenerContainer() throws Exception</td> 
     <td> DefaultMessageListenerContainer answer; ReplyToType type = endpoint.getConfiguration().getReplyToType(); if (type == null) { // use shared by default for reply queues type = ReplyToType.Shared; } if (ReplyToType.Shared == type) { // shared reply to queues support either a fixed or dynamic JMS message selector String replyToSelectorName = endpoint.getReplyToDestinationSelectorName(); if (replyToSelectorName != null) { // create a random selector value we will use for the reply queue replyToSelectorValue = "ID:" + new BigInteger(24 * 8, new Random()).toString(16); String fixedMessageSelector = replyToSelectorName + "='" + replyToSelectorValue + "'"; answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector); // must use cache level consumer for fixed message selector answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER); log.debug("Using shared queue: " + endpoint.getReplyTo() + " with fixed message selector [" + fixedMessageSelector + "] as reply listener: " + answer); } else { // use a dynamic message selector which will select the message we want to receive as reply dynamicMessageSelector = new MessageSelectorCreator(correlation); answer = new SharedQueueMessageListenerContainer(endpoint, dynamicMessageSelector); // must use cache level session for dynamic message selector, // as otherwise the dynamic message selector will not be updated on-the-fly answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION); log.debug("Using shared queue: " + endpoint.getReplyTo() + " with dynamic message selector as reply listener: " + answer); } // shared is not as fast as temporary or exclusive, so log this so the end user may be aware of this log.warn("{} is using a shared reply queue, which is not as fast as alternatives." + " See more detail at the section 'Request-reply over JMS' at http://camel.apache.org/jms", endpoint); } else if (ReplyToType.Exclusive == type) { answer = new ExclusiveQueueMessageListenerContainer(endpoint); // must use cache level consumer for exclusive as there is no message selector answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER); log.debug("Using exclusive queue:" + endpoint.getReplyTo() + " as reply listener: " + answer); } else { throw new IllegalArgumentException("ReplyToType " + type + " is not supported for reply queues"); } String replyToCacheLevelName = endpoint.getConfiguration().getReplyToCacheLevelName(); if (replyToCacheLevelName != null) { answer.setCacheLevelName(replyToCacheLevelName); log.debug("Setting the replyCacheLevel to be " + replyToCacheLevelName); } DestinationResolver resolver = endpoint.getDestinationResolver(); if (resolver == null) { resolver = answer.getDestinationResolver(); } answer.setDestinationResolver(new DestinationResolverDelegate(resolver)); answer.setDestinationName(endpoint.getReplyTo()); answer.setAutoStartup(true); answer.setIdleConsumerLimit(endpoint.getIdleConsumerLimit()); answer.setIdleTaskExecutionLimit(endpoint.getIdleTaskExecutionLimit()); if (endpoint.getMaxMessagesPerTask() &gt;= 0) { answer.setMaxMessagesPerTask(endpoint.getMaxMessagesPerTask()); } answer.setMessageListener(this); answer.setPubSubDomain(false); answer.setSubscriptionDurable(false); answer.setConcurrentConsumers(endpoint.getConcurrentConsumers()); if (endpoint.getMaxConcurrentConsumers() &gt; 0) { answer.setMaxConcurrentConsumers(endpoint.getMaxConcurrentConsumers()); } answer.setConnectionFactory(endpoint.getConnectionFactory()); String clientId = endpoint.getClientId(); if (clientId != null) { clientId += ".CamelReplyManager"; answer.setClientId(clientId); } // we cannot do request-reply over JMS with transaction answer.setSessionTransacted(false); // other optional properties if (endpoint.getExceptionListener() != null) { answer.setExceptionListener(endpoint.getExceptionListener()); } if (endpoint.getErrorHandler() != null) { answer.setErrorHandler(endpoint.getErrorHandler()); } else { answer.setErrorHandler(new DefaultSpringErrorHandler(QueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace())); } if (endpoint.getReceiveTimeout() &gt;= 0) { answer.setReceiveTimeout(endpoint.getReceiveTimeout()); } if (endpoint.getRecoveryInterval() &gt;= 0) { answer.setRecoveryInterval(endpoint.getRecoveryInterval()); } // set task executor if (endpoint.getTaskExecutor() != null) { if (log.isDebugEnabled()) { log.debug("Using custom TaskExecutor: {} on listener container: {}", endpoint.getTaskExecutor(), answer); } answer.setTaskExecutor(endpoint.getTaskExecutor()); } // setup a bean name which is used ny Spring JMS as the thread name String name = "QueueReplyManager[" + answer.getDestinationName() + "]"; answer.setBeanName(name); if (answer.getConcurrentConsumers() &gt; 1) { if (ReplyToType.Shared == type) { // warn if using concurrent consumer with shared reply queue as that may not work properly log.warn("Using {}-{} concurrent consumer on {} with shared queue {} may not work properly with all message brokers.", new Object[] { answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name, endpoint.getReplyTo() }); } else { // log that we are using concurrent consumers log.info("Using {}-{} concurrent consumers on {}", new Object[] { answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name }); } } return answer; </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>2639</td> 
     <td>-1422650632</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>0e8aff74bb13110553d91fb87f0bebe0ea8438d7</td> 
     <td>None</td> 
     <td>warn if using concurrent consumer with shared reply queue as that may not work properly</td> 
     <td>SATD_ADDED</td> 
     <td>createListenerContainer()</td> 
     <td>protected AbstractMessageListenerContainer createListenerContainer() throws Exception</td> 
     <td> DefaultMessageListenerContainer answer; ReplyToType type = endpoint.getConfiguration().getReplyToType(); if (type == null) { // use shared by default for persistent reply queues type = ReplyToType.Shared; } if (ReplyToType.Shared == type) { // shared reply to queues support either a fixed or dynamic JMS message selector String replyToSelectorName = endpoint.getReplyToDestinationSelectorName(); if (replyToSelectorName != null) { // create a random selector value we will use for the persistent reply queue replyToSelectorValue = "ID:" + new BigInteger(24 * 8, new Random()).toString(16); String fixedMessageSelector = replyToSelectorName + "='" + replyToSelectorValue + "'"; answer = new SharedPersistentQueueMessageListenerContainer(fixedMessageSelector); // must use cache level consumer for fixed message selector answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER); log.debug("Using shared queue: " + endpoint.getReplyTo() + " with fixed message selector [" + fixedMessageSelector + "] as reply listener: " + answer); } else { // use a dynamic message selector which will select the message we want to receive as reply dynamicMessageSelector = new MessageSelectorCreator(correlation); answer = new SharedPersistentQueueMessageListenerContainer(dynamicMessageSelector); // must use cache level session for dynamic message selector, // as otherwise the dynamic message selector will not be updated on-the-fly answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION); log.debug("Using shared queue: " + endpoint.getReplyTo() + " with dynamic message selector as reply listener: " + answer); } // shared is not as fast as temporary or exclusive, so log this so the end user may be aware of this log.warn("{} is using a shared reply queue, which is not as fast as alternatives." + " See more detail at the section 'Request-reply over JMS' at http://camel.apache.org/jms", endpoint); } else if (ReplyToType.Exclusive == type) { answer = new ExclusivePersistentQueueMessageListenerContainer(); // must use cache level consumer for exclusive as there is no message selector answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER); log.debug("Using exclusive queue:" + endpoint.getReplyTo() + " as reply listener: " + answer); } else { throw new IllegalArgumentException("ReplyToType " + type + " is not supported for persistent reply queues"); } String replyToCacheLevelName = endpoint.getConfiguration().getReplyToCacheLevelName(); if (replyToCacheLevelName != null) { answer.setCacheLevelName(replyToCacheLevelName); log.debug("Setting the replyCacheLevel to be " + replyToCacheLevelName); } DestinationResolver resolver = endpoint.getDestinationResolver(); if (resolver == null) { resolver = answer.getDestinationResolver(); } answer.setDestinationResolver(new DestinationResolverDelegate(resolver)); answer.setDestinationName(endpoint.getReplyTo()); answer.setAutoStartup(true); answer.setMessageListener(this); answer.setPubSubDomain(false); answer.setSubscriptionDurable(false); answer.setConcurrentConsumers(endpoint.getConcurrentConsumers()); if (endpoint.getMaxConcurrentConsumers() &gt; 0) { answer.setMaxConcurrentConsumers(endpoint.getMaxConcurrentConsumers()); } answer.setConnectionFactory(endpoint.getConnectionFactory()); String clientId = endpoint.getClientId(); if (clientId != null) { clientId += ".CamelReplyManager"; answer.setClientId(clientId); } // we cannot do request-reply over JMS with transaction answer.setSessionTransacted(false); // other optional properties if (endpoint.getExceptionListener() != null) { answer.setExceptionListener(endpoint.getExceptionListener()); } if (endpoint.getErrorHandler() != null) { answer.setErrorHandler(endpoint.getErrorHandler()); } else { answer.setErrorHandler(new DefaultSpringErrorHandler(PersistentQueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace())); } if (endpoint.getReceiveTimeout() &gt;= 0) { answer.setReceiveTimeout(endpoint.getReceiveTimeout()); } if (endpoint.getRecoveryInterval() &gt;= 0) { answer.setRecoveryInterval(endpoint.getRecoveryInterval()); } // do not use a task executor for reply as we are are always a single threaded task // setup a bean name which is used ny Spring JMS as the thread name String name = "PersistentQueueReplyManager[" + answer.getDestinationName() + "]"; String beanName = endpoint.getCamelContext().getExecutorServiceManager().resolveThreadName(name); answer.setBeanName(beanName); if (answer.getConcurrentConsumers() &gt; 1) { if (ReplyToType.Shared == type) { // warn if using concurrent consumer with shared reply queue as that may not work properly log.warn("Using {}-{} concurrent consumer on {} with shared queue {} may not work properly with all message brokers.", new Object[] { answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name, endpoint.getReplyTo() }); } else { // log that we are using concurrent consumers log.info("Using {}-{} concurrent consumers on {}", new Object[] { answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name }); } } return answer; </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>