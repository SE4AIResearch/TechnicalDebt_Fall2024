<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1633</td> <td>-1422651202</td><td>apache/camel</td><td>Hadrian Zbarcea</td><td>5381eb5cc5d94237ec5e5ff4637a4cc09655cb39</td> <td>not an exact match so find the best candidate</td> <td>not an exact match so find the best candidate</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition>, Exchange, Throwable, Map<Integer, OnExceptionDefinition>)</td> <td>private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception, Map<Integer, OnExceptionDefinition> candidates)</td> <td>
    if (LOG.isTraceEnabled()) {
        LOG.trace("Finding best suited exception policy for thrown exception " + exception.getClass().getName());
    }
    // the goal is to find the exception with the same/closet inheritance level as the target exception being thrown
    int targetLevel = getInheritanceLevel(exception.getClass());
    // candidate is the best candidate found so far to return
    OnExceptionDefinition candidate = null;
    // difference in inheritance level between the current candidate and the thrown exception (target level)
    int candidateDiff = Integer.MAX_VALUE;
    // loop through all the entries and find the best candidates to use
    Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet();
    for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {
        Class clazz = entry.getKey().getExceptionClass();
        OnExceptionDefinition type = entry.getValue();
        if (filter(type, clazz, exception)) {
            // must match
            if (!matchesWhen(type, exchange)) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace("The type did not match when: " + type);
                }
                continue;
            }
            // exact match then break
            if (clazz.equals(exception.getClass())) {
                candidate = type;
                candidateDiff = 0;
                break;
            }
            // not an exact match so find the best candidate
            int level = getInheritanceLevel(clazz);
            int diff = targetLevel - level;
            if (diff < candidateDiff) {
                // replace with a much better candidate
                candidate = type;
                candidateDiff = diff;
            }
        }
    }
    if (candidate != null) {
        if (!candidates.containsKey(candidateDiff)) {
            // only add as candidate if we do not already have it registered with that level
            if (LOG.isTraceEnabled()) {
                LOG.trace("Adding " + candidate + " as candidate at level " + candidateDiff);
            }
            candidates.put(candidateDiff, candidate);
        } else {
            // we have an existing candidate already which we should prefer to use
            if (LOG.isTraceEnabled()) {
                LOG.trace("Existing candidate " + candidates.get(candidateDiff) + " takes precedence over " + candidate + " at level " + candidateDiff);
            }
        }
    }
    // if we found a exact match then we should stop continue looking
    boolean exactMatch = candidateDiff == 0;
    if (LOG.isTraceEnabled() && exactMatch) {
        LOG.trace("Exact match found for candidate: " + candidate);
    }
    return exactMatch;
</td> </tr></table></body></html>