<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1417</td> <td>-1422651322</td><td>apache/camel</td><td>Claus Ibsen</td><td>b2bee1a966adb03063c9e6e3e22bfd5ebf2ae52c</td> <td>TODO: divde into onException and deadLetterQueue
no then move it to the dead letter queue</td> <td>prepare the exchange for failure before returning</td> <td>SATD_REMOVED</td> <td>processErrorHandler(Exchange, RedeliveryData)</td> <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> <td>
    while (true) {
        // we can't keep retrying if the route is being shutdown.
        if (!isRunAllowed()) {
            if (log.isDebugEnabled()) {
                log.debug("Rejected execution as we are not started for exchange: " + exchange);
            }
            if (exchange.getException() == null) {
                exchange.setException(new RejectedExecutionException());
                return;
            }
        }
        // do not handle transacted exchanges that failed as this error handler does not support it
        if (exchange.isTransacted() && !supportTransacted() && exchange.getException() != null) {
            if (log.isDebugEnabled()) {
                log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId());
            }
            return;
        }
        // did previous processing cause an exception?
        if (exchange.getException() != null) {
            handleException(exchange, data);
        }
        // compute if we should redeliver or not
        boolean shouldRedeliver = shouldRedeliver(exchange, data);
        if (!shouldRedeliver) {
            // no we should not redeliver to the same output so either try an onException (if any given)
            // or the dead letter queue
            Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor;
            // deliver to the failure processor (either an on exception or dead letter queue
            deliverToFailureProcessor(target, exchange, data);
            // prepare the exchange for failure before returning
            prepareExchangeAfterFailure(exchange, data);
            // and then return
            return;
        }
        // if we are redelivering then sleep before trying again
        if (shouldRedeliver && data.redeliveryCounter > 0) {
            prepareExchangeForRedelivery(exchange);
            // wait until we should redeliver
            try {
                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter);
            } catch (InterruptedException e) {
                log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped()));
                // continue from top
                continue;
            }
            // letting onRedeliver be executed
            deliverToRedeliveryProcessor(exchange, data);
        }
        // process the exchange (also redelivery)
        try {
            output.process(exchange);
        } catch (Exception e) {
            exchange.setException(e);
        }
        // only done if the exchange hasn't failed
        // and it has not been handled by the failure processor
        boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange);
        if (done) {
            return;
        }
    // error occurred so loop back around.....
    }
</td> </tr></table></body></html>