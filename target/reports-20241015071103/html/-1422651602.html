<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2703</td> 
     <td>-1422651602</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>84364bfcafd48f8b60fe97e9c09e9b18def2b215</td> 
     <td>loop and execute the best setter method</td> 
     <td>loop and execute the best setter method</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>setProperty(CamelContext, TypeConverter, Object, String, Object, String, boolean)</td> 
     <td>public static boolean setProperty(CamelContext context, TypeConverter typeConverter, Object target, String name, Object value, String refName, boolean allowBuilderPattern) throws Exception</td> 
     <td> Class<!--?--> clazz = target.getClass(); Collection<method>
        setters; // we need to lookup the value from the registry if (context != null &amp;&amp; refName != null &amp;&amp; value == null) { setters = findSetterMethodsOrderedByParameterType(clazz, name, allowBuilderPattern); } else { // find candidates of setter methods as there can be overloaded setters setters = findSetterMethods(clazz, name, value, allowBuilderPattern); } if (setters.isEmpty()) { return false; } // loop and execute the best setter method Exception typeConversionFailed = null; for (Method setter : setters) { Class parameterType = setter.getParameterTypes()[0]; Object ref = value; // try and lookup the reference based on the method if (context != null &amp;&amp; refName != null &amp;&amp; ref == null) { ref = CamelContextHelper.lookup(context, refName.replaceAll("#", ""), parameterType); if (ref == null) { // try the next method if nothing was found continue; } } try { try { // If the type is null or it matches the needed type, just use the value directly if (value == null || parameterType.isAssignableFrom(ref.getClass())) { setter.invoke(target, ref); if (LOG.isDebugEnabled()) { LOG.debug("Configured property: {} on bean: {} with value: {}", new Object[] { name, target, ref }); } return true; } else { // We need to convert it Object convertedValue = convert(typeConverter, parameterType, ref); setter.invoke(target, convertedValue); if (LOG.isDebugEnabled()) { LOG.debug("Configured property: {} on bean: {} with value: {}", new Object[] { name, target, ref }); } return true; } } catch (InvocationTargetException e) { // lets unwrap the exception Throwable throwable = e.getCause(); if (throwable instanceof Exception) { Exception exception = (Exception) throwable; throw exception; } else { Error error = (Error) throwable; throw error; } } // ignore exceptions as there could be another setter method where we could type convert successfully } catch (NoTypeConversionAvailableException e) { typeConversionFailed = e; } catch (IllegalArgumentException e) { typeConversionFailed = e; } if (LOG.isTraceEnabled()) { LOG.trace("Setter \"{}\" with parameter type \"{}\" could not be used for type conversions of {}", new Object[] { setter, parameterType, ref }); } } if (typeConversionFailed != null) { // we did not find a setter method to use, and if we did try to use a type converter then throw // this kind of exception as the caused by will hint this error throw new IllegalArgumentException("Could not find a suitable setter for property: " + name + " as there isn't a setter method with same type: " + value.getClass().getCanonicalName() + " nor type conversion possible: " + typeConversionFailed.getMessage()); } else { return false; } 
      </method></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2333</td> 
     <td>-1422651602</td> 
     <td>apache/camel</td> 
     <td>Christian Schneider</td> 
     <td>79dfc61cdfc12793f341e3cc192a9932a52d03ca</td> 
     <td>loop and execute the best setter method</td> 
     <td>loop and execute the best setter method</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>setProperty(TypeConverter, Object, String, Object, boolean)</td> 
     <td>public static boolean setProperty(TypeConverter typeConverter, Object target, String name, Object value, boolean allowBuilderPattern) throws Exception</td> 
     <td> try { Class<!--?--> clazz = target.getClass(); // find candidates of setter methods as there can be overloaded setters Set<method>
        setters = findSetterMethods(typeConverter, clazz, name, value, allowBuilderPattern); if (setters.isEmpty()) { return false; } // loop and execute the best setter method Exception typeConversionFailed = null; for (Method setter : setters) { // If the type is null or it matches the needed type, just use the value directly if (value == null || setter.getParameterTypes()[0].isAssignableFrom(value.getClass())) { setter.invoke(target, value); return true; } else { // We need to convert it try { // ignore exceptions as there could be another setter method where we could type convert successfully Object convertedValue = convert(typeConverter, setter.getParameterTypes()[0], value); setter.invoke(target, convertedValue); return true; } catch (NoTypeConversionAvailableException e) { typeConversionFailed = e; } catch (IllegalArgumentException e) { typeConversionFailed = e; } if (LOG.isTraceEnabled()) { LOG.trace("Setter \"{}\" with parameter type \"{}\" could not be used for type conversions of {}", new Object[] { setter, setter.getParameterTypes()[0], value }); } } } // we did not find a setter method to use, and if we did try to use a type converter then throw // this kind of exception as the caused by will hint this error if (typeConversionFailed != null) { throw new IllegalArgumentException("Could not find a suitable setter for property: " + name + " as there isn't a setter method with same type: " + value.getClass().getCanonicalName() + " nor type conversion possible: " + typeConversionFailed.getMessage()); } else { return false; } } catch (InvocationTargetException e) { // lets unwrap the exception Throwable throwable = e.getCause(); if (throwable instanceof Exception) { Exception exception = (Exception) throwable; throw exception; } else { Error error = (Error) throwable; throw error; } } 
      </method></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>790</td> 
     <td>-1422651602</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>37093dfba3b1fe3d383eda5061eac9b81360e9ff</td> 
     <td>None</td> 
     <td>loop and execute the best setter method</td> 
     <td>SATD_ADDED</td> 
     <td>setProperty(TypeConverter, Object, String, Object)</td> 
     <td>public static boolean setProperty(TypeConverter typeConverter, Object target, String name, Object value) throws Exception</td> 
     <td> try { Class clazz = target.getClass(); // find candidates of setter methods as there can be overloaded setters Set<method>
        setters = findSetterMethods(typeConverter, clazz, name, value); if (setters.isEmpty()) { return false; } // loop and execute the best setter method Exception typeConvertionFailed = null; for (Method setter : setters) { // If the type is null or it matches the needed type, just use the value directly if (value == null || value.getClass() == setter.getParameterTypes()[0]) { setter.invoke(target, value); return true; } else { // We need to convert it try { Object convertedValue = convert(typeConverter, setter.getParameterTypes()[0], value); setter.invoke(target, convertedValue); return true; } catch (IllegalArgumentException e) { typeConvertionFailed = e; // ignore as there could be another setter method where we could type convert with success LOG.trace("Setter " + setter + " with parameter type " + setter.getParameterTypes()[0] + " could not be used for type conertions of " + value); } } } // we did not find a setter method to use, and if we did try to use a type converter then throw // this kind of exception as the caused by will hint this error if (typeConvertionFailed != null) { throw new IllegalArgumentException("Could not find a suitable setter for property: " + name + " as there isn't a setter method with same type: " + value.getClass().getCanonicalName() + " nor type convertion possbile: " + typeConvertionFailed.getMessage()); } else { return false; } } catch (InvocationTargetException e) { Throwable throwable = e.getTargetException(); if (throwable instanceof Exception) { Exception exception = (Exception) throwable; throw exception; } else { Error error = (Error) throwable; throw error; } } 
      </method></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>