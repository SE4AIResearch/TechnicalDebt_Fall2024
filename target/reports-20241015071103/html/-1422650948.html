<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2090</td> <td>-1422650948</td><td>apache/camel</td><td>Hadrian Zbarcea</td><td>362b01d384e4ce97f9134e48e943956401951c80</td> <td>None</td> <td>
gnodet: the initialization of the CamelContextFactoryBean is now done at the end of the blueprint
container creation through the use of a ComponentDefinitionRegistryProcessor (those are called
after all the beans have been initialized.  That's why the calls to #afterPropertiesSet and
#init are commented.
This mechanism is now required because the #afterPropertiesSet method on the CamelContext
will search through the blueprint beans for beans implementing known interfaces such as
LifeCycle strategies, etc... so that they are automatically wired to the CamelContext.
However, Blueprint does not support real factories, so in order to do so, we need to actually
access the beans which lead to a circular exception while looking for the CamelContext itself.
</td> <td>SATD_ADDED</td> <td>renameNamespaceRecursive(Node)</td> <td>public static void renameNamespaceRecursive(Node node)</td> <td>
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        Document doc = node.getOwnerDocument();
        if (((Element) node).getNamespaceURI().equals(BLUEPRINT_NS)) {
            doc.renameNode(node, SPRING_NS, node.getNodeName());
        }
    }
    NodeList list = node.getChildNodes();
    for (int i = 0; i < list.getLength(); ++i) {
        renameNamespaceRecursive(list.item(i));
    }
</td> </tr></table></body></html>