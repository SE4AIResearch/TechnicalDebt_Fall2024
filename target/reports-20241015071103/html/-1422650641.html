<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2700</td> 
     <td>-1422650641</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>bdf5686bac11f742fa0339accdc039566533aeeb</td> 
     <td>special as we have hardcoded parameters, so we need to choose method that matches those parameters the best</td> 
     <td>special as we have hardcoded parameters, so we need to choose method that matches those parameters the best</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>chooseMethod(Object, Exchange, String)</td> 
     <td>protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException</td> 
     <td> // @Handler should be select first // then any single method that has a custom @annotation // or any single method that has a match parameter type that matches the Exchange payload // and last then try to select the best among the rest // must use defensive copy, to avoid altering the shared lists // and we want to remove unwanted operations from these local lists final List<methodinfo>
        localOperationsWithBody = new ArrayList 
       <methodinfo>
         (operationsWithBody); final List 
        <methodinfo>
          localOperationsWithNoBody = new ArrayList 
         <methodinfo>
           (operationsWithNoBody); final List 
          <methodinfo>
            localOperationsWithCustomAnnotation = new ArrayList 
           <methodinfo>
             (operationsWithCustomAnnotation); final List 
            <methodinfo>
              localOperationsWithHandlerAnnotation = new ArrayList 
             <methodinfo>
               (operationsWithHandlerAnnotation); if (name != null) { // filter all lists to only include methods with this name removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name); removeNonMatchingMethods(localOperationsWithCustomAnnotation, name); removeNonMatchingMethods(localOperationsWithBody, name); removeNonMatchingMethods(localOperationsWithNoBody, name); } else { // remove all getter/setter as we do not want to consider these methods removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation); removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation); removeAllSetterOrGetterMethods(localOperationsWithBody); removeAllSetterOrGetterMethods(localOperationsWithNoBody); } if (localOperationsWithHandlerAnnotation.size() &gt; 1) { // if we have more than 1 @Handler then its ambiguous throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation); } if (localOperationsWithHandlerAnnotation.size() == 1) { // methods with handler should be preferred return localOperationsWithHandlerAnnotation.get(0); } else if (localOperationsWithCustomAnnotation.size() == 1) { // if there is one method with an annotation then use that one return localOperationsWithCustomAnnotation.get(0); } // named method and with no parameters boolean noParameters = name != null &amp;&amp; name.endsWith("()"); if (noParameters &amp;&amp; localOperationsWithNoBody.size() == 1) { // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters) return localOperationsWithNoBody.get(0); } else if (localOperationsWithBody.size() == 1) { // if there is one method with body then use that one return localOperationsWithBody.get(0); } Collection 
              <methodinfo>
                possibleOperations = new ArrayList 
               <methodinfo>
                 (); possibleOperations.addAll(localOperationsWithBody); possibleOperations.addAll(localOperationsWithCustomAnnotation); if (!possibleOperations.isEmpty()) { // multiple possible operations so find the best suited if possible MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation); if (answer == null &amp;&amp; name != null) { // do we have hardcoded parameters values provided from the method name then fallback and try that String parameters = ObjectHelper.between(name, "(", ")"); if (parameters != null) { // special as we have hardcoded parameters, so we need to choose method that matches those parameters the best answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations); } } if (answer == null) { throw new AmbiguousMethodCallException(exchange, possibleOperations); } else { return answer; } } // not possible to determine return null; 
               </methodinfo> 
              </methodinfo> 
             </methodinfo> 
            </methodinfo> 
           </methodinfo> 
          </methodinfo> 
         </methodinfo> 
        </methodinfo> 
       </methodinfo> 
      </methodinfo></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2692</td> 
     <td>-1422650641</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>14669b432024f7321ad0dd9a1df68b4aa38bf156</td> 
     <td>special as we have hardcoded parameters, so we need to choose method that matches those parameters the best</td> 
     <td>special as we have hardcoded parameters, so we need to choose method that matches those parameters the best</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>getType()</td> 
     <td>public Class<!--?--> getType()</td> 
     <td> return type; </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>2625</td> 
     <td>-1422650641</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>f7e50f34ca5d46a3bbb45edd5743a4e7f5e2ac02</td> 
     <td>None</td> 
     <td>special as we have hardcoded parameters, so we need to choose method that matches those parameters the best</td> 
     <td>SATD_ADDED</td> 
     <td>chooseMethod(Object, Exchange, String)</td> 
     <td>protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException</td> 
     <td> // @Handler should be select first // then any single method that has a custom @annotation // or any single method that has a match parameter type that matches the Exchange payload // and last then try to select the best among the rest // must use defensive copy, to avoid altering the shared lists // and we want to remove unwanted operations from these local lists final List<methodinfo>
        localOperationsWithBody = new ArrayList
       <methodinfo>
        (operationsWithBody); final List
        <methodinfo>
          localOperationsWithNoBody = new ArrayList
         <methodinfo>
          (operationsWithNoBody); final List
          <methodinfo>
            localOperationsWithCustomAnnotation = new ArrayList
           <methodinfo>
            (operationsWithCustomAnnotation); final List
            <methodinfo>
              localOperationsWithHandlerAnnotation = new ArrayList
             <methodinfo>
              (operationsWithHandlerAnnotation); if (name != null) { // filter all lists to only include methods with this name removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name); removeNonMatchingMethods(localOperationsWithCustomAnnotation, name); removeNonMatchingMethods(localOperationsWithBody, name); removeNonMatchingMethods(localOperationsWithNoBody, name); } else { // remove all getter/setter as we do not want to consider these methods removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation); removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation); removeAllSetterOrGetterMethods(localOperationsWithBody); removeAllSetterOrGetterMethods(localOperationsWithNoBody); } if (localOperationsWithHandlerAnnotation.size() &gt; 1) { // if we have more than 1 @Handler then its ambiguous throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation); } if (localOperationsWithHandlerAnnotation.size() == 1) { // methods with handler should be preferred return localOperationsWithHandlerAnnotation.get(0); } else if (localOperationsWithCustomAnnotation.size() == 1) { // if there is one method with an annotation then use that one return localOperationsWithCustomAnnotation.get(0); } // named method and with no parameters boolean noParameters = name != null &amp;&amp; name.endsWith("()"); if (noParameters &amp;&amp; localOperationsWithNoBody.size() == 1) { // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters) return localOperationsWithNoBody.get(0); } else if (localOperationsWithBody.size() == 1) { // if there is one method with body then use that one return localOperationsWithBody.get(0); } Collection
              <methodinfo>
                possibleOperations = new ArrayList
               <methodinfo>
                (); possibleOperations.addAll(localOperationsWithBody); possibleOperations.addAll(localOperationsWithCustomAnnotation); if (!possibleOperations.isEmpty()) { // multiple possible operations so find the best suited if possible MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation); if (answer == null &amp;&amp; name != null) { // do we have hardcoded parameters values provided from the method name then fallback and try that String parameters = ObjectHelper.between(name, "(", ")"); if (parameters != null) { // special as we have hardcoded parameters, so we need to choose method that matches those parameters the best answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations); } } if (answer == null) { throw new AmbiguousMethodCallException(exchange, possibleOperations); } else { return answer; } } // not possible to determine return null; 
               </methodinfo>
              </methodinfo>
             </methodinfo>
            </methodinfo>
           </methodinfo>
          </methodinfo>
         </methodinfo>
        </methodinfo>
       </methodinfo>
      </methodinfo></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>