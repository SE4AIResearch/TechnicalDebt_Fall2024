<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1261</td> <td>-1422651398</td><td>apache/camel</td><td>Claus Ibsen</td><td>cf11eb8fb4e6ca187b573513e49b58cdc361771b</td> <td>TODO: Disabled for now until we find a better strategy for registering routes in the JMX
without altering the route model. The route model should be much the same as without JMX to avoid
a gap that causes pain to get working with and without JMX enabled. We have seen to many issues with this already.</td> <td>add an intercept strategy that counts when the route sends to any of its outputs</td> <td>SATD_REMOVED</td> <td>onRouteContextCreate(RouteContext)</td> <td>public void onRouteContextCreate(RouteContext routeContext)</td> <td>
    // the agent hasn't been started
    if (!initialized) {
        return;
    }
    // Create a map (ProcessorType -> PerformanceCounter)
    // to be passed to InstrumentationInterceptStrategy.
    Map<ProcessorDefinition, PerformanceCounter> registeredCounters = new HashMap<ProcessorDefinition, PerformanceCounter>();
    // Each processor in a route will have its own performance counter
    // The performance counter are MBeans that we register with MBeanServer.
    // These performance counter will be embedded
    // to InstrumentationProcessor and wrap the appropriate processor
    // by InstrumentationInterceptStrategy.
    RouteDefinition route = routeContext.getRoute();
    // TODO: This only registers counters for the first outputs in the route
    // all the chidren of the outputs is not registered
    // we should leverge the Channel for this to ensure we register all processors
    // in the entire route graph
    // register all processors
    for (ProcessorDefinition processor : route.getOutputs()) {
        ObjectName name = null;
        try {
            // get the mbean name
            name = getNamingStrategy().getObjectName(routeContext, processor);
            // register mbean wrapped in the performance counter mbean
            PerformanceCounter pc = new PerformanceCounter();
            agent.register(pc, name);
            // add to map now that it has been registered
            registeredCounters.put(processor, pc);
        } catch (MalformedObjectNameException e) {
            LOG.warn("Could not create MBean name: " + name, e);
        } catch (JMException e) {
            LOG.warn("Could not register PerformanceCounter MBean: " + name, e);
        }
    }
    // add intercept strategy that executes the JMX instrumentation for performance metrics
    // TODO: We could do as below with an inlined implementation instead of a separate class
    routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters));
    // instrument the route endpoint
    final Endpoint endpoint = routeContext.getEndpoint();
    // only needed to register on the first output as all rotues will pass through this one
    ProcessorDefinition out = routeContext.getRoute().getOutputs().get(0);
    // add an intercept strategy that counts when the route sends to any of its outputs
    out.addInterceptStrategy(new InterceptStrategy() {

        public Processor wrapProcessorInInterceptors(ProcessorDefinition processorDefinition, Processor target) throws Exception {
            if (registeredRoutes.containsKey(endpoint)) {
                // do not double wrap
                return target;
            }
            InstrumentationProcessor wrapper = new InstrumentationProcessor(null);
            wrapper.setType(processorDefinition.getShortName());
            wrapper.setProcessor(target);
            // register our wrapper
            registeredRoutes.put(endpoint, wrapper);
            return wrapper;
        }
    });
</td> </tr></table></body></html>