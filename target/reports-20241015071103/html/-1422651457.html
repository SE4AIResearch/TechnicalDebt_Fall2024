<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1788</td> 
     <td>-1422651457</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>80448160f0a8569def7e5476fc9036209f249cbc</td> 
     <td>TODO: should we throw an exception instead?</td> 
     <td>warn if the body could not be mapped</td> 
     <td>SATD_REMOVED</td> 
     <td>createJmsMessage(Exchange, Object, Map<string, object>
        , Session, CamelContext) 
      </string,></td> 
     <td>protected Message createJmsMessage(Exchange exchange, Object body, Map<string, object>
        headers, Session session, CamelContext context) throws JMSException 
      </string,></td> 
     <td> JmsMessageType type = null; // special for transferExchange if (endpoint != null &amp;&amp; endpoint.isTransferExchange()) { if (LOG.isTraceEnabled()) { LOG.trace("Option transferExchange=true so we use JmsMessageType: Object"); } Serializable holder = DefaultExchangeHolder.marshal(exchange); return session.createObjectMessage(holder); } // use a custom message converter if (endpoint != null &amp;&amp; endpoint.getMessageConverter() != null) { if (LOG.isTraceEnabled()) { LOG.trace("Creating JmsMessage using a custom MessageConverter: " + endpoint.getMessageConverter() + " with body: " + body); } return endpoint.getMessageConverter().toMessage(body, session); } // check if header have a type set, if so we force to use it if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) { type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE)); } else if (endpoint != null &amp;&amp; endpoint.getConfiguration().getJmsMessageType() != null) { // force a specific type from the endpoint configuration type = endpoint.getConfiguration().getJmsMessageType(); } else { // let body determine the type if (body instanceof Node || body instanceof String) { type = Text; } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer || body instanceof StreamCache) { type = Bytes; } else if (body instanceof Map) { type = Map; } else if (body instanceof Serializable) { type = Object; } } // create the JmsMessage based on the type if (type != null) { if (LOG.isTraceEnabled()) { LOG.trace("Using JmsMessageType: " + type); } switch(type) { case Text: { TextMessage message = session.createTextMessage(); String payload = context.getTypeConverter().convertTo(String.class, exchange, body); message.setText(payload); return message; } case Bytes: { BytesMessage message = session.createBytesMessage(); byte[] payload = context.getTypeConverter().convertTo(byte[].class, exchange, body); message.writeBytes(payload); return message; } case Map: { MapMessage message = session.createMapMessage(); Map payload = context.getTypeConverter().convertTo(Map.class, exchange, body); populateMapMessage(message, payload, context); return message; } case Object: Serializable payload; try { payload = context.getTypeConverter().mandatoryConvertTo(Serializable.class, exchange, body); } catch (NoTypeConversionAvailableException e) { // cannot convert to serializable then thrown an exception to avoid sending a null message JMSException cause = new MessageFormatException(e.getMessage()); cause.initCause(e); throw cause; } return session.createObjectMessage(payload); default: break; } } // warn if the body could not be mapped if (body != null &amp;&amp; LOG.isWarnEnabled()) { LOG.warn("Cannot determine specific JmsMessage type to use from body class." + " Will use generic JmsMessage." + " Body class: " + ObjectHelper.classCanonicalName(body) + ". If you want to send a POJO then your class might need to implement java.io.Serializable" + ", or you can force a specific type by setting the jmsMessageType option on the JMS endpoint."); } // return a default message return session.createMessage(); </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1159</td> 
     <td>-1422651457</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>016918b2e276f95a7e8868dc6cd00fc3ca6fb71c</td> 
     <td>TODO: should we throw an exception instead?</td> 
     <td>TODO: should we throw an exception instead?</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createJmsMessage(Exchange, Object, Map<string, object>
        , Session, CamelContext) 
      </string,></td> 
     <td>protected Message createJmsMessage(Exchange exchange, Object body, Map<string, object>
        headers, Session session, CamelContext context) throws JMSException 
      </string,></td> 
     <td> JmsMessageType type = null; // special for transferExchange if (endpoint != null &amp;&amp; endpoint.isTransferExchange()) { if (LOG.isDebugEnabled()) { LOG.debug("Option transferExchange=true so we use JmsMessageType: Object"); } Serializable holder = DefaultExchangeHolder.marshal(exchange); return session.createObjectMessage(holder); } // check if header have a type set, if so we force to use it if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) { type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE)); } else if (endpoint != null &amp;&amp; endpoint.getConfiguration().getJmsMessageType() != null) { // force a specific type from the endpoint configuration type = endpoint.getConfiguration().getJmsMessageType(); } else { // let body deterime the type if (body instanceof Node || body instanceof String) { type = Text; } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer) { type = Bytes; } else if (body instanceof Map) { type = Map; } else if (body instanceof Serializable) { type = Object; } } // create the JmsMessage based on the type if (type != null) { if (LOG.isDebugEnabled()) { LOG.debug("Using JmsMessageType: " + type); } switch(type) { case Text: { TextMessage message = session.createTextMessage(); String payload = context.getTypeConverter().convertTo(String.class, body); message.setText(payload); return message; } case Bytes: { BytesMessage message = session.createBytesMessage(); byte[] payload = context.getTypeConverter().convertTo(byte[].class, body); message.writeBytes(payload); return message; } case Map: { MapMessage message = session.createMapMessage(); Map payload = context.getTypeConverter().convertTo(Map.class, body); populateMapMessage(message, payload, context); return message; } case Object: return session.createObjectMessage((Serializable) body); case Strem: // TODO: Stream is not supported break; default: break; } } // TODO: should we throw an exception instead? if (LOG.isDebugEnabled()) { LOG.debug("Could not determine specific JmsMessage type to use from body." + " Will use generic JmsMessage. Body class: " + body.getClass().getCanonicalName()); } // return a default message return session.createMessage(); </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1148</td> 
     <td>-1422651457</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>3ca5c0259dab33a903bc08ac678359d2cd108a21</td> 
     <td>None</td> 
     <td>TODO: should we throw an exception instead?</td> 
     <td>SATD_ADDED</td> 
     <td>createJmsMessage(Object, Map<string, object>
       , Session, CamelContext)
      </string,></td> 
     <td>protected Message createJmsMessage(Object body, Map<string, object>
        headers, Session session, CamelContext context) throws JMSException
      </string,></td> 
     <td> JmsMessageType type = null; // check if header have a type set, if so we force to use it if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) { type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE)); } else if (endpoint != null &amp;&amp; endpoint.getConfiguration().getJmsMessageType() != null) { // force a specific type from the endpoint configuration type = endpoint.getConfiguration().getJmsMessageType(); } else { // let body deterime the type if (body instanceof Node || body instanceof String) { type = Text; } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer) { type = Bytes; } else if (body instanceof Map) { type = Map; } else if (body instanceof Serializable) { type = Object; } } // create the JmsMessage based on the type if (type != null) { if (LOG.isDebugEnabled()) { LOG.debug("Using JmsMessageType: " + type); } switch(type) { case Text: { TextMessage message = session.createTextMessage(); String payload = context.getTypeConverter().convertTo(String.class, body); message.setText(payload); return message; } case Bytes: { BytesMessage message = session.createBytesMessage(); byte[] payload = context.getTypeConverter().convertTo(byte[].class, body); message.writeBytes(payload); return message; } case Map: { MapMessage message = session.createMapMessage(); Map payload = context.getTypeConverter().convertTo(Map.class, body); populateMapMessage(message, payload, context); return message; } case Object: return session.createObjectMessage((Serializable) body); case Strem: // TODO: Stream is not supported break; default: break; } } // TODO: should we throw an exception instead? if (LOG.isDebugEnabled()) { LOG.debug("Could not determine specific JmsMessage type to use from body." + " Will use generic JmsMessage. Body class: " + body.getClass().getCanonicalName()); } // return a default message return session.createMessage(); </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>