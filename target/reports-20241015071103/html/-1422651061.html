<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1908</td> 
     <td>-1422651061</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>943fe8d7952baafa825d4359d5dd1dbdd59f0ec7</td> 
     <td>TODO: async process redelivery (eg duplicate the error handler logic) And have a timer task scheduled when redelivery should occur to avoid blocking thread</td> 
     <td>only process if the exchange hasn't failed and it has not been handled by the error processor</td> 
     <td>SATD_REMOVED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // can we still run if (!isRunAllowed()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // no we should not redeliver to the same output so either try an onException (if any given) // or the dead letter queue Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; // deliver to the failure processor (either an on exception or dead letter queue boolean sync = deliverToFailureProcessor(target, exchange, data, callback); // we are breaking out return sync; } if (shouldRedeliver &amp;&amp; data.redeliveryCounter &gt; 0) { // prepare for redelivery prepareExchangeForRedelivery(exchange); // if we are redelivering then sleep before trying again // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { if (log.isDebugEnabled()) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); } // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange (also redelivery) boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (isDone(exchange)) { callback.done(sync); return; } // error occurred so loop back around which we do by invoking the processAsyncErrorHandler processAsyncErrorHandler(exchange, callback, data); } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } // we route synchronously boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1891</td> 
     <td>-1422651061</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>a24f83b12e90ce52f41c256dea6e4b9b7528ee2a</td> 
     <td>let Camel error handle take care of all kind of exceptions now</td> 
     <td>TODO: async process redelivery (eg duplicate the error handler logic) And have a timer task scheduled when redelivery should occur to avoid blocking thread</td> 
     <td>SATD_CHANGED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // no we should not redeliver to the same output so either try an onException (if any given) // or the dead letter queue Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; // deliver to the failure processor (either an on exception or dead letter queue deliverToFailureProcessor(target, exchange, data); // prepare the exchange for failure before returning prepareExchangeAfterFailure(exchange, data); // fire event if we had a failure processor to handle it if (target != null) { boolean deadLetterChannel = target == data.deadLetterProcessor &amp;&amp; data.deadLetterProcessor != null; EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, target, deadLetterChannel); } boolean shouldContinue = shouldContinue(exchange, data); if (shouldContinue) { // okay we want to continue then prepare the exchange for that as well prepareExchangeForContinue(exchange, data); } // and then return return data.sync; } if (shouldRedeliver &amp;&amp; data.redeliveryCounter &gt; 0) { // prepare for redelivery prepareExchangeForRedelivery(exchange); // if we are redelivering then sleep before trying again // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { if (log.isDebugEnabled()) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); } // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange (also redelivery) boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (!isDone(exchange)) { // TODO: async process redelivery (eg duplicate the error handler logic) // And have a timer task scheduled when redelivery should occur to avoid blocking thread } else { callback.done(sync); } } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>