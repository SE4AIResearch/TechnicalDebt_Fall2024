<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2178</td> 
     <td>-1422651091</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>c290dfc21e97b04173186a1ea362a83303a390bb</td> 
     <td>create the output processor TODO: This should be mandatory (but ExceptionHandlerStreamCacheTest fails)</td> 
     <td>create the output processor</td> 
     <td>SATD_REMOVED</td> 
     <td>createProcessor(RouteContext)</td> 
     <td>public Processor createProcessor(final RouteContext routeContext) throws Exception</td> 
     <td> // create the output processor output = this.createChildProcessor(routeContext, true); // add the output as a intercept strategy to the route context so its invoked on each processing step routeContext.getInterceptStrategies().add(new InterceptStrategy() { private Processor interceptedTarget; public Processor wrapProcessorInInterceptors(CamelContext context, ProcessorDefinition definition, Processor target, Processor nextTarget) throws Exception { // prefer next target over target as next target is the real target interceptedTarget = nextTarget != null ? nextTarget : target; // remember the target that was intercepted intercepted.add(interceptedTarget); if (interceptedTarget != null) { // wrap in a pipeline so we continue routing to the next List<processor>
        list = new ArrayList
       <processor>
        (2); list.add(output); list.add(interceptedTarget); return new Pipeline(context, list); } else { return output; } } @Override public String toString() { return "intercept[" + (interceptedTarget != null ? interceptedTarget : output) + "]"; } }); // remove me from the route so I am not invoked in a regular route path routeContext.getRoute().getOutputs().remove(this); // and return no processor to invoke next from me return null; 
       </processor>
      </processor></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1822</td> 
     <td>-1422651091</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>7007ffc09359f88a9f3eddc017cd1d38047d0a4b</td> 
     <td>None</td> 
     <td>create the output processor TODO: This should be mandatory (but ExceptionHandlerStreamCacheTest fails)</td> 
     <td>SATD_ADDED</td> 
     <td>createProcessor(RouteContext)</td> 
     <td>public Processor createProcessor(final RouteContext routeContext) throws Exception</td> 
     <td> // create the output processor // TODO: This should be mandatory (but ExceptionHandlerStreamCacheTest fails) output = this.createChildProcessor(routeContext, false); // add the output as a intercept strategy to the route context so its invoked on each processing step routeContext.getInterceptStrategies().add(new InterceptStrategy() { private Processor interceptedTarget; public Processor wrapProcessorInInterceptors(CamelContext context, ProcessorDefinition definition, Processor target, Processor nextTarget) throws Exception { // prefer next target over target as next target is the real target interceptedTarget = nextTarget != null ? nextTarget : target; // remember the target that was intercepted intercepted.add(interceptedTarget); if (interceptedTarget != null) { // wrap in a pipeline so we continue routing to the next List<processor>
        list = new ArrayList
       <processor>
        (2); list.add(output); list.add(interceptedTarget); return new Pipeline(context, list); } else { return output; } } @Override public String toString() { return "intercept[" + (interceptedTarget != null ? interceptedTarget : output) + "]"; } }); // remove me from the route so I am not invoked in a regular route path routeContext.getRoute().getOutputs().remove(this); // and return no processor to invoke next from me return null; 
       </processor>
      </processor></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>