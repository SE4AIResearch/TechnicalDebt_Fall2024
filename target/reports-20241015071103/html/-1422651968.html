<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>359</td> 
     <td>-1422651968</td> 
     <td>apache/camel</td> 
     <td>James Strachan</td> 
     <td>8b5b03c52cc74c09534a67aa8f9cd3dba7ec9e5a</td> 
     <td>TODO is InputStream the best type to give to CXF?</td> 
     <td>CXF uses the stax which is based on the stream API to parser the XML, so the CXF transport is also based on the stream API. And the interceptors are also based on the stream API, so lets use an InputStream to host the CXF on wire message.</td> 
     <td>SATD_REMOVED</td> 
     <td>createCxfMessage(CxfExchange)</td> 
     <td>public MessageImpl createCxfMessage(CxfExchange exchange)</td> 
     <td> MessageImpl answer = (MessageImpl) exchange.getInMessage(); // CXF uses the stax which is based on the stream API to parser the XML, so // the CXF transport is also based on the stream API. // And the interceptors are also based on the stream API, // so lets use an InputStream to host the CXF on wire message. CxfMessage in = exchange.getIn(); Object body = in.getBody(InputStream.class); if (body == null) { body = in.getBody(); } answer.setContent(InputStream.class, body); // no need to process headers as we reuse the CXF message /* // set the headers Set<map.entry> 
       <string, object>
         &gt; entries = in.getHeaders().entrySet(); for (Map.Entry 
        <string, object>
          entry : entries) { answer.put(entry.getKey(), entry.getValue()); } */ return answer; 
        </string,> 
       </string,> 
      </map.entry></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>220</td> 
     <td>-1422651968</td> 
     <td>apache/camel</td> 
     <td>James Strachan</td> 
     <td>645d9a7a1027ea4efecdaff4ad127333666baab4</td> 
     <td>TODO is InputStream the best type to give to CXF?</td> 
     <td>TODO is InputStream the best type to give to CXF?</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>createCxfMessage(CxfExchange)</td> 
     <td>public MessageImpl createCxfMessage(CxfExchange exchange)</td> 
     <td> MessageImpl answer = (MessageImpl) exchange.getInMessage(); // TODO is InputStream the best type to give to CXF? CxfMessage in = exchange.getIn(); Object body = in.getBody(InputStream.class); if (body == null) { body = in.getBody(); } answer.setContent(InputStream.class, body); // no need to process headers as we reuse the CXF message /* // set the headers Set<map.entry> 
       <string, object>
         &gt; entries = in.getHeaders().entrySet(); for (Map.Entry 
        <string, object>
          entry : entries) { answer.put(entry.getKey(), entry.getValue()); } */ return answer; 
        </string,> 
       </string,> 
      </map.entry></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>105</td> 
     <td>-1422651968</td>
     <td>apache/camel</td>
     <td>James Strachan</td>
     <td>bc42ef45d64d6f49d35c2b958248d5958400d0d5</td> 
     <td>None</td> 
     <td>TODO is InputStream the best type to give to CXF?</td> 
     <td>SATD_ADDED</td> 
     <td>createCxfMessage(CxfExchange)</td> 
     <td>public MessageImpl createCxfMessage(CxfExchange exchange)</td> 
     <td> MessageImpl answer = new MessageImpl(); // TODO is InputStream the best type to give to CXF? CxfMessage in = exchange.getIn(); Object body = in.getBody(InputStream.class); if (body == null) { body = in.getBody(); } answer.setContent(InputStream.class, body); // set the headers Set<map.entry>
       <string, object>
        &gt; entries = in.getHeaders().entrySet(); for (Map.Entry
        <string, object>
          entry : entries) { answer.put(entry.getKey(), entry.getValue()); } return answer; 
        </string,>
       </string,>
      </map.entry></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>