<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1252</td> 
     <td>-1422651453</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>92d3cf91f9c35d41da4adaf19f562f12f37b9275</td> 
     <td>TODO: align this code with DefaultLifecycleStrategy</td> 
     <td>add intercept strategy that executes the JMX instrumentation for performance metrics</td> 
     <td>SATD_REMOVED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap 
       <processordefinition, performancecounter>
         (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); // register all processors for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // add intercept strategy that executes the JMX instrumentation for performance metrics routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); // Add an InstrumentationProcessor at the beginning of each route and // set up the interceptorMap for onRoutesAdd() method to register the // ManagedRoute MBeans. // TODO: Disabled for now until we find a better strategy for registering routes in the JMX // without altering the route model. The route model should be much the same as without JMX to avoid // a gap that causes pain to get working with and without JMX enabled. We have seen to many issues with this already. /* RouteDefinition routeType = routeContext.getRoute(); if (routeType.getInputs() != null &amp;&amp; !routeType.getInputs().isEmpty()) { if (routeType.getInputs().size() &gt; 1) { LOG.warn("Addding InstrumentationProcessor to first input only."); } Endpoint endpoint = routeType.getInputs().get(0).getEndpoint(); List 
        <processordefinition>
          exceptionHandlers = new ArrayList 
         <processordefinition>
           (); List 
          <processordefinition>
            outputs = new ArrayList 
           <processordefinition>
             (); // separate out the exception handers in the outputs for (ProcessorDefinition output : routeType.getOutputs()) { if (output instanceof OnExceptionDefinition) { exceptionHandlers.add(output); } else { outputs.add(output); } } // clearing the outputs routeType.clearOutput(); // add exception handlers as top children routeType.getOutputs().addAll(exceptionHandlers); // add an interceptor to instrument the route InstrumentationProcessor processor = new InstrumentationProcessor(); routeType.intercept(processor); // add the output for (ProcessorDefinition processorType : outputs) { routeType.addOutput(processorType); } interceptorMap.put(endpoint, processor); }*/ 
           </processordefinition> 
          </processordefinition> 
         </processordefinition> 
        </processordefinition> 
       </processordefinition,> 
      </processordefinition,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1220</td> 
     <td>-1422651453</td> 
     <td>apache/camel</td> 
     <td>Gert Vanthienen</td> 
     <td>f7e48098072a5659554d7d492841a7ca5a464b0c</td> 
     <td>TODO: align this code with InstrumentationLifecycleStrategy</td> 
     <td>TODO: align this code with DefaultLifecycleStrategy</td> 
     <td>SATD_CHANGED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap 
       <processordefinition, performancecounter>
         (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // TODO: align this code with DefaultLifecycleStrategy routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); routeContext.setErrorHandlerWrappingStrategy(new DefaultErrorHandlerWrappingStrategy(routeContext)); // Add an InstrumentationProcessor at the beginning of each route and // set up the interceptorMap for onRoutesAdd() method to register the // ManagedRoute MBeans. // TODO: Rework the code below it changes the model and it affects the gap with and without JMX! // we have enough pain with JAXB vs Java DSL already so we should not also have gaps with JMX! RouteDefinition routeType = routeContext.getRoute(); if (routeType.getInputs() != null &amp;&amp; !routeType.getInputs().isEmpty()) { if (routeType.getInputs().size() &gt; 1) { LOG.warn("Addding InstrumentationProcessor to first input only."); } Endpoint endpoint = routeType.getInputs().get(0).getEndpoint(); List 
        <processordefinition>
          exceptionHandlers = new ArrayList 
         <processordefinition>
           (); List 
          <processordefinition>
            outputs = new ArrayList 
           <processordefinition>
             (); // separate out the exception handers in the outputs for (ProcessorDefinition output : routeType.getOutputs()) { if (output instanceof OnExceptionDefinition) { exceptionHandlers.add(output); } else { outputs.add(output); } } // clearing the outputs routeType.clearOutput(); // add exception handlers as top children routeType.getOutputs().addAll(exceptionHandlers); // add an interceptor to instrument the route InstrumentationProcessor processor = new InstrumentationProcessor(); routeType.intercept(processor); // add the output for (ProcessorDefinition processorType : outputs) { routeType.addOutput(processorType); } interceptorMap.put(endpoint, processor); } 
           </processordefinition> 
          </processordefinition> 
         </processordefinition> 
        </processordefinition> 
       </processordefinition,> 
      </processordefinition,></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1154</td> 
     <td>-1422651453</td>
     <td>apache/camel</td>
     <td>Jonathan Anstey</td>
     <td>71e646abf0cb9161004ca84e547d853d9cdb6a65</td> 
     <td>None</td> 
     <td>TODO: align this code with InstrumentationLifecycleStrategy</td> 
     <td>SATD_ADDED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        counterMap = new HashMap
       <processordefinition, performancecounter>
        (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered counterMap.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // TODO: align this code with InstrumentationLifecycleStrategy routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(counterMap)); routeContext.setErrorHandlerWrappingStrategy(new InstrumentationErrorHandlerWrappingStrategy(routeContext, counterMap)); // Add an InstrumentationProcessor at the beginning of each route and // set up the interceptorMap for onRoutesAdd() method to register the // ManagedRoute MBeans. RouteDefinition routeType = routeContext.getRoute(); if (routeType.getInputs() != null &amp;&amp; !routeType.getInputs().isEmpty()) { if (routeType.getInputs().size() &gt; 1) { LOG.warn("Addding InstrumentationProcessor to first input only."); } Endpoint endpoint = routeType.getInputs().get(0).getEndpoint(); List
        <processordefinition>
          exceptionHandlers = new ArrayList
         <processordefinition>
          (); List
          <processordefinition>
            outputs = new ArrayList
           <processordefinition>
            (); // separate out the exception handers in the outputs for (ProcessorDefinition output : routeType.getOutputs()) { if (output instanceof OnExceptionDefinition) { exceptionHandlers.add(output); } else { outputs.add(output); } } // clearing the outputs routeType.clearOutput(); // add exception handlers as top children routeType.getOutputs().addAll(exceptionHandlers); // add an interceptor InstrumentationProcessor processor = new InstrumentationProcessor(); routeType.intercept(processor); // add the output for (ProcessorDefinition processorType : outputs) { routeType.addOutput(processorType); } interceptorMap.put(endpoint, processor); } 
           </processordefinition>
          </processordefinition>
         </processordefinition>
        </processordefinition>
       </processordefinition,>
      </processordefinition,></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>