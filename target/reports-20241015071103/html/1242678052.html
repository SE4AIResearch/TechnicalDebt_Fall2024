<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4756</td> 
     <td>1242678052</td>
     <td>GerritCodeReview/gerrit</td>
     <td>David Pursehouse</td>
     <td>7273df290a812f28c28e2fbd3dcaccb1e34b4d76</td> 
     <td>None</td> 
     <td>TODO(dborowitz): Use try/finally when this doesn't double-close the repo.</td> 
     <td>SATD_ADDED</td> 
     <td>testAvoidingCircularReference()</td> 
     <td>public void testAvoidingCircularReference() throws Exception</td> 
     <td> expect(schemaFactory.open()).andReturn(schema); try (Repository sourceRepository = createWorkRepository(); Repository targetRepository = createWorkRepository()) { // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git sourceGit = new Git(sourceRepository); // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git targetGit = new Git(targetRepository); addRegularFileToIndex("file.txt", "test content", sourceRepository); final RevCommit sourceMergeTip = sourceGit.commit().setMessage("test").call(); final Branch.NameKey sourceBranchNameKey = new Branch.NameKey(new Project.NameKey("source-project"), "refs/heads/master"); final CodeReviewCommit codeReviewCommit = new CodeReviewCommit(sourceMergeTip.toObjectId()); final Change submittedChange = new Change(new Change.Key(sourceMergeTip.toObjectId().getName()), new Change.Id(1), new Account.Id(1), sourceBranchNameKey, TimeUtil.nowTs()); final Map<change.id, codereviewcommit>
        mergedCommits = new HashMap&lt;&gt;(); mergedCommits.put(submittedChange.getId(), codeReviewCommit); final List
       <change>
         submitted = new ArrayList&lt;&gt;(); submitted.add(submittedChange); addGitLinkToIndex("a", sourceMergeTip.copy(), targetRepository); targetGit.commit().setMessage("test").call(); final Branch.NameKey targetBranchNameKey = new Branch.NameKey(new Project.NameKey("target-project"), sourceBranchNameKey.get()); expect(urlProvider.get()).andReturn("http://localhost:8080"); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final ResultSet
        <submodulesubscription>
          subscribers = new ListResultSet&lt;&gt;(Collections.singletonList(new SubmoduleSubscription(targetBranchNameKey, sourceBranchNameKey, "source-project"))); expect(subscriptions.bySubmodule(sourceBranchNameKey)).andReturn(subscribers); expect(repoManager.openRepository(targetBranchNameKey.getParentKey())).andReturn(targetRepository).anyTimes(); Capture
         <refupdate>
           ruCapture = new Capture&lt;&gt;(); gitRefUpdated.fire(eq(targetBranchNameKey.getParentKey()), capture(ruCapture)); changeHooks.doRefUpdatedHook(eq(targetBranchNameKey), anyObject(RefUpdate.class), EasyMock.
          <account>
           isNull()); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final ResultSet
           <submodulesubscription>
             incorrectSubscriptions = new ListResultSet&lt;&gt;(Collections.singletonList(new SubmoduleSubscription(sourceBranchNameKey, targetBranchNameKey, "target-project"))); expect(subscriptions.bySubmodule(targetBranchNameKey)).andReturn(incorrectSubscriptions); schema.close(); final PersonIdent myIdent = new PersonIdent("test-user", "test-user@email.com"); doReplay(); final SubmoduleOp submoduleOp = new SubmoduleOp(sourceBranchNameKey, sourceMergeTip, new RevWalk(sourceRepository), urlProvider, schemaFactory, sourceRepository, new Project(sourceBranchNameKey.getParentKey()), submitted, mergedCommits, myIdent, repoManager, gitRefUpdated, null, changeHooks); submoduleOp.update(); doVerify(); RefUpdate ru = ruCapture.getValue(); assertEquals(ru.getName(), targetBranchNameKey.get()); } 
           </submodulesubscription>
          </account>
         </refupdate>
        </submodulesubscription>
       </change>
      </change.id,></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4743</td> 
     <td>1242678052</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>16f552165aac8497576a5fded23d7027e951c547</td> 
     <td>None</td> 
     <td>TODO(dborowitz): Use try/finally when this doesn't double-close the repo.</td> 
     <td>SATD_ADDED</td> 
     <td>testAvoidingCircularReference()</td> 
     <td>public void testAvoidingCircularReference() throws Exception</td> 
     <td> expect(schemaFactory.open()).andReturn(schema); try (Repository sourceRepository = createWorkRepository(); Repository targetRepository = createWorkRepository()) { // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git sourceGit = new Git(sourceRepository); // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git targetGit = new Git(targetRepository); addRegularFileToIndex("file.txt", "test content", sourceRepository); final RevCommit sourceMergeTip = sourceGit.commit().setMessage("test").call(); final Branch.NameKey sourceBranchNameKey = new Branch.NameKey(new Project.NameKey("source-project"), "refs/heads/master"); final CodeReviewCommit codeReviewCommit = new CodeReviewCommit(sourceMergeTip.toObjectId()); final Change submittedChange = new Change(new Change.Key(sourceMergeTip.toObjectId().getName()), new Change.Id(1), new Account.Id(1), sourceBranchNameKey, TimeUtil.nowTs()); final Map<change.id, codereviewcommit>
        mergedCommits = new HashMap&lt;&gt;(); mergedCommits.put(submittedChange.getId(), codeReviewCommit); final List
       <change>
         submitted = new ArrayList&lt;&gt;(); submitted.add(submittedChange); addGitLinkToIndex("a", sourceMergeTip.copy(), targetRepository); targetGit.commit().setMessage("test").call(); final Branch.NameKey targetBranchNameKey = new Branch.NameKey(new Project.NameKey("target-project"), sourceBranchNameKey.get()); expect(urlProvider.get()).andReturn("http://localhost:8080"); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final ResultSet
        <submodulesubscription>
          subscribers = new ListResultSet&lt;&gt;(Collections.singletonList(new SubmoduleSubscription(targetBranchNameKey, sourceBranchNameKey, "source-project"))); expect(subscriptions.bySubmodule(sourceBranchNameKey)).andReturn(subscribers); expect(repoManager.openRepository(targetBranchNameKey.getParentKey())).andReturn(targetRepository).anyTimes(); Capture
         <refupdate>
           ruCapture = new Capture&lt;&gt;(); gitRefUpdated.fire(eq(targetBranchNameKey.getParentKey()), capture(ruCapture)); changeHooks.doRefUpdatedHook(eq(targetBranchNameKey), anyObject(RefUpdate.class), EasyMock.
          <account>
           isNull()); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final ResultSet
           <submodulesubscription>
             incorrectSubscriptions = new ListResultSet&lt;&gt;(Collections.singletonList(new SubmoduleSubscription(sourceBranchNameKey, targetBranchNameKey, "target-project"))); expect(subscriptions.bySubmodule(targetBranchNameKey)).andReturn(incorrectSubscriptions); schema.close(); final PersonIdent myIdent = new PersonIdent("test-user", "test-user@email.com"); doReplay(); final SubmoduleOp submoduleOp = new SubmoduleOp(sourceBranchNameKey, sourceMergeTip, new RevWalk(sourceRepository), urlProvider, schemaFactory, sourceRepository, new Project(sourceBranchNameKey.getParentKey()), submitted, mergedCommits, myIdent, repoManager, gitRefUpdated, null, changeHooks); submoduleOp.update(); doVerify(); RefUpdate ru = ruCapture.getValue(); assertEquals(ru.getName(), targetBranchNameKey.get()); } 
           </submodulesubscription>
          </account>
         </refupdate>
        </submodulesubscription>
       </change>
      </change.id,></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>