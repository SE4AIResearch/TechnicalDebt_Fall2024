<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1713</td> <td>-1422651150</td><td>apache/camel</td><td>Claus Ibsen</td><td>8185db6c27db119d6115ab4cd31c5a3b68981b5b</td> <td>None</td> <td>toAsync should fix up itself at first</td> <td>SATD_ADDED</td> <td>afterPropertiesSet()</td> <td>public void afterPropertiesSet() throws Exception</td> <td>
    if (properties != null) {
        getContext().setProperties(properties.asMap());
    }
    // setup JMX agent at first
    initJMXAgent();
    // set the resolvers first
    PackageScanClassResolver packageResolver = getBeanForType(PackageScanClassResolver.class);
    if (packageResolver != null) {
        LOG.info("Using custom PackageScanClassResolver: " + packageResolver);
        getContext().setPackageScanClassResolver(packageResolver);
    }
    ClassResolver classResolver = getBeanForType(ClassResolver.class);
    if (classResolver != null) {
        LOG.info("Using custom ClassResolver: " + classResolver);
        getContext().setClassResolver(classResolver);
    }
    FactoryFinderResolver factoryFinderResolver = getBeanForType(FactoryFinderResolver.class);
    if (factoryFinderResolver != null) {
        LOG.info("Using custom FactoryFinderResolver: " + factoryFinderResolver);
        getContext().setFactoryFinderResolver(factoryFinderResolver);
    }
    // set the strategy if defined
    Registry registry = getBeanForType(Registry.class);
    if (registry != null) {
        LOG.info("Using custom Registry: " + registry);
        getContext().setRegistry(registry);
    }
    Tracer tracer = getBeanForType(Tracer.class);
    if (tracer != null) {
        // use formatter if there is a TraceFormatter bean defined
        TraceFormatter formatter = getBeanForType(TraceFormatter.class);
        if (formatter != null) {
            tracer.setFormatter(formatter);
        }
        LOG.info("Using custom Tracer: " + tracer);
        getContext().addInterceptStrategy(tracer);
    }
    HandleFault handleFault = getBeanForType(HandleFault.class);
    if (handleFault != null) {
        LOG.info("Using custom HandleFault: " + handleFault);
        getContext().addInterceptStrategy(handleFault);
    }
    Delayer delayer = getBeanForType(Delayer.class);
    if (delayer != null) {
        LOG.info("Using custom Delayer: " + delayer);
        getContext().addInterceptStrategy(delayer);
    }
    InflightRepository inflightRepository = getBeanForType(InflightRepository.class);
    if (delayer != null) {
        LOG.info("Using custom InflightRepository: " + inflightRepository);
        getContext().setInflightRepository(inflightRepository);
    }
    ManagementStrategy managementStrategy = getBeanForType(ManagementStrategy.class);
    if (managementStrategy != null) {
        LOG.info("Using custom ManagementStrategy: " + managementStrategy);
        getContext().setManagementStrategy(managementStrategy);
    }
    EventFactory eventFactory = getBeanForType(EventFactory.class);
    if (eventFactory != null) {
        LOG.info("Using custom EventFactory: " + eventFactory);
        getContext().getManagementStrategy().setEventFactory(eventFactory);
    }
    EventNotifier eventNotifier = getBeanForType(EventNotifier.class);
    if (eventNotifier != null) {
        LOG.info("Using custom EventNotifier: " + eventNotifier);
        getContext().getManagementStrategy().setEventNotifier(eventNotifier);
    }
    ShutdownStrategy shutdownStrategy = getBeanForType(ShutdownStrategy.class);
    if (shutdownStrategy != null) {
        LOG.info("Using custom ShutdownStrategy: " + shutdownStrategy);
        getContext().setShutdownStrategy(shutdownStrategy);
    }
    // add global interceptors
    Map<String, InterceptStrategy> interceptStrategies = getContext().getRegistry().lookupByType(InterceptStrategy.class);
    if (interceptStrategies != null && !interceptStrategies.isEmpty()) {
        for (String id : interceptStrategies.keySet()) {
            InterceptStrategy strategy = interceptStrategies.get(id);
            // do not add if already added, for instance a tracer that is also an InterceptStrategy class
            if (!getContext().getInterceptStrategies().contains(strategy)) {
                LOG.info("Using custom intercept strategy with id: " + id + " and implementation: " + strategy);
                getContext().addInterceptStrategy(strategy);
            }
        }
    }
    // set the lifecycle strategy if defined
    Map<String, LifecycleStrategy> lifecycleStrategies = getContext().getRegistry().lookupByType(LifecycleStrategy.class);
    if (lifecycleStrategies != null && !lifecycleStrategies.isEmpty()) {
        for (String id : lifecycleStrategies.keySet()) {
            LifecycleStrategy strategy = lifecycleStrategies.get(id);
            // do not add if already added, for instance a tracer that is also an InterceptStrategy class
            if (!getContext().getLifecycleStrategies().contains(strategy)) {
                LOG.info("Using custom lifecycle strategy with id: " + id + " and implementation: " + strategy);
                getContext().addLifecycleStrategy(strategy);
            }
        }
    }
    // Set the application context and camelContext for the beanPostProcessor
    if (beanPostProcessor != null) {
        if (beanPostProcessor instanceof ApplicationContextAware) {
            ((ApplicationContextAware) beanPostProcessor).setApplicationContext(applicationContext);
        }
        if (beanPostProcessor instanceof CamelBeanPostProcessor) {
            ((CamelBeanPostProcessor) beanPostProcessor).setCamelContext(getContext());
        }
    }
    // do special preparation for some concepts such as interceptors and policies
    // this is needed as JAXB does not build exactly the same model definition as Spring DSL would do
    // using route builders. So we have here a little custom code to fix the JAXB gaps
    for (RouteDefinition route : routes) {
        // move all abstracts into their own list so we can deal with them separately
        List<ProcessorDefinition> abstracts = new ArrayList<ProcessorDefinition>();
        initAbstracts(route, abstracts);
        // toAsync should fix up itself at first
        initToAsync(route);
        // interceptors should be first for the cross cutting concerns
        initInterceptors(route);
        // then on completion
        initOnCompletions(route, abstracts);
        // then polices
        initPolicies(route, abstracts);
        // then on exception
        initOnExceptions(route, abstracts);
        // configure parents
        initParent(route);
    }
    if (dataFormats != null) {
        getContext().setDataFormats(dataFormats.asMap());
    }
    // lets force any lazy creation
    getContext().addRouteDefinitions(routes);
    if (LOG.isDebugEnabled()) {
        LOG.debug("Found JAXB created routes: " + getRoutes());
    }
    findRouteBuilders();
    installRoutes();
</td> </tr></table></body></html>