<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>1888</td> <td>-1422651064</td><td>apache/camel</td><td>Claus Ibsen</td><td>a24f83b12e90ce52f41c256dea6e4b9b7528ee2a</td> <td>let Camel error handle take care of all kind of exceptions now</td> <td>this callback should only handle the async case</td> <td>SATD_REMOVED</td> <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> <td>
    while (true) {
        // did previous processing cause an exception?
        boolean handle = shouldHandleException(exchange);
        if (handle) {
            handleException(exchange, data);
        }
        // compute if we should redeliver or not
        boolean shouldRedeliver = shouldRedeliver(exchange, data);
        if (!shouldRedeliver) {
            // no we should not redeliver to the same output so either try an onException (if any given)
            // or the dead letter queue
            Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor;
            // deliver to the failure processor (either an on exception or dead letter queue
            deliverToFailureProcessor(target, exchange, data);
            // prepare the exchange for failure before returning
            prepareExchangeAfterFailure(exchange, data);
            // fire event if we had a failure processor to handle it
            if (target != null) {
                boolean deadLetterChannel = target == data.deadLetterProcessor && data.deadLetterProcessor != null;
                EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, target, deadLetterChannel);
            }
            boolean shouldContinue = shouldContinue(exchange, data);
            if (shouldContinue) {
                // okay we want to continue then prepare the exchange for that as well
                prepareExchangeForContinue(exchange, data);
            }
            // and then return
            return data.sync;
        }
        if (shouldRedeliver && data.redeliveryCounter > 0) {
            // prepare for redelivery
            prepareExchangeForRedelivery(exchange);
            // if we are redelivering then sleep before trying again
            // wait until we should redeliver
            try {
                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter);
            } catch (InterruptedException e) {
                if (log.isDebugEnabled()) {
                    log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped()));
                }
                // continue from top
                continue;
            }
            // letting onRedeliver be executed
            deliverToRedeliveryProcessor(exchange, data);
        }
        // process the exchange (also redelivery)
        boolean sync = outputAsync.process(exchange, new AsyncCallback() {

            public void done(boolean sync) {
                // this callback should only handle the async case
                if (sync) {
                    return;
                }
                // mark we are in async mode now
                data.sync = false;
                // only process if the exchange hasn't failed
                // and it has not been handled by the error processor
                if (!isDone(exchange)) {
                // TODO: async process redelivery (eg duplicate the error handler logic)
                // And have a timer task scheduled when redelivery should occur to avoid blocking thread
                } else {
                    callback.done(sync);
                }
            }
        });
        if (!sync) {
            // the remainder of the Exchange is being processed asynchronously so we should return
            return false;
        }
        boolean done = isDone(exchange);
        if (done) {
            callback.done(true);
            return true;
        }
    // error occurred so loop back around.....
    }
</td> </tr></table></body></html>