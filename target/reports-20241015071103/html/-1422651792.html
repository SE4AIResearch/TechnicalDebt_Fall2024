<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>471</td> <td>-1422651792</td><td>apache/camel</td><td>James Strachan</td><td>e824181508bc29fa0e7563dd9155cd71e7a0ca1f</td> <td>None</td> <td>FIXME: This aggregator doesn�t usually fail but could also due to timeout
or an incorrect batch size
Join in a list by the surname on the header and mark as
brothers list</td> <td>SATD_ADDED</td> <td>createRouteBuilder()</td> <td>protected RouteBuilder createRouteBuilder() throws Exception</td> <td>
    return new RouteBuilder() {

        private void debugIn(String stringId, Exchange oldExchange, Exchange newExchange) {
            log.debug(stringId + " old headers in: " + oldExchange.getIn().getHeaders());
            log.debug(stringId + " old body in: " + oldExchange.getIn().getBody());
            log.debug(stringId + " new headers in: " + newExchange.getIn().getHeaders());
            log.debug(stringId + " new body in: " + newExchange.getIn().getBody());
        }

        private void debugOut(String stringId, Exchange exchange) {
            log.debug(stringId + " old headers out: " + exchange.getIn().getHeaders());
            log.debug(stringId + " old body out: " + exchange.getIn().getBody());
        }

        AggregationStrategy surnameAggregator = new AggregationStrategy() {

            public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
                debugIn("Surname Aggregator", oldExchange, newExchange);
                Message oldIn = oldExchange.getIn();
                Message newIn = newExchange.getIn();
                List<String> brothers = null;
                if (oldIn.getBody() instanceof List) {
                    brothers = oldIn.getBody(List.class);
                    brothers.add(newIn.getBody(String.class));
                } else {
                    brothers = new ArrayList<String>();
                    brothers.add(oldIn.getBody(String.class));
                    brothers.add(newIn.getBody(String.class));
                    oldExchange.getIn().setBody(brothers);
                }
                // else
                debugOut("Surname Aggregator", oldExchange);
                return oldExchange;
            }
        };

        AggregationStrategy brothersAggregator = new AggregationStrategy() {

            public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
                debugIn("Brothers Aggregator", oldExchange, newExchange);
                Message oldIn = oldExchange.getIn();
                Message newIn = newExchange.getIn();
                Map<String, List> brothers = null;
                if (oldIn.getBody() instanceof Map) {
                    brothers = oldIn.getBody(Map.class);
                    brothers.put(newIn.getHeader(SURNAME_HEADER, String.class), newIn.getBody(List.class));
                } else {
                    brothers = new HashMap<String, List>();
                    brothers.put(oldIn.getHeader(SURNAME_HEADER, String.class), oldIn.getBody(List.class));
                    brothers.put(newIn.getHeader(SURNAME_HEADER, String.class), newIn.getBody(List.class));
                    oldExchange.getIn().setBody(brothers);
                }
                // else
                debugOut("Brothers Aggregator", oldExchange);
                return oldExchange;
            }
        };

        @Override
        public void configure() throws Exception {
            from("direct:start").splitter(bodyAs(String.class).tokenize(",")).process(// Split the name, erase the surname and put it in a
            // header
            new Processor() {

                public void process(Exchange exchange) throws Exception {
                    String[] parts = exchange.getIn().getBody(String.class).split(" ");
                    exchange.getIn().setBody(parts[0]);
                    exchange.getIn().setHeader(SURNAME_HEADER, parts[1]);
                }
            }).to("direct:joinSurnames");
            // FIXME: This aggregator doesn�t usually fail but could also due to timeout
            // or an incorrect batch size
            // Join in a list by the surname on the header and mark as
            // brothers list
            from("direct:joinSurnames").aggregator(header(SURNAME_HEADER), surnameAggregator).setHeader(TYPE_HEADER, constant(BROTHERS_TYPE)).to("direct:joinBrothers");
            // Join all brothers lists and remove surname and type headers
            AggregatorType agg = from("direct:joinBrothers").aggregator(header(TYPE_HEADER), brothersAggregator);
            // FIXME: If these lines get commented the test fails some times with different errors
            // due to a timeout or incorrect batch size that must be adjusted by hand
            // There are two brothers lists to join but we don�t know always the number "a priori"
            /*
                agg.setBatchSize(2);
                agg.setBatchTimeout(10000L);
*/
            agg.setBatchTimeout(5000L);
            agg.removeHeader(SURNAME_HEADER).removeHeader(TYPE_HEADER).to("mock:result");
        }
    };
</td> </tr></table></body></html>