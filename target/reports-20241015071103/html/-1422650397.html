<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>3058</td> 
     <td>-1422650397</td>
     <td>apache/camel</td>
     <td>Dhiraj Bokde</td>
     <td>7dc2bb13a645c2c2a4dbfc9ec0ed0e5b2a63b914</td> 
     <td>prefer exact match to avoid unused args</td> 
     <td>prefer exact match to avoid unused args</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>filterMethods(List<!--? extends ApiMethod-->, MatchType, String...)</td> 
     <td>public static List<apimethod>
        filterMethods(List<!--? extends ApiMethod--> methods, MatchType matchType, String... argNames)
      </apimethod></td> 
     <td> List<string>
        argsList = Arrays.asList(argNames); // list of methods that have all args in the given names final List
       <apimethod>
         result = new ArrayList
        <apimethod>
         (); final List
         <apimethod>
           extraArgs = new ArrayList
          <apimethod>
           (); for (ApiMethod method : methods) { final List
           <string>
             methodArgs = method.getArgNames(); switch(matchType) { case EXACT: // method must take all args, and no more if (methodArgs.containsAll(argsList) &amp;&amp; argsList.containsAll(methodArgs)) { result.add(method); } break; case SUBSET: // all args are required, method may take more if (methodArgs.containsAll(argsList)) { result.add(method); } break; default: case SUPER_SET: // all method args must be present if (argsList.containsAll(methodArgs)) { if (methodArgs.containsAll(argsList)) { // prefer exact match to avoid unused args result.add(method); } else { // method takes a subset, unused args extraArgs.add(method); } } break; } } return Collections.unmodifiableList(result.isEmpty() ? extraArgs : result); 
           </string>
          </apimethod>
         </apimethod>
        </apimethod>
       </apimethod>
      </string></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>3047</td> 
     <td>-1422650397</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>10a0b6156a1a2a7ad8d349d3e561b713b5e51377</td> 
     <td>None</td> 
     <td>prefer exact match to avoid unused args</td> 
     <td>SATD_ADDED</td> 
     <td>filterMethods(List<t>
       , MatchType, String...)
      </t></td> 
     <td>public List<t>
        filterMethods(List
       <t>
         methods, MatchType matchType, String... argNames)
       </t>
      </t></td> 
     <td> List<string>
        argsList = Arrays.asList(argNames); // list of methods that have all args in the given names final List
       <t>
         result = new ArrayList
        <t>
         (); final List
         <t>
           extraArgs = new ArrayList
          <t>
           (); for (T method : methods) { final List
           <string>
             methodArgs = method.getArgNames(); switch(matchType) { case EXACT: // method must take all args, and no more if (methodArgs.containsAll(argsList) &amp;&amp; argsList.containsAll(methodArgs)) { result.add(method); } break; case SUBSET: // all args are required, method may take more if (methodArgs.containsAll(argsList)) { result.add(method); } break; default: case SUPER_SET: // all method args must be present if (argsList.containsAll(methodArgs)) { if (methodArgs.containsAll(argsList)) { // prefer exact match to avoid unused args result.add(method); } else { // method takes a subset, unused args extraArgs.add(method); } } break; } } return Collections.unmodifiableList(result.isEmpty() ? extraArgs : result); 
           </string>
          </t>
         </t>
        </t>
       </t>
      </string></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>