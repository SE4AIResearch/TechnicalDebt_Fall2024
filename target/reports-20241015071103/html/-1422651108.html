<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1787</td> 
     <td>-1422651108</td>
     <td>apache/camel</td>
     <td>Martin Krasser</td>
     <td>7b3282d6d8ebbb3a499c7c5c015ba3f78f7e715e</td> 
     <td>TODO: support delay and have a DelayQueue to avoid blocking if so we need to pre add in progress so we wont add again to delay queue</td> 
     <td>set redelivery counter</td> 
     <td>SATD_REMOVED</td> 
     <td>run()</td> 
     <td>public void run()</td> 
     <td> // only run if CamelContext has been fully started if (!camelContext.getStatus().isStarted()) { if (LOG.isTraceEnabled()) { LOG.trace("Recover check cannot start due CamelContext(" + camelContext.getName() + ") has not been started yet"); } return; } LOG.trace("Starting recover check"); Set<string>
        exchangeIds = recoverable.scan(camelContext); for (String exchangeId : exchangeIds) { // we may shutdown while doing recovery if (!isRunAllowed()) { LOG.info("We are shutting down so stop recovering"); return; } boolean inProgress = inProgressCompleteExchanges.contains(exchangeId); if (inProgress) { if (LOG.isTraceEnabled()) { LOG.trace("Aggregated exchange with id " + exchangeId + " is already in progress."); } } else { if (LOG.isDebugEnabled()) { LOG.debug("Recovering aggregated exchange with id " + exchangeId); } Exchange exchange = recoverable.recover(camelContext, exchangeId); if (exchange != null) { // get the correlation key String key = exchange.getProperty(Exchange.AGGREGATED_CORRELATION_KEY, String.class); // and mark it as redelivered exchange.getIn().setHeader(Exchange.REDELIVERED, Boolean.TRUE); // update current redelivery state RedeliveryData data = redeliveryState.get(exchange.getExchangeId()); if (data == null) { // create new data data = new RedeliveryData(); redeliveryState.put(exchange.getExchangeId(), data); } data.redeliveryCounter++; // set redelivery counter exchange.getIn().setHeader(Exchange.REDELIVERY_COUNTER, data.redeliveryCounter); // resubmit the recovered exchange onSubmitCompletion(key, exchange); } } } LOG.trace("Recover check complete"); 
      </string></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1786</td> 
     <td>-1422651108</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>7a4c837c3e520fbb6015215a964b88d611009c27</td> 
     <td>None</td> 
     <td>TODO: support delay and have a DelayQueue to avoid blocking if so we need to pre add in progress so we wont add again to delay queue</td> 
     <td>SATD_ADDED</td> 
     <td>run()</td> 
     <td>public void run()</td> 
     <td> // only run if CamelContext has been fully started if (!camelContext.getStatus().isStarted()) { if (LOG.isTraceEnabled()) { LOG.trace("Recover check cannot start due CamelContext(" + camelContext.getName() + ") has not been started yet"); } return; } LOG.trace("Starting recover check"); Set<string>
        exchangeIds = recoverable.scan(camelContext); for (String exchangeId : exchangeIds) { // we may shutdown while doing recovery if (!isRunAllowed()) { LOG.info("We are shutting down so stop recovering"); return; } boolean inProgress = inProgressCompleteExchanges.contains(exchangeId); if (inProgress) { if (LOG.isTraceEnabled()) { LOG.trace("Aggregated exchange with id " + exchangeId + " is already in progress."); } } else { if (LOG.isDebugEnabled()) { LOG.debug("Recovering aggregated exchange with id " + exchangeId); } Exchange exchange = recoverable.recover(camelContext, exchangeId); if (exchange != null) { // get the correlation key String key = exchange.getProperty(Exchange.AGGREGATED_CORRELATION_KEY, String.class); // and mark it as redelivered exchange.getIn().setHeader(Exchange.REDELIVERED, Boolean.TRUE); // update current redelivery state RedeliveryData data = redeliveryState.get(exchange.getExchangeId()); if (data == null) { // create new data data = new RedeliveryData(); redeliveryState.put(exchange.getExchangeId(), data); } data.redeliveryCounter++; // TODO: support delay and have a DelayQueue to avoid blocking // if so we need to pre add in progress so we wont add again to delay queue // set redelivery counter exchange.getIn().setHeader(Exchange.REDELIVERY_COUNTER, data.redeliveryCounter); // resubmit the recovered exchange onSubmitCompletion(key, exchange); } } } LOG.trace("Recover check complete"); 
      </string></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>