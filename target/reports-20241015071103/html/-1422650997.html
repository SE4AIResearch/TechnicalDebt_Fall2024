<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2013</td> 
     <td>-1422650997</td>
     <td>apache/camel</td>
     <td>Christian Mueller</td>
     <td>ddecd192c0790cbfc23506f97147d8c878b33f1f</td> 
     <td>its to hard to do parallel async routing so we let the caller thread be synchronously and have it pickup the replies and do the aggregation TODO: use a stopwatch to keep track of timeout left</td> 
     <td>its to hard to do parallel async routing so we let the caller thread be synchronously and have it pickup the replies and do the aggregation</td> 
     <td>SATD_REMOVED</td> 
     <td>doProcessParallel(Exchange, AtomicExchange, Iterable<processorexchangepair>
       , boolean, AsyncCallback)
      </processorexchangepair></td> 
     <td>protected void doProcessParallel(final Exchange original, final AtomicExchange result, final Iterable<processorexchangepair>
        pairs, final boolean streaming, final AsyncCallback callback) throws InterruptedException, ExecutionException
      </processorexchangepair></td> 
     <td> final CompletionService<exchange>
        completion; final AtomicBoolean running = new AtomicBoolean(true); if (streaming) { // execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence) completion = new ExecutorCompletionService
       <exchange>
        (executorService); } else { // execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence) completion = new SubmitOrderedCompletionService
        <exchange>
         (executorService); } final AtomicInteger total = new AtomicInteger(0); final List
         <future>
          <exchange>
           &gt; tasks = new ArrayList
           <future>
            <exchange>
             &gt;(); final Iterator
             <processorexchangepair>
               it = pairs.iterator(); while (it.hasNext()) { final ProcessorExchangePair pair = it.next(); final Exchange subExchange = pair.getExchange(); updateNewExchange(subExchange, total.intValue(), pairs, it); Future
              <exchange>
                task = completion.submit(new Callable
               <exchange>
                () { public Exchange call() throws Exception { if (!running.get()) { // do not start processing the task if we are not running return subExchange; } try { doProcessParallel(pair); } catch (Exception e) { subExchange.setException(e); } // should we stop in case of an exception occurred during processing? if (stopOnException &amp;&amp; subExchange.getException() != null) { // signal to stop running running.set(false); throw new CamelExchangeException("Parallel processing failed for number " + total.intValue(), subExchange, subExchange.getException()); } if (LOG.isTraceEnabled()) { LOG.trace("Parallel processing complete for exchange: " + subExchange); } return subExchange; } }); tasks.add(task); total.incrementAndGet(); } // its to hard to do parallel async routing so we let the caller thread be synchronously // and have it pickup the replies and do the aggregation boolean timedOut = false; final StopWatch watch = new StopWatch(); for (int i = 0; i &lt; total.intValue(); i++) { Future
                <exchange>
                  future; if (timedOut) { // we are timed out but try to grab if some tasks has been completed // poll will return null if no tasks is present future = completion.poll(); } else if (timeout &gt; 0) { long left = timeout - watch.taken(); if (left &lt; 0) { left = 0; } if (LOG.isTraceEnabled()) { LOG.trace("Polling completion task #" + i + " using timeout " + left + " millis."); } future = completion.poll(left, TimeUnit.MILLISECONDS); } else { // take will wait until the task is complete if (LOG.isTraceEnabled()) { LOG.trace("Polling completion task #" + i); } future = completion.take(); } if (future == null &amp;&amp; timedOut) { // we are timed out and no more tasks complete so break out break; } else if (future == null) { // timeout occurred AggregationStrategy strategy = getAggregationStrategy(null); if (strategy instanceof TimeoutAwareAggregationStrategy) { // notify the strategy we timed out ((TimeoutAwareAggregationStrategy) strategy).timeout(result.get(), i, total.intValue(), timeout); } else { // log a WARN we timed out since it will not be aggregated and the Exchange will be lost LOG.warn("Parallel processing timed out after " + timeout + " millis for number " + i + ". This task will be cancelled and will not be aggregated."); } timedOut = true; } else { // we got a result so aggregate it Exchange subExchange = future.get(); AggregationStrategy strategy = getAggregationStrategy(subExchange); doAggregate(strategy, result, subExchange); } } if (timedOut) { if (LOG.isDebugEnabled()) { LOG.debug("Cancelling future tasks due timeout after " + timeout + " millis."); } // cancel tasks as we timed out (its safe to cancel done tasks) for (Future future : tasks) { future.cancel(true); } } if (LOG.isDebugEnabled()) { LOG.debug("Done parallel processing " + total + " exchanges"); } 
                </exchange>
               </exchange>
              </exchange>
             </processorexchangepair>
            </exchange>
           </future>
          </exchange>
         </future>
        </exchange>
       </exchange>
      </exchange></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>2011</td> 
     <td>-1422650997</td>
     <td>apache/camel</td>
     <td>James Strachan</td>
     <td>bd1c6a8f030965dbd334d573ea97a151dbc96205</td> 
     <td>None</td> 
     <td>its to hard to do parallel async routing so we let the caller thread be synchronously and have it pickup the replies and do the aggregation TODO: use a stopwatch to keep track of timeout left</td> 
     <td>SATD_ADDED</td> 
     <td>doProcessParallel(Exchange, AtomicExchange, Iterable<processorexchangepair>
       , boolean, AsyncCallback)
      </processorexchangepair></td> 
     <td>protected void doProcessParallel(final Exchange original, final AtomicExchange result, final Iterable<processorexchangepair>
        pairs, final boolean streaming, final AsyncCallback callback) throws InterruptedException, ExecutionException
      </processorexchangepair></td> 
     <td> final CompletionService<exchange>
        completion; final AtomicBoolean running = new AtomicBoolean(true); if (streaming) { // execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence) completion = new ExecutorCompletionService
       <exchange>
        (executorService); } else { // execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence) completion = new SubmitOrderedCompletionService
        <exchange>
         (executorService); } final AtomicInteger total = new AtomicInteger(0); final List
         <future>
          <exchange>
           &gt; tasks = new ArrayList
           <future>
            <exchange>
             &gt;(); final Iterator
             <processorexchangepair>
               it = pairs.iterator(); while (it.hasNext()) { final ProcessorExchangePair pair = it.next(); final Exchange subExchange = pair.getExchange(); updateNewExchange(subExchange, total.intValue(), pairs, it); Future
              <exchange>
                task = completion.submit(new Callable
               <exchange>
                () { public Exchange call() throws Exception { if (!running.get()) { // do not start processing the task if we are not running return subExchange; } try { doProcessParallel(pair); } catch (Exception e) { subExchange.setException(e); } // should we stop in case of an exception occurred during processing? if (stopOnException &amp;&amp; subExchange.getException() != null) { // signal to stop running running.set(false); throw new CamelExchangeException("Parallel processing failed for number " + total.intValue(), subExchange, subExchange.getException()); } if (LOG.isTraceEnabled()) { LOG.trace("Parallel processing complete for exchange: " + subExchange); } return subExchange; } }); tasks.add(task); total.incrementAndGet(); } // its to hard to do parallel async routing so we let the caller thread be synchronously // and have it pickup the replies and do the aggregation // TODO: use a stopwatch to keep track of timeout left boolean timedOut = false; for (int i = 0; i &lt; total.intValue(); i++) { Future
                <exchange>
                  future; if (timedOut) { // we are timed out but try to grab if some tasks has been completed // poll will return null if no tasks is present future = completion.poll(); } else if (timeout &gt; 0) { future = completion.poll(timeout, TimeUnit.MILLISECONDS); } else { // take will wait until the task is complete future = completion.take(); } if (future == null &amp;&amp; timedOut) { // we are timed out and no more tasks complete so break out break; } else if (future == null) { // timeout occurred AggregationStrategy strategy = getAggregationStrategy(null); if (strategy instanceof TimeoutAwareAggregationStrategy) { // notify the strategy we timed out ((TimeoutAwareAggregationStrategy) strategy).timeout(result.get(), i, total.intValue(), timeout); } else { LOG.warn("Parallel processing timed out after " + timeout + " millis for number " + i + ". Cannot aggregate"); } timedOut = true; } else { // we got a result so aggregate it Exchange subExchange = future.get(); AggregationStrategy strategy = getAggregationStrategy(subExchange); doAggregate(strategy, result, subExchange); } } if (timedOut) { if (LOG.isDebugEnabled()) { LOG.debug("Cancelling future tasks due timeout after " + timeout + " millis."); } // cancel tasks as we timed out (its safe to cancel done tasks) for (Future future : tasks) { future.cancel(true); } } if (LOG.isDebugEnabled()) { LOG.debug("Done parallel processing " + total + " exchanges"); } 
                </exchange>
               </exchange>
              </exchange>
             </processorexchangepair>
            </exchange>
           </future>
          </exchange>
         </future>
        </exchange>
       </exchange>
      </exchange></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>