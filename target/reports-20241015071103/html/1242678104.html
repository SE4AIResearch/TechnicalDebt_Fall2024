<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4869</td> <td>1242678104</td><td>GerritCodeReview/gerrit</td><td>Saša Živkov</td><td>250bab05a83fd6c6f2ab83329a8ef77f5b50d608</td> <td>None</td> <td>TODO(zivkov): handle the case with multiple merge bases</td> <td>SATD_ADDED</td> <td>predicates(Arguments, String, List<Change>)</td> <td>private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException</td> <td>
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        OperatorPredicate<ChangeData> isMerge = new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_MERGE, value) {

            @Override
            public boolean match(ChangeData cd) throws OrmException {
                ObjectId id = ObjectId.fromString(cd.currentPatchSet().getRevision().get());
                try (Repository repo = args.repoManager.openRepository(cd.change().getProject());
                    RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    RevCommit commit = rw.parseCommit(id);
                    return commit.getParentCount() > 1;
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 2;
            }
        };
        predicatesForOneChange.add(or(or(filePredicates), isMerge));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                    CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                    SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                    CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                    otherCommit.add(canMergeFlag);
                    conflicts = !strategy.dryRun(commit, otherCommit);
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (MergeException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
</td> </tr></table></body></html>