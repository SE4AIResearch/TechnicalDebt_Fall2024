<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th><th>Method Declaration</th><th>Method Body</th></tr><tr><td>331</a></td> <td><a href="html/-1413930362.html">-1413930362</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>3d30346f59a79ced396bbcaf6acb3624a7cb27ad</td> <td>None</td> <td>Prevent concurrent re-entry by this thread
(There might be a cheaper way to do this)
(Or maybe this lock is not necessary)</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    active.set(true);
</td> </tr><tr><td>329</a></td> <td><a href="html/-1413930364.html">-1413930364</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>c4dfd0d7ef22210c16f2ec7197e5909e52b907c4</td> <td>None</td> <td>move the good config file into place</td> <td>SATD_ADDED</td> <td>testPropertyConfigurationError()</td> <td>public void testPropertyConfigurationError() throws Exception</td> <td>
    LogManager.getLoggerRepository().resetConfiguration();
    logger.setLevel(Level.DEBUG);
    File outFile = new File(getOutputFile("test4"));
    if (outFile.exists()) {
        assertTrue(outFile.delete());
    }
    // set up the needed file references
    // need a "bad" property file
    // File sourceFile1 = new File(getSourceConfigFile("test4", 1));
    File sourceFile2 = new File(getSourceConfigFile("test2", 2));
    // assertTrue(sourceFile1.exists());
    assertTrue(sourceFile2.exists());
    // config file should not exist yet
    File configFile = new File(getConfigFile("test4"));
    assertFalse(configFile.exists());
    // now watch the nonexistent file for changes
    FileWatchdog watchdog = new FileWatchdog();
    watchdog.setName("test4");
    watchdog.setFile(configFile.getAbsolutePath());
    watchdog.setInterval(1000);
    watchdog.setConfigurator(PropertyConfigurator.class.getName());
    ((LoggerRepositoryEx) LogManager.getLoggerRepository()).getPluginRegistry().addPlugin(watchdog);
    watchdog.activateOptions();
    testLogger.debug("watchdog activated");
    // the file does not exist, so the modification time should never change
    long modTime = watchdog.getLastModTime();
    for (int count = 0; count < 5; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue("watchdog mod time changed when no file", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("no file, mod time not changed: " + modTime);
    /* need a "bad" property file
    // move the bad config file into place
    copyFile(sourceFile1, configFile);
    assertTrue(configFile.exists());

    testLogger.debug("bad config file put into place");

    // the file is "bad", so the modification time should never change
    for (int count = 0; count < 7; count++) {
      if (modTime != watchdog.getLastModTime()) {
        assertTrue("watchdog mod time changed for bad file", false);
      }
      Thread.sleep(500);
    }

    testLogger.debug("bad file, mod time not changed: " + modTime);
*/
    // move the good config file into place
    copyFile(sourceFile2, configFile);
    assertTrue(configFile.exists());
    testLogger.debug("moved good config file into place");
    // the file is good, so the modification time and level should change
    for (int count = 0; count < 7; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue(logger.getLevel() == Level.INFO);
            break;
        }
        if (count == 6) {
            assertTrue("mod time for good file never changed", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("good file, modTime changed: " + modTime);
</td> </tr><tr><td>328</a></td> <td><a href="html/-1413930365.html">-1413930365</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>c4dfd0d7ef22210c16f2ec7197e5909e52b907c4</td> <td>None</td> <td>move the good config file into place</td> <td>SATD_ADDED</td> <td>testJoranConfigurationError()</td> <td>public void testJoranConfigurationError() throws Exception</td> <td>
    LogManager.getLoggerRepository().resetConfiguration();
    logger.setLevel(Level.DEBUG);
    File outFile = new File(getOutputFile("test3"));
    if (outFile.exists()) {
        assertTrue(outFile.delete());
    }
    // set up the needed file references
    File sourceFile1 = new File(getSourceXMLConfigFile("test3", 1));
    File sourceFile2 = new File(getSourceXMLConfigFile("test1", 2));
    assertTrue(sourceFile1.exists());
    assertTrue(sourceFile2.exists());
    // config file should not exist yet
    File configFile = new File(getXMLConfigFile("test3"));
    assertFalse(configFile.exists());
    // now watch the nonexistent file for changes
    FileWatchdog watchdog = new FileWatchdog();
    watchdog.setName("test3");
    watchdog.setFile(configFile.getAbsolutePath());
    watchdog.setInterval(1000);
    watchdog.setConfigurator(JoranConfigurator.class.getName());
    ((LoggerRepositoryEx) LogManager.getLoggerRepository()).getPluginRegistry().addPlugin(watchdog);
    watchdog.activateOptions();
    testLogger.debug("watchdog activated");
    // the file does not exist, so the modification time should never change
    long modTime = watchdog.getLastModTime();
    for (int count = 0; count < 5; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue("watchdog mod time changed when no file", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("no file, mod time not changed: " + modTime);
    // move the bad config file into place
    copyFile(sourceFile1, configFile);
    assertTrue(configFile.exists());
    testLogger.debug("bad config file put into place");
    // the file is "bad", so the modification time should never change
    for (int count = 0; count < 7; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue("watchdog mod time changed for bad file", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("bad file, mod time not changed: " + modTime);
    // move the good config file into place
    copyFile(sourceFile2, configFile);
    assertTrue(configFile.exists());
    testLogger.debug("moved good config file into place");
    // the file is good, so the modification time and level should change
    for (int count = 0; count < 7; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue(logger.getLevel() == Level.INFO);
            break;
        }
        if (count == 6) {
            assertTrue("mod time for good file never changed", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("good file, modTime changed: " + modTime);
</td> </tr><tr><td>327</a></td> <td><a href="html/-1413930366.html">-1413930366</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>c4dfd0d7ef22210c16f2ec7197e5909e52b907c4</td> <td>None</td> <td>move the bad config file into place</td> <td>SATD_ADDED</td> <td>testJoranConfigurationError()</td> <td>public void testJoranConfigurationError() throws Exception</td> <td>
    LogManager.getLoggerRepository().resetConfiguration();
    logger.setLevel(Level.DEBUG);
    File outFile = new File(getOutputFile("test3"));
    if (outFile.exists()) {
        assertTrue(outFile.delete());
    }
    // set up the needed file references
    File sourceFile1 = new File(getSourceXMLConfigFile("test3", 1));
    File sourceFile2 = new File(getSourceXMLConfigFile("test1", 2));
    assertTrue(sourceFile1.exists());
    assertTrue(sourceFile2.exists());
    // config file should not exist yet
    File configFile = new File(getXMLConfigFile("test3"));
    assertFalse(configFile.exists());
    // now watch the nonexistent file for changes
    FileWatchdog watchdog = new FileWatchdog();
    watchdog.setName("test3");
    watchdog.setFile(configFile.getAbsolutePath());
    watchdog.setInterval(1000);
    watchdog.setConfigurator(JoranConfigurator.class.getName());
    ((LoggerRepositoryEx) LogManager.getLoggerRepository()).getPluginRegistry().addPlugin(watchdog);
    watchdog.activateOptions();
    testLogger.debug("watchdog activated");
    // the file does not exist, so the modification time should never change
    long modTime = watchdog.getLastModTime();
    for (int count = 0; count < 5; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue("watchdog mod time changed when no file", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("no file, mod time not changed: " + modTime);
    // move the bad config file into place
    copyFile(sourceFile1, configFile);
    assertTrue(configFile.exists());
    testLogger.debug("bad config file put into place");
    // the file is "bad", so the modification time should never change
    for (int count = 0; count < 7; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue("watchdog mod time changed for bad file", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("bad file, mod time not changed: " + modTime);
    // move the good config file into place
    copyFile(sourceFile2, configFile);
    assertTrue(configFile.exists());
    testLogger.debug("moved good config file into place");
    // the file is good, so the modification time and level should change
    for (int count = 0; count < 7; count++) {
        if (modTime != watchdog.getLastModTime()) {
            assertTrue(logger.getLevel() == Level.INFO);
            break;
        }
        if (count == 6) {
            assertTrue("mod time for good file never changed", false);
        }
        Thread.sleep(500);
    }
    testLogger.debug("good file, modTime changed: " + modTime);
</td> </tr><tr><td>326</a></td> <td><a href="html/-1413930367.html">-1413930367</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>043ce2af5d6da3989c1eb0a655f139001bd7364f</td> <td>None</td> <td>move pointer</td> <td>SATD_ADDED</td> <td>addToList(PatternConverter)</td> <td>private void addToList(PatternConverter pc)</td> <td>
    if (head == null) {
        head = tail = pc;
    } else {
        tail.next = pc;
        tail = pc;
    }
</td> </tr><tr><td>325</a></td> <td><a href="html/-1413930368.html">-1413930368</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>abbd9d3d8b7b16aa02f45679753c1e20886bc49f</td> <td>None</td> <td>
could potentially return a LoggerRepository property value
when there is not an MDC property value
but the negative consequences should be minimal.</td> <td>SATD_ADDED</td> <td>getMDC(String)</td> <td>public Object getMDC(final String key)</td> <td>
    // 
    // could potentially return a LoggerRepository property value
    // when there is not an MDC property value
    // but the negative consequences should be minimal.
    if (properties != null) {
        Object r = properties.get(key);
        if (r != null) {
            return r;
        }
    }
    return MDC.get(key);
</td> </tr><tr><td>313</a></td> <td><a href="html/-1413930372.html">-1413930372</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>532c5ca2102386382f099e4920e93ec9f29f49bb</td> <td>move pointer</td> <td>move pointer</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>getPatternLayoutRules()</td> <td>public static Map getPatternLayoutRules()</td> <td>
    return PATTERN_LAYOUT_RULES;
</td> </tr><tr><td>312</a></td> <td><a href="html/-1413930406.html">-1413930406</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>200bdbf75b61b68118ab32bd793ef035846b78f5</td> <td>TODO work out how the Selector has it's AppenderFactory configured by Joran</td> <td>TODO work out how the Selector has it's AppenderFactory configured by Joran</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    // check that we have a selector of something at this point
    if (getSelector() == null) {
        throw new IllegalStateException("Should have had a Selector defined at this point");
    }
// TODO work out how the Selector has it's AppenderFactory configured by Joran
</td> </tr><tr><td>298</a></td> <td><a href="html/-1413930531.html">-1413930531</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d43f5081fc7c12832d8cd942dae4a6031446d74f</td> <td>Failing to reset the object output stream every now and
then creates a serious memory leak.
right now we always reset. TODO - set up frequency counter per oos?</td> <td>Failing to reset the object output stream every now and
then creates a serious memory leak.
right now we always reset. TODO - set up frequency counter per oos?</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    startServer();
</td> </tr><tr><td>279</a></td> <td><a href="html/-1413930531.html">-1413930531</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>834066bf1a6ebae4fcbf04295d3e80b5f1930410</td> <td>Failing to reset the object output stream every now and
then creates a serious memory leak.
right now we always reset. TODO - set up frequency counter per oos?</td> <td>Failing to reset the object output stream every now and
then creates a serious memory leak.
right now we always reset. TODO - set up frequency counter per oos?</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>activate()</td> <td>public void activate()</td> <td>
    startServer();
    super.activate();
</td> </tr><tr><td>278</a></td> <td><a href="html/-1413930406.html">-1413930406</td><td>apache/log4j</td><td>Scott Deboy</td><td>7db3e1f0e0bb4c4b77e638df7580b4b8377aeb4a</td> <td>TODO work out how the Selector has it's AppenderFactory configured by Joran</td> <td>TODO work out how the Selector has it's AppenderFactory configured by Joran</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    // check that we have a selector of something at this point
    if (getSelector() == null) {
        throw new IllegalStateException("Should have had a Selector defined at this point");
    }
// TODO work out how the Selector has it's AppenderFactory configured by Joran
</td> </tr><tr><td>272</a></td> <td><a href="html/-1413930379.html">-1413930379</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e08a60f350fe21e2be1ffae32a6ef707242f29c1</td> <td>None</td> <td>TODO: add support for spaces in prooperty keys</td> <td>SATD_ADDED</td> <td>testProperty2()</td> <td>public void testProperty2() throws IOException, ScanError</td> <td>
// TODO: add support for spaces in prooperty keys
// StringReader sr = new StringReader(" property.'toto a' etc");
// TokenStream ts = new TokenStream(sr);
// 
// ts.next(); t = ts.getCurrent();
// assertEquals(Token.PROPERTY, t.getType());
// assertEquals("toto a", t.getValue());
</td> </tr><tr><td>271</a></td> <td><a href="html/-1413930380.html">-1413930380</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>c6d8b7375cfcf4a4cc5dfc975c7abf2289cf825d</td> <td>None</td> <td>the following test cannot be run because of a bug in the way
java.io.StreamTokenizer incorrectly interprets the '\' character within quotes</td> <td>SATD_ADDED</td> <td>testRegexMessage()</td> <td>public void testRegexMessage() throws Exception, ScanError</td> <td>
    evaluator = new LBELEventEvaluator("message ~ 'hello'");
    assertTrue(evaluator.evaluate(event));
    evaluator = new LBELEventEvaluator("message ~ 'h[a-z]* world'");
    assertTrue(evaluator.evaluate(event));
    // the following test cannot be run because of a bug in the way
    // java.io.StreamTokenizer incorrectly interprets the '\' character within quotes
    // evaluator = new LBELEventEvaluator("message ~ 'h\\w* world'");
    // assertTrue(evaluator.evaluate(event));
    LBELEventEvaluator evaluator = new LBELEventEvaluator("message !~ 'x'");
    assertTrue(evaluator.evaluate(event));
    evaluator = new LBELEventEvaluator("message !~ 'x[a-z]* world'");
    assertTrue(evaluator.evaluate(event));
</td> </tr><tr><td>269</a></td> <td><a href="html/-1413930382.html">-1413930382</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>25517ae23def94e51e9c3b77ff3d0089c9279f8e</td> <td>None</td> <td>FIXME: We should not flood other appenders but at the same time
should output something meaningful (only once though).
Logging not allowed:
getLogger().error(</td> <td>SATD_ADDED</td> <td>doAppend(LoggingEvent)</td> <td>public synchronized void doAppend(LoggingEvent event)</td> <td>
    // WARNING: The guard check MUST be the first statement in the
    // doAppend() method.
    // prevent re-entry.
    if (guard) {
        return;
    }
    try {
        guard = true;
        if (closed) {
            // FIXME: We should not flood other appenders but at the same time
            // should output something meaningful (only once though).
            // Logging not allowed:
            // getLogger().error(
            // "Attempted to append to closed appender named [{}].", name);
            return;
        }
        if (!isAsSevereAsThreshold(event.getLevel())) {
            return;
        }
        Filter f = this.headFilter;
        FILTER_LOOP: while (f != null) {
            switch(f.decide(event)) {
                case Filter.DENY:
                    return;
                case Filter.ACCEPT:
                    break FILTER_LOOP;
                case Filter.NEUTRAL:
                    f = f.getNext();
            }
        }
        this.append(event);
    } finally {
        guard = false;
    }
</td> </tr><tr><td>268</a></td> <td><a href="html/-1413930383.html">-1413930383</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>1f62d9a039c3ee68f66c6c5cb41760438777dfd8</td> <td>TODO: this method should be removed if OptionConverter becomes a static</td> <td>TODO: this method should be removed if OptionConverter becomes totally static</td> <td>SATD_CHANGED</td> <td>setLoggerRepository(LoggerRepository)</td> <td>public static void setLoggerRepository(LoggerRepository lr)</td> <td>
</td> </tr><tr><td>267</a></td> <td><a href="html/-1413930383.html">-1413930383</td><td>apache/log4j</td><td>Scott Deboy</td><td>d192ca52485990a035b7ef84cea67a6743ad3d47</td> <td>None</td> <td>TODO: this method should be removed if OptionConverter becomes a static</td> <td>SATD_ADDED</td> <td>setLoggerRepository(LoggerRepository)</td> <td>public static void setLoggerRepository(LoggerRepository lr)</td> <td>
</td> </tr><tr><td>266</a></td> <td><a href="html/-1413930384.html">-1413930384</td><td>apache/log4j</td><td>Scott Deboy</td><td>d192ca52485990a035b7ef84cea67a6743ad3d47</td> <td>None</td> <td>TODO: this method should be removed if OptionConverter becomes a static</td> <td>SATD_ADDED</td> <td>getLogger()</td> <td> static Logger getLogger()</td> <td>
    return LogManager.getLogger(OptionConverter.class);
</td> </tr><tr><td>262</a></td> <td><a href="html/-1413930397.html">-1413930397</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>0db46c49dc1c195b50feb9e3db59ae26fec623cc</td> <td>If the systemId is not for us to handle, we delegate to our super
class, at leasts that's the basic idea. However, the code below
needs to be more complicated.</td> <td>If the systemId is not for us to handle, we delegate to our super
class, at leasts that's the basic idea. However, the code below
needs to be more complicated.
Due to inexplicable voodoo, the original resolveEntity method in
org.xml.sax.helpers.DefaultHandler declares throwing an IOException,
whereas the org.xml.sax.helpers.DefaultHandler class included in
JDK 1.4 masks this exception. In JDK 1.5, the IOException has been
put back...
In order to compile under JDK 1.4, we are forced to mask the IOException
as well. Since its signatures varies, we cannot call our super class'
resolveEntity method. We are forced to implement the default behavior
ourselves, which in this case, is just returning null.</td> <td>SATD_REMOVED</td> <td>error(SAXParseException)</td> <td>public void error(final SAXParseException spe)</td> <td>
    errorReport(spe);
</td> </tr><tr><td>260</a></td> <td><a href="html/-1413930385.html">-1413930385</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>6e636eebbcc46431fe15821866d2518f3ca9840d</td> <td>None</td> <td>if repository is set but logger is not an instance of Logger, we
could reset the logger, as in the line below. However, we chose not to
do so in order to make the bigger problem more apparent.</td> <td>SATD_ADDED</td> <td>getLogger()</td> <td>protected ULogger getLogger()</td> <td>
    if (logger == null) {
        if (repository != null) {
            logger = repository.getLogger(this.getClass().getName());
        } else {
            logger = LogManager.SIMPLE_LOGGER_FA.getLogger(this.getClass().getName());
        }
    } else if (repository != null && !(logger instanceof org.apache.log4j.Logger)) {
    // if repository is set but logger is not an instance of Logger, we
    // could reset the logger, as in the line below. However, we chose not to
    // do so in order to make the bigger problem more apparent.
    // logger = repository.getLogger(this.getClass().getName());
    }
    return logger;
</td> </tr><tr><td>257</a></td> <td><a href="html/-1413930386.html">-1413930386</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>6a00ff29234b4f5a13eb18b087757707ab208868</td> <td>subsequent calls within one minute
are optimized to reuse previous formatted value
make a couple of nearly spaced calls
(Note: 'Z' is JDK 1.4, using 'z' instead.)</td> <td>subsequent calls within one minute
are optimized to reuse previous formatted value
make a couple of nearly spaced calls
(Note: 'Z' is JDK 1.4, using 'z' instead.)</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>disabled_test5()</td> <td>public void disabled_test5()</td> <td>
    // subsequent calls within one minute
    // are optimized to reuse previous formatted value
    // make a couple of nearly spaced calls
    // (Note: 'Z' is JDK 1.4, using 'z' instead.)
    Locale thai = new Locale("th", "TH");
    SimpleDateFormat baseFormat = new SimpleDateFormat("EEE, MMM dd, HH:mm:ss.SSS z", thai);
    DateFormat cachedFormat = new CachedDateFormat(baseFormat, 1000);
    // 
    // use a date in the year 2000 CE to attempt to confuse the millisecond locator
    long ticks = 11141L * 86400000L;
    String sx;
    Date jul1 = new Date(ticks);
    sx = cachedFormat.format(jul1);
    System.out.println(baseFormat.format(jul1));
    System.out.println(sx);
    assertEquals(baseFormat.format(jul1), sx);
    sx = cachedFormat.format(jul1);
    System.out.println(baseFormat.format(jul1));
    System.out.println(sx);
    assertEquals(baseFormat.format(jul1), sx);
    Date plus8ms = new Date(ticks + 8);
    sx = cachedFormat.format(plus8ms);
    System.out.println(baseFormat.format(plus8ms));
    System.out.println(sx);
    assertEquals(baseFormat.format(plus8ms), sx);
    Date plus17ms = new Date(ticks + 17);
    assertEquals(baseFormat.format(plus17ms), cachedFormat.format(plus17ms));
    Date plus237ms = new Date(ticks + 237);
    assertEquals(baseFormat.format(plus237ms), cachedFormat.format(plus237ms));
    Date plus1415ms = new Date(ticks + 1415);
    assertEquals(baseFormat.format(plus1415ms), cachedFormat.format(plus1415ms));
</td> </tr><tr><td>256</a></td> <td><a href="html/-1413930386.html">-1413930386</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>305263f69ff0b6fe1597f662207f30d396b7da62</td> <td>None</td> <td>subsequent calls within one minute
are optimized to reuse previous formatted value
make a couple of nearly spaced calls
(Note: 'Z' is JDK 1.4, using 'z' instead.)</td> <td>SATD_ADDED</td> <td>disabled_test5()</td> <td>public void disabled_test5()</td> <td>
    // subsequent calls within one minute
    // are optimized to reuse previous formatted value
    // make a couple of nearly spaced calls
    // (Note: 'Z' is JDK 1.4, using 'z' instead.)
    Locale thai = new Locale("th", "TH");
    SimpleDateFormat baseFormat = new SimpleDateFormat("EEE, MMM dd, HH:mm:ss.SSS z", thai);
    DateFormat cachedFormat = new CachedDateFormat(baseFormat, 1000);
    // 
    // use a date in the year 2000 CE to attempt to confuse the millisecond locator
    long ticks = 11141L * 86400000L;
    String sx;
    Date jul1 = new Date(ticks);
    sx = cachedFormat.format(jul1);
    System.out.println(baseFormat.format(jul1));
    System.out.println(sx);
    assertEquals(baseFormat.format(jul1), sx);
    sx = cachedFormat.format(jul1);
    System.out.println(baseFormat.format(jul1));
    System.out.println(sx);
    assertEquals(baseFormat.format(jul1), sx);
    Date plus8ms = new Date(ticks + 8);
    sx = cachedFormat.format(plus8ms);
    System.out.println(baseFormat.format(plus8ms));
    System.out.println(sx);
    assertEquals(baseFormat.format(plus8ms), sx);
    Date plus17ms = new Date(ticks + 17);
    assertEquals(baseFormat.format(plus17ms), cachedFormat.format(plus17ms));
    Date plus237ms = new Date(ticks + 237);
    assertEquals(baseFormat.format(plus237ms), cachedFormat.format(plus237ms));
    Date plus1415ms = new Date(ticks + 1415);
    assertEquals(baseFormat.format(plus1415ms), cachedFormat.format(plus1415ms));
</td> </tr><tr><td>255</a></td> <td><a href="html/-1413930387.html">-1413930387</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>305263f69ff0b6fe1597f662207f30d396b7da62</td> <td>None</td> <td>subsequent calls within one minute are optimized to reuse previous
formatted value. make a couple of nearly spaced calls
(Note: 'Z' is JDK 1.4, using 'z' instead.)</td> <td>SATD_ADDED</td> <td>test4()</td> <td>public void test4()</td> <td>
    // subsequent calls within one minute are optimized to reuse previous
    // formatted value. make a couple of nearly spaced calls
    // (Note: 'Z' is JDK 1.4, using 'z' instead.)
    SimpleDateFormat baseFormat = new SimpleDateFormat("EEE, MMM dd, HH:mm:ss.SSS z", Locale.ENGLISH);
    DateFormat cachedFormat = new CachedDateFormat(baseFormat, 1000);
    // 
    // use a date in 2000 to attempt to confuse the millisecond locator
    long ticks = 11141L * 86400000L;
    Date jul1 = new Date(ticks);
    assertEquals(baseFormat.format(jul1), cachedFormat.format(jul1));
    Date plus8ms = new Date(ticks + 8);
    String base = baseFormat.format(plus8ms);
    String cached = cachedFormat.format(plus8ms);
    assertEquals(baseFormat.format(plus8ms), cachedFormat.format(plus8ms));
    Date plus17ms = new Date(ticks + 17);
    assertEquals(baseFormat.format(plus17ms), cachedFormat.format(plus17ms));
    Date plus237ms = new Date(ticks + 237);
    assertEquals(baseFormat.format(plus237ms), cachedFormat.format(plus237ms));
    Date plus1415ms = new Date(ticks + 1415);
    assertEquals(baseFormat.format(plus1415ms), cachedFormat.format(plus1415ms));
</td> </tr><tr><td>254</a></td> <td><a href="html/-1413930388.html">-1413930388</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2029de5a9357d7ca66c3ebee96058451cc4b0795</td> <td>None</td> <td>TODO consider falling back on something more meaningful</td> <td>SATD_ADDED</td> <td>getLogger(String)</td> <td>public static ULogger getLogger(String name)</td> <td>
    return adapter.getLogger(name);
</td> </tr><tr><td>253</a></td> <td><a href="html/-1413930389.html">-1413930389</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>f64dc00b4caf5b8043f9ebbd568ac5fd990dbfd1</td> <td>None</td> <td>at this point, the probability of the two events being equal is
extremely high. The next few test is optimized to take advantage of
this knowlege. (We only compare string lengths instead of invoking
string.equals which is much slower when the two string are equal.</td> <td>SATD_ADDED</td> <td>equals(Object)</td> <td>public boolean equals(Object rObject)</td> <td>
    if (this == rObject) {
        return true;
    }
    if (!(rObject instanceof LoggingEvent)) {
        return false;
    }
    LoggingEvent rEvent = (LoggingEvent) rObject;
    if (timeStamp != rEvent.timeStamp) {
        return false;
    }
    if (sequenceNumber != rEvent.sequenceNumber) {
        return false;
    }
    // at this point, the probability of the two events being equal is
    // extremely high. The next few test is optimized to take advantage of
    // this knowlege. (We only compare string lengths instead of invoking
    // string.equals which is much slower when the two string are equal.
    if (categoryName != null && rEvent.categoryName != null) {
        if (categoryName.length() != rEvent.categoryName.length()) {
            return false;
        }
    } else if (categoryName != rEvent.categoryName) {
        // of categoryNames is null while the other is not, they can't possibly
        // be equal
        return false;
    }
    // If timestamp, sequenceNumber and categoryName length are equal than the
    // events are assumed to be equal.
    return true;
</td> </tr><tr><td>252</a></td> <td><a href="html/-1413930390.html">-1413930390</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>31f5b471836a18905c8001562a5ac602aa350bf9</td> <td>None</td> <td>NOTE: tab addition is a very fragile process - if you modify this code,
verify the frames in the individual log panels initialize to their
correct sizes</td> <td>SATD_ADDED</td> <td>showSplash(Frame)</td> <td>private static final void showSplash(Frame owner)</td> <td>
    splash = new ChainsawSplash(owner);
    SwingHelper.centerOnScreen(splash);
    splash.setVisible(true);
</td> </tr><tr><td>251</a></td> <td><a href="html/-1413930391.html">-1413930391</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>17fa629e45d0dcd55b81edb34286e8c675a0bfd4</td> <td>None</td> <td>
TODO: why is this returning ,120 ... , 120
</td> <td>SATD_ADDED</td> <td>test17()</td> <td>public void test17()</td> <td>
    Date jul2 = new Date(12602L * 86400000L);
    String badPattern = "HH:mm:ss,SSS HH:mm:ss,SSS";
    SimpleDateFormat simpleFormat = new SimpleDateFormat(badPattern);
    simpleFormat.setTimeZone(GMT);
    DateFormat cachedFormat = new CachedDateFormat(simpleFormat, 1000);
    String s = cachedFormat.format(jul2);
    assertEquals("00:00:00,000 00:00:00,000", s);
    jul2.setTime(jul2.getTime() + 120);
    assertEquals("00:00:00,120 00:00:00,120", simpleFormat.format(jul2));
    s = cachedFormat.format(jul2);
    // 
    // TODO: why is this returning ,120 ... , 120
    // 
    // assertEquals("00:00:00,120 00:00:00,000", s) ;
    int maxValid = CachedDateFormat.getMaximumCacheValidity(badPattern);
    assertEquals(1, maxValid);
</td> </tr><tr><td>249</a></td> <td><a href="html/-1413930392.html">-1413930392</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>a4780f399cbdd589a8b1ace5d00792c2e1f762e0</td> <td>None</td> <td>if we can cache, so much the better</td> <td>SATD_ADDED</td> <td>setOptions(List)</td> <td>public void setOptions(List optionList)</td> <td>
    String patternOption;
    if (optionList == null || optionList.size() == 0) {
        // the branch could be optimized, but here we are making explicit
        // that null values for patternOption are allowed.
        patternOption = null;
    } else {
        patternOption = (String) optionList.get(0);
    }
    String pattern;
    if (patternOption == null) {
        pattern = "yyyy-MM-dd HH:mm:ss,SSS";
    } else if (patternOption.equalsIgnoreCase(AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
        pattern = "yyyy-MM-dd HH:mm:ss,SSS";
    } else if (patternOption.equalsIgnoreCase(AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
        pattern = "HH:mm:ss,SSS";
    } else if (patternOption.equalsIgnoreCase(AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
        pattern = "dd MMM yyyy HH:mm:ss,SSS";
    } else {
        pattern = patternOption;
    }
    try {
        df = new SimpleDateFormat(pattern);
    } catch (IllegalArgumentException e) {
        logger.warn("Could not instantiate SimpleDateFormat with pattern " + patternOption, e);
        // detault for the ISO8601 format
        pattern = "yyyy-MM-dd HH:mm:ss,SSS";
        df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS");
    }
    // if the option list contains a TZ option, then set it.
    if (optionList != null && optionList.size() > 1) {
        TimeZone tz = TimeZone.getTimeZone((String) optionList.get(1));
        df.setTimeZone(tz);
    }
    // if we can cache, so much the better
    if (CacheUtil.isPatternSafeForCaching(pattern)) {
        df = new CachedDateFormat(df);
    }
</td> </tr><tr><td>246</a></td> <td><a href="html/-1413930393.html">-1413930393</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e267766d610de35b2d96fdba6b5aa55ceeac3f4a</td> <td>
calling ourself should be safe and faster
but why risk it</td> <td>
calling ourself should be safe and faster
but why risk it</td> <td>FILE_PATH_CHANGED</td> <td>format(Date, StringBuffer, FieldPosition)</td> <td>public StringBuffer format(Date date, StringBuffer sbuf, FieldPosition fieldPosition)</td> <td>
    if (millisecondStart == UNRECOGNIZED_MILLISECOND_PATTERN) {
        return formatter.format(date, sbuf, fieldPosition);
    }
    long now = date.getTime();
    if (now < previousTime + 1000L && now >= previousTime) {
        if (millisecondStart >= 0) {
            cache.delete(millisecondStart, millisecondStart + 3);
            int millis = (int) (now - previousTime);
            int cacheLength = cache.length();
            // 
            // append milliseconds to the end of the cache
            numberFormat.format(millis, cache, fieldPosition);
            int milliLength = cache.length() - cacheLength;
            // 
            // if it didn't belong at the end, then move it
            if (cacheLength != millisecondStart) {
                String milli = cache.substring(cacheLength);
                cache.setLength(cacheLength);
                cache.insert(millisecondStart, milli);
            }
            for (int i = milliLength; i < 3; i++) {
                cache.insert(millisecondStart, "0");
            }
        }
        sbuf.append(cache);
    } else {
        previousTime = (now / 1000L) * 1000L;
        // 
        // if earlier than 1970 and rounded toward 1970
        // then move back one second
        if (now - previousTime < 0) {
            previousTime -= 1000;
        }
        cache.setLength(0);
        formatter.format(new Date(previousTime), cache, fieldPosition);
        millisecondStart = findMillisecondStart(previousTime, cache.toString(), formatter);
        // 
        // calling ourself should be safe and faster
        // but why risk it
        formatter.format(date, sbuf, fieldPosition);
    }
    return sbuf;
</td> </tr><tr><td>245</a></td> <td><a href="html/-1413930394.html">-1413930394</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e267766d610de35b2d96fdba6b5aa55ceeac3f4a</td> <td>
if it didn't belong at the end, then move it</td> <td>
if it didn't belong at the end, then move it</td> <td>FILE_PATH_CHANGED</td> <td>format(Date, StringBuffer, FieldPosition)</td> <td>public StringBuffer format(Date date, StringBuffer sbuf, FieldPosition fieldPosition)</td> <td>
    if (millisecondStart == UNRECOGNIZED_MILLISECOND_PATTERN) {
        return formatter.format(date, sbuf, fieldPosition);
    }
    long now = date.getTime();
    if (now < previousTime + 1000L && now >= previousTime) {
        if (millisecondStart >= 0) {
            cache.delete(millisecondStart, millisecondStart + 3);
            int millis = (int) (now - previousTime);
            int cacheLength = cache.length();
            // 
            // append milliseconds to the end of the cache
            numberFormat.format(millis, cache, fieldPosition);
            int milliLength = cache.length() - cacheLength;
            // 
            // if it didn't belong at the end, then move it
            if (cacheLength != millisecondStart) {
                String milli = cache.substring(cacheLength);
                cache.setLength(cacheLength);
                cache.insert(millisecondStart, milli);
            }
            for (int i = milliLength; i < 3; i++) {
                cache.insert(millisecondStart, "0");
            }
        }
        sbuf.append(cache);
    } else {
        previousTime = (now / 1000L) * 1000L;
        // 
        // if earlier than 1970 and rounded toward 1970
        // then move back one second
        if (now - previousTime < 0) {
            previousTime -= 1000;
        }
        cache.setLength(0);
        formatter.format(new Date(previousTime), cache, fieldPosition);
        millisecondStart = findMillisecondStart(previousTime, cache.toString(), formatter);
        // 
        // calling ourself should be safe and faster
        // but why risk it
        formatter.format(date, sbuf, fieldPosition);
    }
    return sbuf;
</td> </tr><tr><td>244</a></td> <td><a href="html/-1413930393.html">-1413930393</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>86dcb54ec6afeb2ed8e3332e243db749a0d44b2b</td> <td>None</td> <td>
calling ourself should be safe and faster
but why risk it</td> <td>SATD_ADDED</td> <td>format(Date, StringBuffer, FieldPosition)</td> <td>public StringBuffer format(Date date, StringBuffer sbuf, FieldPosition fieldPosition)</td> <td>
    if (millisecondStart == UNRECOGNIZED_MILLISECOND_PATTERN) {
        return formatter.format(date, sbuf, fieldPosition);
    }
    long now = date.getTime();
    if (now < previousTime + 1000L && now >= previousTime) {
        if (millisecondStart >= 0) {
            cache.delete(millisecondStart, millisecondStart + 3);
            int millis = (int) (now - previousTime);
            int cacheLength = cache.length();
            // 
            // append milliseconds to the end of the cache
            numberFormat.format(millis, cache, fieldPosition);
            int milliLength = cache.length() - cacheLength;
            // 
            // if it didn't belong at the end, then move it
            if (cacheLength != millisecondStart) {
                String milli = cache.substring(cacheLength);
                cache.setLength(cacheLength);
                cache.insert(millisecondStart, milli);
            }
            for (int i = milliLength; i < 3; i++) {
                cache.insert(millisecondStart, "0");
            }
        }
        sbuf.append(cache);
    } else {
        previousTime = (now / 1000L) * 1000L;
        // 
        // if earlier than 1970 and rounded toward 1970
        // then move back one second
        if (now - previousTime < 0) {
            previousTime -= 1000;
        }
        cache.setLength(0);
        formatter.format(new Date(previousTime), cache, fieldPosition);
        millisecondStart = findMillisecondStart(previousTime, cache.toString(), formatter);
        // 
        // calling ourself should be safe and faster
        // but why risk it
        formatter.format(date, sbuf, fieldPosition);
    }
    return sbuf;
</td> </tr><tr><td>243</a></td> <td><a href="html/-1413930394.html">-1413930394</td><td>apache/log4j</td><td>Curtis William Arnold</td><td>12d5aa3ea034cead621b9ff1f0a43e4dabcfe241</td> <td>None</td> <td>
if it didn't belong at the end, then move it</td> <td>SATD_ADDED</td> <td>format(Date, StringBuffer, FieldPosition)</td> <td>public StringBuffer format(Date date, StringBuffer sbuf, FieldPosition fieldPosition)</td> <td>
    if (millisecondStart == UNRECOGNIZED_MILLISECOND_PATTERN) {
        return formatter.format(date, sbuf, fieldPosition);
    }
    long now = date.getTime();
    if (now < previousTime + 1000L && now >= previousTime) {
        if (millisecondStart >= 0) {
            cache.delete(millisecondStart, millisecondStart + 3);
            int millis = (int) (now - previousTime);
            int cacheLength = cache.length();
            // 
            // append milliseconds to the end of the cache
            numberFormat.format(millis, cache, fieldPosition);
            int milliLength = cache.length() - cacheLength;
            // 
            // if it didn't belong at the end, then move it
            if (cacheLength != millisecondStart) {
                String milli = cache.substring(cacheLength);
                cache.setLength(cacheLength);
                cache.insert(millisecondStart, milli);
            }
            for (int i = milliLength; i < 3; i++) {
                cache.insert(millisecondStart, "0");
            }
        }
    } else {
        previousTime = (now / 1000L) * 1000L;
        // 
        // if earlier than 1970 and rounded toward 1970
        // then move back one second
        if (now - previousTime < 0) {
            previousTime -= 1000;
        }
        int prevLength = cache.length();
        cache.setLength(0);
        formatter.format(date, cache, fieldPosition);
        // 
        // if the length changed then
        // recalculate the millisecond position
        if (cache.length() != prevLength) {
            // 
            // format the previous integral second
            StringBuffer tempBuffer = new StringBuffer(cache.length());
            formatter.format(new Date(previousTime), tempBuffer, fieldPosition);
            // 
            // detect the start of the millisecond field
            millisecondStart = findMillisecondStart(previousTime, tempBuffer.toString(), formatter);
        }
    }
    sbuf.append(cache);
    return sbuf;
</td> </tr><tr><td>240</a></td> <td><a href="html/-1413930397.html">-1413930397</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>feb4cbb673ca53f72ccb05b07a96f66d53a84897</td> <td>None</td> <td>If the systemId is not for us to handle, we delegate to our super
class, at leasts that's the basic idea. However, the code below
needs to be more complicated.</td> <td>SATD_ADDED</td> <td>error(SAXParseException)</td> <td>public void error(final SAXParseException spe)</td> <td>
    errorReport(spe);
</td> </tr><tr><td>239</a></td> <td><a href="html/-1413930398.html">-1413930398</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e6d0c5a232e2d63de06f5b588cf7c1837141b78a</td> <td>None</td> <td>TODO This is clearly bogus.</td> <td>SATD_ADDED</td> <td>getActiveFileName()</td> <td>public String getActiveFileName()</td> <td>
    // TODO This is clearly bogus.
    return activeFileName;
</td> </tr><tr><td>237</a></td> <td><a href="html/-1413930399.html">-1413930399</td><td>apache/log4j</td><td>Jacob Kjome</td><td>1e8aeccdd04dc0dfb45e8a9e8a6745952bfb4bcb</td> <td>None</td> <td>POSSIBLE TO-DO: add support for properties
passed to the initial context, e.g. a factory,
to enable things like a remote context.</td> <td>SATD_ADDED</td> <td>findNamingContext()</td> <td>protected void findNamingContext() throws NamingException</td> <td>
    if (getNamingContext() != null) {
        LOGGER.warn("Overwriting existing naming context.");
    }
    // POSSIBLE TO-DO: add support for properties
    // passed to the initial context, e.g. a factory,
    // to enable things like a remote context.
    InitialContext ic = new InitialContext();
    namingContext = (Context) ic.lookup("java:comp/env");
</td> </tr><tr><td>235</a></td> <td><a href="html/-1413930401.html">-1413930401</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>559f0829327009ee2d5172011d18056827ff8f62</td> <td>None</td> <td>TODO This is clearly bogus.</td> <td>SATD_ADDED</td> <td>getActiveFileName()</td> <td>public String getActiveFileName()</td> <td>
    // TODO This is clearly bogus.
    return activeFileName;
</td> </tr><tr><td>232</a></td> <td><a href="html/-1413930402.html">-1413930402</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>441ce6010640df7248bc0df2a40ca41cd02cf9de</td> <td>FIXME: What happens if the users wanted to set the additivity flag
for \"org.apahce.log4j\" to false in the config file? We are now
potentially overriding her wishes but I don't see any other way.</td> <td>FIXME: What happens if the users wanted to set the additivity flag
for \"org.apahce.log4j\" to false in the config file? We are now
potentially overriding her wishes but I don't see any other way.</td> <td>SATD_MOVED_FILE</td> <td>detachListAppender(LoggerRepository)</td> <td>protected void detachListAppender(LoggerRepository repository)</td> <td>
    Logger ll = repository.getLogger(Constants.LOG4J_PACKAGE_NAME);
    // FIXME: What happens if the users wanted to set the additivity flag
    // for "org.apahce.log4j" to false in the config file? We are now
    // potentially overriding her wishes but I don't see any other way.
    ll.setAdditivity(true);
    ListAppender listAppender = (ListAppender) ll.getAppender(Constants.TEMP_LIST_APPENDER_NAME);
    if (listAppender == null) {
        String errMsg = "Could not find appender " + Constants.TEMP_LIST_APPENDER_NAME;
        getLogger(repository).error(errMsg);
        addError(new ErrorItem(errMsg));
        return;
    }
    List eventList = listAppender.getList();
    int size = eventList.size();
    for (int i = 0; i < size; i++) {
        LoggingEvent event = (LoggingEvent) eventList.get(i);
        Logger xLogger = event.getLogger();
        if (event.getLevel().isGreaterOrEqual(xLogger.getEffectiveLevel())) {
            xLogger.callAppenders(event);
        }
    }
    listAppender.clearModel();
    listAppender.close();
    ll.removeAppender(listAppender);
</td> </tr><tr><td>231</a></td> <td><a href="html/-1413930403.html">-1413930403</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>5ce8c4d34da5f4ff1dff4092589833e8fa6c56a9</td> <td>FIXME: What happens if the users wanted to set the additivity flag
to false in the config file? We are now potentially overriding her
wishes but I don't see any other way.</td> <td>FIXME: What happens if the users wanted to set the additivity flag
for \"org.apahce.log4j\" to false in the config file? We are now
potentially overriding her wishes but I don't see any other way.</td> <td>SATD_CHANGED</td> <td>detachListAppender(LoggerRepository)</td> <td>protected void detachListAppender(LoggerRepository repository)</td> <td>
    ExecutionContext ec = joranInterpreter.getExecutionContext();
    Logger ll = repository.getLogger(Constants.LOG4J_PACKAGE_NAME);
    // FIXME: What happens if the users wanted to set the additivity flag
    // for "org.apahce.log4j" to false in the config file? We are now
    // potentially overriding her wishes but I don't see any other way.
    ll.setAdditivity(true);
    ListAppender listAppender = (ListAppender) ll.getAppender(Constants.TEMP_LIST_APPENDER_NAME);
    if (listAppender == null) {
        String errMsg = "Could not find appender " + Constants.TEMP_LIST_APPENDER_NAME;
        getLogger().error(errMsg);
        ec.addError(new ErrorItem(errMsg));
        return;
    }
    List eventList = listAppender.getList();
    int size = eventList.size();
    for (int i = 0; i < size; i++) {
        LoggingEvent event = (LoggingEvent) eventList.get(i);
        Logger xLogger = event.getLogger();
        if (event.getLevel().isGreaterOrEqual(xLogger.getEffectiveLevel())) {
            xLogger.callAppenders(event);
        }
    }
    listAppender.clearModel();
    listAppender.close();
    ll.removeAppender(listAppender);
</td> </tr><tr><td>230</a></td> <td><a href="html/-1413930403.html">-1413930403</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>3605f1464cd0ddde0bca8aa270fbe6e6e63edaaa</td> <td>None</td> <td>FIXME: What happens if the users wanted to set the additivity flag
to false in the config file? We are now potentially overriding her
wishes but I don't see any other way.</td> <td>SATD_ADDED</td> <td>detachListAppender(LoggerRepository)</td> <td>protected void detachListAppender(LoggerRepository repository)</td> <td>
    ExecutionContext ec = joranInterpreter.getExecutionContext();
    Logger ll = repository.getLogger(Constants.LOG4J_PACKAGE_NAME);
    // FIXME: What happens if the users wanted to set the additivity flag
    // to false in the config file? We are now potentially overriding her
    // wishes but I don't see any other way.
    ll.setAdditivity(true);
    ListAppender listAppender = (ListAppender) ll.getAppender(Constants.TEMP_LIST_APPENDER_NAME);
    if (listAppender == null) {
        String errMsg = "Could not find appender " + Constants.TEMP_LIST_APPENDER_NAME;
        getLogger().error(errMsg);
        ec.addError(new ErrorItem(errMsg));
        return;
    }
    List eventList = listAppender.getList();
    int size = eventList.size();
    for (int i = 0; i < size; i++) {
        LoggingEvent event = (LoggingEvent) eventList.get(i);
        Logger xLogger = event.getLogger();
        if (event.getLevel().isGreaterOrEqual(xLogger.getEffectiveLevel())) {
            xLogger.callAppenders(event);
        }
    }
    listAppender.clearModel();
    listAppender.close();
    ll.removeAppender(listAppender);
</td> </tr><tr><td>226</a></td> <td><a href="html/-1413930404.html">-1413930404</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2fefbb9bbeb0a094d22ae551e317e3ab425efed4</td> <td>None</td> <td>TODO probable should log that we're closing each appender</td> <td>SATD_ADDED</td> <td>close()</td> <td>public void close()</td> <td>
    // TODO probable should log that we're closing each appender
    for (Iterator iter = multiplexedAppenders.values().iterator(); iter.hasNext(); ) {
        Appender appender = (Appender) iter.next();
        appender.close();
    }
</td> </tr><tr><td>225</a></td> <td><a href="html/-1413930405.html">-1413930405</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2fefbb9bbeb0a094d22ae551e317e3ab425efed4</td> <td>None</td> <td>TODO check this is correct</td> <td>SATD_ADDED</td> <td>requiresLayout()</td> <td>public boolean requiresLayout()</td> <td>
    // TODO check this is correct
    return true;
</td> </tr><tr><td>224</a></td> <td><a href="html/-1413930406.html">-1413930406</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2fefbb9bbeb0a094d22ae551e317e3ab425efed4</td> <td>None</td> <td>TODO work out how the Selector has it's AppenderFactory configured by Joran</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    // check that we have a selector of something at this point
    if (getSelector() == null) {
        throw new IllegalStateException("Should have had a Selector defined at this point");
    }
// TODO work out how the Selector has it's AppenderFactory configured by Joran
</td> </tr><tr><td>223</a></td> <td><a href="html/-1413930407.html">-1413930407</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2fefbb9bbeb0a094d22ae551e317e3ab425efed4</td> <td>None</td> <td>TODO ?</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
// TODO ?
</td> </tr><tr><td>222</a></td> <td><a href="html/-1413930408.html">-1413930408</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2fefbb9bbeb0a094d22ae551e317e3ab425efed4</td> <td>None</td> <td>TODO we need a test that tests when the MDC value is null/not found</td> <td>SATD_ADDED</td> <td>testcreateMDCAndDailyRollingAppenderFactory()</td> <td>public void testcreateMDCAndDailyRollingAppenderFactory()</td> <td>
    AppenderFactory factory = AppenderFactoryUtils.createMDCAndDailyRollingAppenderFactory("output/standardMDC", "User", new PatternLayout("%m%n"));
    MDC.put("User", "Bob");
    LoggingEvent e = new LoggingEvent();
    RollingFileAppender appender = (RollingFileAppender) factory.create(e);
    assertEquals(appender.getTriggeringPolicy().getClass(), TimeBasedRollingPolicy.class);
// TimeBasedRollingPolicy policy =(TimeBasedRollingPolicy) appender.getTriggeringPolicy();
</td> </tr><tr><td>221</a></td> <td><a href="html/-1413930409.html">-1413930409</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>89a43cf272908b3c94312ed074568039c7121f30</td> <td>None</td> <td>io exception - probably shut down</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    new Thread(new Runnable() {

        public void run() {
            initialize();
            try {
                reader = new InputStreamReader(new URL(getFileURL()).openStream());
            } catch (IOException ioe) {
                LogLog.debug("exception", ioe);
                return;
            }
            try {
                process(reader);
            } catch (IOException ioe) {
                // io exception - probably shut down
                LogLog.debug("stream closed");
            }
        }
    }).start();
</td> </tr><tr><td>220</a></td> <td><a href="html/-1413930410.html">-1413930410</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>31836fb3952ef3022b72bf346adea8164473c5e3</td> <td>None</td> <td>this should work, shouldn't it?</td> <td>SATD_ADDED</td> <td>setClassName(LocationInfo, Object)</td> <td> static void setClassName(LocationInfo li, Object location)</td> <td>
    try {
        li.className = (String) getClassName.invoke(location, nullArgs);
    } catch (Throwable e) {
    }
// this should work, shouldn't it?
</td> </tr><tr><td>219</a></td> <td><a href="html/-1413930411.html">-1413930411</td><td>apache/log4j</td><td>Yoav Shapira</td><td>d8530a7ba0a823db98022edabcc018e5864ab2a5</td> <td>None</td> <td>TODO work out a better way of decorating a component</td> <td>SATD_ADDED</td> <td>decorateComponent()</td> <td>private void decorateComponent()</td> <td>
    // TODO work out a better way of decorating a component
    guiTarget.setBorder(BorderFactory.createLineBorder(Color.black));
</td> </tr><tr><td>218</a></td> <td><a href="html/-1413930496.html">-1413930496</td><td>apache/log4j</td><td>Yoav Shapira</td><td>d8530a7ba0a823db98022edabcc018e5864ab2a5</td> <td>TODO Handle the error with a nice msg</td> <td>TODO Handle the error with a nice msg</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>importURL(ChainsawAppenderHandler, Decoder, String, URL)</td> <td>public static void importURL(final ChainsawAppenderHandler handler, final Decoder decoder, String name, URL url)</td> <td>
    Map additionalProperties = new HashMap();
    additionalProperties.put(Constants.HOSTNAME_KEY, "file");
    additionalProperties.put(Constants.APPLICATION_KEY, name);
    decoder.setAdditionalProperties(additionalProperties);
    final URL urlToUse = url;
    new Thread(new Runnable() {

        public void run() {
            try {
                Vector events = decoder.decode(urlToUse);
                Iterator iter = events.iterator();
                while (iter.hasNext()) {
                    handler.append((LoggingEvent) iter.next());
                }
            } catch (IOException e1) {
                // TODO Handle the error with a nice msg
                LOG.error(e1);
            }
        }
    }).start();
</td> </tr><tr><td>216</a></td> <td><a href="html/-1413930412.html">-1413930412</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>a18b74108260ddfa7ca6e13ce8400dcbfe29b68a</td> <td>None</td> <td>TODO UDPAppender throws NullPointerException if the layout is not set</td> <td>SATD_ADDED</td> <td>append(LoggingEvent)</td> <td>public void append(LoggingEvent event)</td> <td>
    if (inError) {
        return;
    }
    if (event == null) {
        return;
    }
    if (address == null) {
        errorHandler.error("No remote host is set for UDPAppender named \"" + this.name + "\".");
        return;
    }
    if (outSocket != null) {
        // if the values already exist, don't set (useful when forwarding from a simplesocketserver
        if ((overrideProperties != null) && overrideProperties.equalsIgnoreCase("true")) {
            event.setProperty(Constants.HOSTNAME_KEY, hostname);
            if (application != null) {
                event.setProperty(Constants.APPLICATION_KEY, application);
            }
        }
        try {
            // TODO UDPAppender throws NullPointerException if the layout is not set
            StringBuffer buf = new StringBuffer(layout.format(event));
            // the implementation of string.getBytes accepts a null encoding and uses the system charset
            DatagramPacket dp = new DatagramPacket(buf.toString().getBytes(encoding), buf.length(), address, port);
            outSocket.send(dp);
            // remove these properties, in case other appenders need to set them to different values
            event.setProperty(Constants.HOSTNAME_KEY, null);
            event.setProperty(Constants.APPLICATION_KEY, null);
        } catch (IOException e) {
            outSocket = null;
            LogLog.warn("Detected problem with UDP connection: " + e);
        }
    }
</td> </tr><tr><td>214</a></td> <td><a href="html/-1413930413.html">-1413930413</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e7ec8973dc4c7618cd9dab379e2a5426a1292e40</td> <td>None</td> <td>TODO UDPAppender throws NullPointerException if the layout is not set</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    try {
        hostname = InetAddress.getLocalHost().getHostName();
    } catch (UnknownHostException uhe) {
        try {
            hostname = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException uhe2) {
            hostname = "unknown";
        }
    }
    // allow system property of application to be primary
    if (application == null) {
        application = System.getProperty(Constants.APPLICATION_KEY);
    } else {
        if (System.getProperty(Constants.APPLICATION_KEY) != null) {
            application = application + "-" + System.getProperty(Constants.APPLICATION_KEY);
        }
    }
    // if not passed in, allow null app (app property won't be set)
    connect(address, port);
</td> </tr><tr><td>212</a></td> <td><a href="html/-1413930415.html">-1413930415</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>ce1a5b525e7b67ab216b383b66e3f32372cc0f69</td> <td>None</td> <td>TODO CG better errorHandling code here
no point in continuing</td> <td>SATD_ADDED</td> <td>fillEventIDArray(Connection, Statement)</td> <td> void fillEventIDArray(Connection connection, Statement insertStatement) throws SQLException</td> <td>
    // if (connectionSource.supportsGetGeneratedKeys()) {
    if (true) {
        ResultSet keyRS = insertStatement.getGeneratedKeys();
        ResultSetMetaData rsmd = keyRS.getMetaData();
        LogLog.info(" numberOfColumns = " + rsmd.getColumnCount());
        int i = 0;
        while (keyRS.next()) {
            int id = keyRS.getInt(1);
            LogLog.info("**filling id =" + id);
            eventIDArray[i++] = id;
            ;
        }
        if (i != eventsBuffer.size()) {
            LogLog.error("Number of inserted objects do not match.");
            // TODO CG better errorHandling code here
            // no point in continuing
            LogLog.error("number of found events: " + i + " bufferSize=" + eventsBuffer.size());
        // throw new IllegalStateException("Programming error. Number of inserted objects do not match.");
        }
    } else {
        Statement idStatement = connection.createStatement();
        idStatement.setMaxRows(1);
        ResultSet rs = idStatement.executeQuery(sqlDialect.getSelectInsertId());
        rs.first();
        eventIDArray[0] = rs.getInt(1);
    }
</td> </tr><tr><td>211</a></td> <td><a href="html/-1413930416.html">-1413930416</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>a06357e45797002cb00c6c23590b20f68665c149</td> <td>None</td> <td>TODO Work out WTF is going on with this PopupListener not being
picked up....
TODO Work out WTF is going on with the split pane and the setVisible
like it used to do in LogPanel</td> <td>SATD_ADDED</td> <td>shutdown()</td> <td>public void shutdown()</td> <td>
    if (fileSystemManager != null) {
        fileSystemManager.close();
    }
</td> </tr><tr><td>209</a></td> <td><a href="html/-1413930418.html">-1413930418</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>130b3181d10b8f89ee785ff0a0e608b9c3001ca3</td> <td>TODO CG The conversion of levelStr should be more general</td> <td>TODO CG The conversion of levelStr should be more general</td> <td>SATD_MOVED_FILE</td> <td>execute()</td> <td>public void execute()</td> <td>
    LogLog.info("DBReceiverJob.execute() called");
    Connection connection = null;
    try {
        Logger logger;
        LoggerRepository loggerRepository = parentDBReceiver.getLoggerRepository();
        connection = parentDBReceiver.connectionSource.getConnection();
        StringBuffer sql = new StringBuffer();
        sql.append("SELECT ");
        sql.append("sequence_number, ");
        sql.append("timestamp, ");
        sql.append("rendered_message, ");
        sql.append("logger_name, ");
        sql.append("level_string, ");
        sql.append("ndc, ");
        sql.append("thread_name, ");
        sql.append("reference_flag, ");
        sql.append("caller_filename, ");
        sql.append("caller_class, ");
        sql.append("caller_method, ");
        sql.append("caller_line, ");
        sql.append("event_id ");
        sql.append("FROM logging_event ");
        // have subsequent SELECTs start from we left off last time
        sql.append(" WHERE event_id > " + lastId);
        sql.append(" ORDER BY event_id ASC");
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery(sql.toString());
        rs.beforeFirst();
        while (rs.next()) {
            LoggingEvent event = new LoggingEvent();
            long id;
            event.setSequenceNumber(rs.getLong(1));
            event.setTimeStamp(rs.getLong(2));
            event.setRenderedMessage(rs.getString(3));
            event.setLoggerName(rs.getString(4));
            String levelStr = rs.getString(5);
            // TODO CG The conversion of levelStr should be more general
            Level level = Level.toLevel(levelStr);
            event.setLevel(level);
            event.setNDC(rs.getString(6));
            event.setThreadName(rs.getString(7));
            short mask = rs.getShort(8);
            String fileName = rs.getString(9);
            String className = rs.getString(10);
            String methodName = rs.getString(11);
            String lineNumber = rs.getString(12).trim();
            if (fileName.equals(LocationInfo.NA)) {
                event.setLocationInformation(LocationInfo.NA_LOCATION_INFO);
            } else {
                event.setLocationInformation(new LocationInfo(fileName, className, methodName, lineNumber));
            }
            id = rs.getLong(13);
            lastId = id;
            // Scott asked for this info to be
            event.setProperty(Constants.LOG4J_ID_KEY, Long.toString(id));
            if ((mask & DBHelper.PROPERTIES_EXIST) != 0) {
                getProperties(connection, id, event);
            }
            if ((mask & DBHelper.EXCEPTION_EXISTS) != 0) {
                getException(connection, id, event);
            }
            if (!parentDBReceiver.isPaused()) {
                parentDBReceiver.doPost(event);
            }
        }
        // while
        statement.close();
        statement = null;
    } catch (SQLException sqle) {
        LogLog.error("Problem receiving events", sqle);
    } finally {
        closeConnection(connection);
    }
</td> </tr><tr><td>208</a></td> <td><a href="html/-1413930419.html">-1413930419</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>131bc4d7010ed8aef9af2aa03839f8852f3d704d</td> <td>None</td> <td>TODO should all columns be sorted?  I think so...</td> <td>SATD_ADDED</td> <td>isSortable(int)</td> <td>public boolean isSortable(int col)</td> <td>
    // TODO should all columns be sorted?  I think so...
    return true;
</td> </tr><tr><td>207</a></td> <td><a href="html/-1413930422.html">-1413930422</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>131bc4d7010ed8aef9af2aa03839f8852f3d704d</td> <td>TODO format should come from a preference model</td> <td>// TODO format should come from a preference model</td> <td>SATD_CHANGED</td> <td>formatFileSize(double)</td> <td>private Object formatFileSize(double size)</td> <td>
    // // TODO format should come from a preference model
    if (size < 1024) {
        return nf.format(size);
    } else if (size < 1024 * 1024) {
        return nf.format((size / 1024)) + "kb";
    } else {
        return nf.format(size / (1024 * 1024)) + "Mb";
    }
</td> </tr><tr><td>206</a></td> <td><a href="html/-1413930420.html">-1413930420</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>e158902f9ab222b4ef4afc1fac5269d7f24fb1bd</td> <td>None</td> <td>TODO load the pref model from preference storage</td> <td>SATD_ADDED</td> <td>shutdown()</td> <td>public void shutdown()</td> <td>
    if (fileSystemManager != null) {
        fileSystemManager.close();
    }
</td> </tr><tr><td>205</a></td> <td><a href="html/-1413930421.html">-1413930421</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>e158902f9ab222b4ef4afc1fac5269d7f24fb1bd</td> <td>TODO replace this with an explicit call to pre-select the firs node in the tree, which
would then trigger the look for children</td> <td>Add the authors of the java.io.File class to the list of people to \"have a word\" with... This is ridiculous...</td> <td>SATD_REMOVED</td> <td>shutdown()</td> <td>public void shutdown()</td> <td>
    if (fileSystemManager != null) {
        fileSystemManager.close();
    }
</td> </tr><tr><td>204</a></td> <td><a href="html/-1413930421.html">-1413930421</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>ae5a19796d81ba878d522fa09787980f9924636e</td> <td>None</td> <td>TODO replace this with an explicit call to pre-select the firs node in the tree, which
would then trigger the look for children</td> <td>SATD_ADDED</td> <td>shutdown()</td> <td>public void shutdown()</td> <td>
    if (fileSystemManager != null) {
        fileSystemManager.close();
    }
</td> </tr><tr><td>202</a></td> <td><a href="html/-1413930422.html">-1413930422</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>654f33b2f16afa399586d0c69e0d0fd1665656db</td> <td>None</td> <td>TODO format should come from a preference model</td> <td>SATD_ADDED</td> <td>formatFileSize(double)</td> <td>private Object formatFileSize(double size)</td> <td>
    // TODO format should come from a preference model
    if (size < 1024) {
        return nf.format(size);
    } else if (size < 1024 * 1024) {
        return nf.format((size / 1024)) + "kb";
    } else {
        return nf.format(size / (1024 * 1024)) + "Mb";
    }
</td> </tr><tr><td>200</a></td> <td><a href="html/-1413930423.html">-1413930423</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>064c29a9f0666a465b3ca89808365d2d9aa86ed1</td> <td>None</td> <td>TODO feedback to the user about the error...</td> <td>SATD_ADDED</td> <td>lookForChildren(JTree, DefaultMutableTreeNode)</td> <td> static void lookForChildren(final JTree tree, final DefaultMutableTreeNode node)</td> <td>
    Object object = node.getUserObject();
    if (!(object instanceof VFSNode)) {
        return;
    }
    final VFSNode vfsNode = (VFSNode) object;
    Thread thread = new Thread(new BackgroundChildFileObjectPopulator(tree, node, vfsNode));
    thread.setPriority(Thread.MIN_PRIORITY);
    thread.start();
</td> </tr><tr><td>199</a></td> <td><a href="html/-1413930424.html">-1413930424</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>e95b32c28f38b2b41972ae0eb1cbb23cbdccdba4</td> <td>None</td> <td>TODO display name, but with Schema too</td> <td>SATD_ADDED</td> <td>toString()</td> <td>public String toString()</td> <td>
    // TODO display name, but with Schema too
    return getName();
</td> </tr><tr><td>198</a></td> <td><a href="html/-1413930425.html">-1413930425</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>5f1358759db4a4bb599f835af6a13afc21d9565e</td> <td>None</td> <td>TODO this should also be fixed up, as VFS bits and pieces might not be built in an Ant build when they don't have all the VFS jars local</td> <td>SATD_ADDED</td> <td>showSplash(Frame)</td> <td>private static final void showSplash(Frame owner)</td> <td>
    splash = new ChainsawSplash(owner);
    SwingHelper.centerOnScreen(splash);
    splash.setVisible(true);
</td> </tr><tr><td>197</a></td> <td><a href="html/-1413930426.html">-1413930426</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>e7a45e09af8c6312a340f607b1425453e5284d7d</td> <td>None</td> <td>TODO This seems really lame to have to do this, but there you go...</td> <td>SATD_ADDED</td> <td>determineSupportedFileSystems()</td> <td>private void determineSupportedFileSystems()</td> <td>
    // TODO This seems really lame to have to do this, but there you go...
    String[] schemes = new String[] { "file", "zip", "jar", "sftp", "http", "https", "ftp", "CIFS" };
    for (int i = 0; i < schemes.length; i++) {
        String scheme = schemes[i];
        try {
            if (fileSystemManager.hasProvider(scheme)) {
                supportedSchemes.add(scheme);
                LogLog.info("VFS scheme '" + scheme + "' supported");
            } else {
                LogLog.error("VFS scheme '" + scheme + "' NOT supported");
            }
        } catch (Exception e) {
            LogLog.error("Failed test for VFS scheme '" + scheme + "'", e);
        }
    }
</td> </tr><tr><td>196</a></td> <td><a href="html/-1413930427.html">-1413930427</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>d9e80a3a2136205e71d99ab93a27d8a83aa9b006</td> <td>None</td> <td>TODO CG Remove these commented out lines
/**
Alternate constructor to allow a string array to be passed in as the throwable.
/
public LoggingEvent(String fqnOfCategoryClass, Logger logger, long timeStamp, Level level, String threadName,</td> <td>SATD_ADDED</td> <td>equals(Object)</td> <td>public boolean equals(Object rObject)</td> <td>
    if (this == rObject) {
        return true;
    }
    if (!(rObject instanceof LoggingEvent)) {
        return false;
    }
    LoggingEvent rEvent = (LoggingEvent) rObject;
    if (timeStamp != rEvent.timeStamp) {
        return false;
    }
    if (sequenceNumber != rEvent.sequenceNumber) {
        return false;
    }
    // If both the timestamp and the sequenceNumber are equal than the objects
    // are assumed to be equal.
    return true;
</td> </tr><tr><td>195</a></td> <td><a href="html/-1413930428.html">-1413930428</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>42f1290ae7de2687560d1f850fd8dc21eb09d7f2</td> <td>None</td> <td>TODO CG The conversion of levelStr should be more general</td> <td>SATD_ADDED</td> <td>execute()</td> <td>public void execute()</td> <td>
    LogLog.info("in DBReceiverJob.execute()");
    try {
        Logger logger;
        LoggerRepository loggerRepository = getLoggerRepository();
        Connection connection = connectionSource.getConnection();
        StringBuffer sql = new StringBuffer();
        sql.append("SELECT sequence_number, timestamp, rendered_message, ");
        sql.append("logger_name, level_string, ndc, thread_name, ");
        sql.append("reference_flag, id from logging_event");
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery(sql.toString());
        rs.first();
        while (rs.next()) {
            LoggingEvent event = new LoggingEvent();
            long id;
            event.setSequenceNumber(rs.getLong(1));
            event.setTimeStamp(rs.getLong(2));
            event.setRenderedMessage(rs.getString(3));
            event.setLoggerName(rs.getString(4));
            String levelStr = rs.getString(5);
            // TODO CG The conversion of levelStr should be more general
            Level level = Level.toLevel(levelStr);
            event.setLevel(level);
            event.setNDC(rs.getString(6));
            event.setThreadName(rs.getString(7));
            short mask = rs.getShort(8);
            id = rs.getLong(9);
            // event.setProperty("id", Long.toString(id));
            if ((mask & DBHelper.PROPERTIES_EXIST) != 0) {
                getProperties(connection, id, event);
            }
            if ((mask & DBHelper.EXCEPTION_EXISTS) != 0) {
                getException(connection, id, event);
            }
            if (!DBReceiver.this.isPaused()) {
                DBReceiver.this.doPost(event);
            }
        }
    } catch (SQLException sqle) {
        LogLog.error("Problem receiving events", sqle);
    }
</td> </tr><tr><td>192</a></td> <td><a href="html/-1413930429.html">-1413930429</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>a1d858e57403bd741f7283451551370685f0aebc</td> <td>None</td> <td>TODO: the rest of the tests could be skipped and we could just return true.</td> <td>SATD_ADDED</td> <td>equals(Object)</td> <td>public boolean equals(Object rObject)</td> <td>
    if (this == rObject) {
        return true;
    }
    if (!(rObject instanceof LoggingEvent)) {
        return false;
    }
    LoggingEvent rEvent = (LoggingEvent) rObject;
    if (timeStamp != rEvent.timeStamp) {
        return false;
    }
    if (sequenceNumber != rEvent.sequenceNumber) {
        return false;
    }
    // TODO: the rest of the tests could be skipped and we could just return true.
    // level cannot be null
    if (level != rEvent.level) {
        return false;
    }
    // threadName can be null after all
    if (threadName == null) {
        if (rEvent.threadName != null) {
            return false;
        }
    } else if (!threadName.equals(rEvent.threadName)) {
        return false;
    }
    if (message == null) {
        if (rEvent.message != null) {
            return false;
        }
    } else if (!message.equals(rEvent.message)) {
        return false;
    }
    if (properties == null) {
        if (rEvent.message != null) {
            return false;
        }
    } else if (!properties.equals(rEvent.properties)) {
        return false;
    }
    if (mdcCopy == null) {
        if (rEvent.mdcCopy != null) {
            return false;
        }
    } else if (!mdcCopy.equals(rEvent.mdcCopy)) {
        return false;
    }
    if (ndc == null) {
        if (rEvent.ndc != null) {
            return false;
        }
    } else if (!ndc.equals(rEvent.ndc)) {
        return false;
    }
    if (throwableInfo == null) {
        if (rEvent.throwableInfo != null) {
            return false;
        }
    } else if (!throwableInfo.equals(rEvent.throwableInfo)) {
        return false;
    }
    if (locationInfo == null) {
        if (rEvent.locationInfo != null) {
            return false;
        }
    } else if (!locationInfo.equals(rEvent.locationInfo)) {
        return false;
    }
    // we can now safely assume that the two events are equal.
    return true;
</td> </tr><tr><td>190</a></td> <td><a href="html/-1413930430.html">-1413930430</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>23a7c94ac88ed1bc2311a317419e7485d6df3d47</td> <td>None</td> <td>threadName cannot be null in a properly constructed LoggingEvent</td> <td>SATD_ADDED</td> <td>equals(Object)</td> <td>public boolean equals(Object rObject)</td> <td>
    if (this == rObject) {
        return true;
    }
    if (!(rObject instanceof LoggingEvent)) {
        return false;
    }
    LoggingEvent rEvent = (LoggingEvent) rObject;
    // timeStamp cannot be null
    if (timeStamp != rEvent.timeStamp) {
        return false;
    }
    // level cannot be null
    if (level != rEvent.level) {
        return false;
    }
    // threadName cannot be null in a properly constructed LoggingEvent
    if (!threadName.equals(rEvent.threadName)) {
        return false;
    }
    if (message == null) {
        if (rEvent.message != null) {
            return false;
        }
    } else if (!message.equals(rEvent.message)) {
        return false;
    }
    if (properties == null) {
        if (rEvent.message != null) {
            return false;
        }
    } else if (!properties.equals(rEvent.properties)) {
        return false;
    }
    if (mdcCopy == null) {
        if (rEvent.mdcCopy != null) {
            return false;
        }
    } else if (!mdcCopy.equals(rEvent.mdcCopy)) {
        return false;
    }
    if (ndc == null) {
        if (rEvent.ndc != null) {
            return false;
        }
    } else if (!ndc.equals(rEvent.ndc)) {
        return false;
    }
    if (throwableInfo == null) {
        if (rEvent.throwableInfo != null) {
            return false;
        }
    } else if (!throwableInfo.equals(rEvent.throwableInfo)) {
        return false;
    }
    if (locationInfo == null) {
        if (rEvent.locationInfo != null) {
            return false;
        }
    } else if (!locationInfo.equals(rEvent.locationInfo)) {
        return false;
    }
    // we can now safely assume that the two events are equal.
    return true;
</td> </tr><tr><td>188</a></td> <td><a href="html/-1413930431.html">-1413930431</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2b1f10e3f71151e3dd89ef9e09abffc2b8928114</td> <td>None</td> <td>TODO think of good mnemonics and HotKey for this action</td> <td>SATD_ADDED</td> <td>createCustomExpressionPanelAction()</td> <td>private Action createCustomExpressionPanelAction()</td> <td>
    final JDialog dialog = new JDialog(logui, "Define tab", true);
    dialog.getContentPane().add(getCustomExpressionPanel());
    dialog.pack();
    Action createExpressionPanel = new AbstractAction("", ChainsawIcons.ICON_HELP) {

        public void actionPerformed(ActionEvent arg0) {
            dialog.setVisible(true);
        }
    };
    createExpressionPanel.putValue(Action.SHORT_DESCRIPTION, "Create custom expression LogPanel...");
    // TODO think of good mnemonics and HotKey for this action
    return createExpressionPanel;
</td> </tr><tr><td>184</a></td> <td><a href="html/-1413930433.html">-1413930433</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>dfef5e8d6b2f78dd78c24965b08356ce8d028d92</td> <td>None</td> <td>so, resource is not a URL:
attempt to get the resource from the class loader path
please read the javadocs for Loader.getResource for the exact
algorithm.</td> <td>SATD_ADDED</td> <td>getLoggerRepository()</td> <td>public LoggerRepository getLoggerRepository()</td> <td>
    String loggingContextName = null;
    Context ctx = null;
    try {
        ctx = new InitialContext();
        loggingContextName = (String) ctx.lookup(JNDI_CONTEXT_NAME);
    } catch (NamingException ne) {
        // we can't log here
        // debug minor issue in Tomcat5 where, after the first webapp install,
        // the second webapp first fails the JNDI lookup and Log4j reports that
        // "no appenders could be found".  Subsequent webapp installs report the
        // same except with no "no appenders could be found" message.  However,
        // the appender do indeed work so I'm not sure why it is reported that
        // they don't?  No issues like this in Tomcat4.
        // System.out.println("failed to look up logging context!");
        ;
    }
    if (loggingContextName == null) {
        return defaultRepository;
    } else {
        Hierarchy hierarchy = (Hierarchy) hierMap.get(loggingContextName);
        if (hierarchy == null) {
            // create new hierarchy
            hierarchy = new Hierarchy(new RootCategory(Level.DEBUG));
            hierMap.put(loggingContextName, hierarchy);
            // configure it
            try {
                String configResourceStr = (String) ctx.lookup(JNDI_CONFIGURATION_RESOURCE);
                URL url;
                try {
                    url = new URL(configResourceStr);
                } catch (MalformedURLException ex) {
                    // so, resource is not a URL:
                    // attempt to get the resource from the class loader path
                    // please read the javadocs for Loader.getResource for the exact
                    // algorithm.
                    url = Loader.getResource(configResourceStr);
                }
                // If we have a non-null url, then delegate the rest of the
                // configuration to the OptionConverter.selectAndConfigure
                // method.
                if (url != null) {
                    LogLog.debug("Using URL [" + url + "] for automatic log4j configuration.");
                    OptionConverter.selectAndConfigure(url, null, hierarchy);
                } else {
                    LogLog.debug("Could not find resources to perform automatic configuration.");
                }
            } catch (NamingException ne) {
            }
        }
        return hierarchy;
    }
</td> </tr><tr><td>183</a></td> <td><a href="html/-1413930434.html">-1413930434</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>765875de40b96ca5be0d2e96479a015dadd6a739</td> <td>None</td> <td>TODO this should all be in a config file</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>182</a></td> <td><a href="html/-1413930435.html">-1413930435</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>765875de40b96ca5be0d2e96479a015dadd6a739</td> <td>None</td> <td>TODO remove the plugin from the gui</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>179</a></td> <td><a href="html/-1413930437.html">-1413930437</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>f45056b1a7489b6273f5ff26664c6788f29244de</td> <td>None</td> <td>TODO: handle exception</td> <td>SATD_ADDED</td> <td>getHelpURL()</td> <td>public final URL getHelpURL()</td> <td>
    return helpURL;
</td> </tr><tr><td>178</a></td> <td><a href="html/-1413930438.html">-1413930438</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0d1bc03ceaf04880c70dfe06ede90da7603f683c</td> <td>None</td> <td>TODO Create a resource not found url</td> <td>SATD_ADDED</td> <td>showHelpForClass(Class)</td> <td>public void showHelpForClass(Class c)</td> <td>
    String name = c.getName();
    name = name.replace('.', '/');
    URL url = helpLocator.findResource(name);
    if (url != null) {
        setHelpURL(url);
    } else {
        // TODO Create a resource not found url
        setHelpURL(ChainsawConstants.WELCOME_URL);
    }
</td> </tr><tr><td>177</a></td> <td><a href="html/-1413930439.html">-1413930439</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0d1bc03ceaf04880c70dfe06ede90da7603f683c</td> <td>None</td> <td>TODO setup all the base URLs in the default.properties and configure in ApplicationPreferenceModel</td> <td>SATD_ADDED</td> <td>getHelpURL()</td> <td>public final URL getHelpURL()</td> <td>
    return helpURL;
</td> </tr><tr><td>175</a></td> <td><a href="html/-1413930440.html">-1413930440</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>bc50e850e3193f556c6c22631eb0fc54a64a9cbf</td> <td>None</td> <td>TODO This needs to convert the FQN class name into a valid help URL.
TODO Be also nice to be able to set a BaseHelpURL or something instead of hitting the Apache server.</td> <td>SATD_ADDED</td> <td>showHelpForClass(Class)</td> <td>public void showHelpForClass(Class class1)</td> <td>
    // TODO This needs to convert the FQN class name into a valid help URL.
    // TODO Be also nice to be able to set a BaseHelpURL or something instead of hitting the Apache server.
    setHelpURL(ChainsawConstants.WELCOME_URL);
</td> </tr><tr><td>172</a></td> <td><a href="html/-1413930441.html">-1413930441</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>52991087d7eb4a160d14f7d7193ae877777ff51a</td> <td>None</td> <td>TODO Determine if the property is one of the ones a User could edit</td> <td>SATD_ADDED</td> <td>isCellEditable(int, int)</td> <td>public boolean isCellEditable(int rowIndex, int columnIndex)</td> <td>
    // TODO Determine if the property is one of the ones a User could edit
    if (columnIndex == 1) {
        return descriptors[rowIndex].getWriteMethod() != null;
    }
    return false;
</td> </tr><tr><td>171</a></td> <td><a href="html/-1413930442.html">-1413930442</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>52991087d7eb4a160d14f7d7193ae877777ff51a</td> <td>None</td> <td>TODO: handle exception</td> <td>SATD_ADDED</td> <td>initComponents()</td> <td>private void initComponents()</td> <td>
    setPreferredSize(new Dimension(160, 120));
    setLayout(new BorderLayout());
    scrollPane.setViewportView(propertyTable);
    add(scrollPane, BorderLayout.CENTER);
    propertyTable.setModel(new DefaultTableModel());
    // TODO when all the correct CellEditors are in place, remove this line
    propertyTable.setEnabled(false);
</td> </tr><tr><td>170</a></td> <td><a href="html/-1413930443.html">-1413930443</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>52991087d7eb4a160d14f7d7193ae877777ff51a</td> <td>None</td> <td>TODO handle else condition</td> <td>SATD_ADDED</td> <td>initComponents()</td> <td>private void initComponents()</td> <td>
    setPreferredSize(new Dimension(160, 120));
    setLayout(new BorderLayout());
    scrollPane.setViewportView(propertyTable);
    add(scrollPane, BorderLayout.CENTER);
    propertyTable.setModel(new DefaultTableModel());
    // TODO when all the correct CellEditors are in place, remove this line
    propertyTable.setEnabled(false);
</td> </tr><tr><td>168</a></td> <td><a href="html/-1413930480.html">-1413930480</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d0b8b519f203349fb9a7cf9bee71e6499c05256e</td> <td>TODO enable this when it's ready.</td> <td>TODO enable this when it's ready.</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>167</a></td> <td><a href="html/-1413930445.html">-1413930445</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d0b8b519f203349fb9a7cf9bee71e6499c05256e</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>165</a></td> <td><a href="html/-1413930450.html">-1413930450</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d0b8b519f203349fb9a7cf9bee71e6499c05256e</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>164</a></td> <td><a href="html/-1413930452.html">-1413930452</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>742f8f847fcdd4a819fb239b516b5bef95d2be9b</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>FILE_PATH_CHANGED</td> <td>factor(int)</td> <td>public int[] factor(int number) throws RemoteException</td> <td>
    // The client's host is an important source of information.
    try {
        NDC.push(this.getClientHost());
    } catch (java.rmi.server.ServerNotActiveException e) {
        // we are being called from same VM
        NDC.push("localhost");
    }
    // The information contained within the request is another source of
    // distinctive information. It might reveal the users name, date of request,
    // request ID etc. In servlet type environments, much information is
    // contained in cookies.
    NDC.push(String.valueOf(number));
    cat.info("Beginning to factor.");
    if (number <= 0) {
        throw new IllegalArgumentException(number + " is not a positive integer.");
    } else if (number == 1)
        return new int[] { 1 };
    Vector factors = new Vector();
    int n = number;
    for (int i = 2; (i <= n) && (i * i <= number); i++) {
        // It is bad practice to place log requests within tight loops.
        // It is done here to show interleaved log output from
        // different requests.
        cat.debug("Trying to see if " + i + " is a factor.");
        if ((n % i) == 0) {
            cat.info("Found factor " + i);
            factors.addElement(new Integer(i));
            do {
                n /= i;
            } while ((n % i) == 0);
        }
        // Placing artificial delays in tight-loops will also lead to sub-optimal
        // resuts. :-)
        delay(100);
    }
    if (n != 1) {
        cat.info("Found factor " + n);
        factors.addElement(new Integer(n));
    }
    int len = factors.size();
    int[] result = new int[len];
    for (int i = 0; i < len; i++) {
        result[i] = ((Integer) factors.elementAt(i)).intValue();
    }
    // Before leaving a thread we call NDC.remove. This deletes the reference
    // to the thread in the internal hash table. Version 0.8.5 introduces a
    // a lazy removal mechanism in case you forget to call remove when
    // exiting a thread. See the java documentation in NDC.remove for further
    // details.
    NDC.remove();
    return result;
</td> </tr><tr><td>162</a></td> <td><a href="html/-1413930480.html">-1413930480</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>80a8f7cb4b321a762f0a292b9b49dbc30ac11c89</td> <td>TODO enable this when it's ready.</td> <td>TODO enable this when it's ready.</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>mouseMoved(MouseEvent)</td> <td>public void mouseMoved(MouseEvent e)</td> <td>
    // LogLog.debug(e.toString());
    if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0 && (e.getModifiers() & InputEvent.SHIFT_MASK) > 0) {
        logTree.setCursor(ignoreCursor);
    } else if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0) {
        logTree.setCursor(focusOnCursor);
    } else {
        logTree.setCursor(Cursor.getDefaultCursor());
    }
</td> </tr><tr><td>161</a></td> <td><a href="html/-1413930470.html">-1413930470</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>80a8f7cb4b321a762f0a292b9b49dbc30ac11c89</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>mouseMoved(MouseEvent)</td> <td>public void mouseMoved(MouseEvent e)</td> <td>
    // LogLog.debug(e.toString());
    if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0 && (e.getModifiers() & InputEvent.SHIFT_MASK) > 0) {
        logTree.setCursor(ignoreCursor);
    } else if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0) {
        logTree.setCursor(focusOnCursor);
    } else {
        logTree.setCursor(Cursor.getDefaultCursor());
    }
</td> </tr><tr><td>160</a></td> <td><a href="html/-1413930450.html">-1413930450</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>80a8f7cb4b321a762f0a292b9b49dbc30ac11c89</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>mouseMoved(MouseEvent)</td> <td>public void mouseMoved(MouseEvent e)</td> <td>
    // LogLog.debug(e.toString());
    if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0 && (e.getModifiers() & InputEvent.SHIFT_MASK) > 0) {
        logTree.setCursor(ignoreCursor);
    } else if ((e.getModifiers() & InputEvent.CTRL_MASK) > 0) {
        logTree.setCursor(focusOnCursor);
    } else {
        logTree.setCursor(Cursor.getDefaultCursor());
    }
</td> </tr><tr><td>158</a></td> <td><a href="html/-1413930447.html">-1413930447</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>dba2c03b6f2eb3ee5500e074eed9666183c0bdc7</td> <td>TODO: Replace the array list creating with the standard way of retreiving the Level set. (TBD)</td> <td>TODO: Replace the array list creating with the standard way of
retreiving the Level set. (TBD)</td> <td>SATD_CHANGED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>157</a></td> <td><a href="html/-1413930448.html">-1413930448</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>b89b60ad7d80a4c800f31f9b4088ebe81b699394</td> <td>None</td> <td>TODO: handle exception</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    String name = "";
    URL url = null;
    if (!remoteURL) {
        if (chooser == null) {
            chooser = new JFileChooser();
        }
        chooser.setDialogTitle("Load Events from XML file...");
        chooser.setAcceptAllFileFilterUsed(true);
        chooser.setFileFilter(new FileFilter() {

            public boolean accept(File f) {
                return (f.getName().toLowerCase().endsWith(".xml") || f.isDirectory());
            }

            public String getDescription() {
                return "XML files (*.xml)";
            }
        });
        chooser.showOpenDialog(parent);
        File selectedFile = chooser.getSelectedFile();
        try {
            url = selectedFile.toURL();
            name = "localhost:" + selectedFile.getName();
        } catch (Exception ex) {
        // TODO: handle exception
        }
    } else {
        String urltext = JOptionPane.showInputDialog(parent, "<html>Please type in the <b>complete</b> URL to the remote XML source.</html>", "file://");
        if (urltext != null) {
            try {
                url = new URL(urltext);
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(parent, "'" + urltext + "' is not a valid URL.");
            }
        }
    }
    if (url != null) {
        Map additionalProperties = new HashMap();
        additionalProperties.put(ChainsawConstants.LOG4J_MACHINE_KEY, name);
        decoder.setAdditionalProperties(additionalProperties);
        final URL urlToUse = url;
        new Thread(new Runnable() {

            public void run() {
                try {
                    Vector events = decoder.decode(urlToUse);
                    parent.handler.appendBatch(events);
                } catch (IOException e1) {
                    // TODO Handle the error with a nice msg
                    LOG.error(e1);
                }
            }
        }).start();
    }
</td> </tr><tr><td>156</a></td> <td><a href="html/-1413930449.html">-1413930449</td><td>apache/log4j</td><td>Scott Deboy</td><td>d2794a0aad70a514bae5e610777e99a027147780</td> <td>None</td> <td>TODO think of good mnemonics and HotKey for this action</td> <td>SATD_ADDED</td> <td>createShowColorPanelAction()</td> <td>private Action createShowColorPanelAction()</td> <td>
    Action showColorPanel = new AbstractAction("", ChainsawIcons.ICON_PREFERENCES) {

        public void actionPerformed(ActionEvent arg0) {
            LogPanel logPanel = logui.getCurrentLogPanel();
            if (logPanel != null) {
                logPanel.showColorPanel();
            }
        }
    };
    showColorPanel.putValue(Action.SHORT_DESCRIPTION, "LogPanel Color Filter...");
    // TODO think of good mnemonics and HotKey for this action
    return showColorPanel;
</td> </tr><tr><td>155</a></td> <td><a href="html/-1413930480.html">-1413930480</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d5acfe6eac395e6aef8dc2ef6d115f55d3b67526</td> <td>TODO enable this when it's ready.</td> <td>TODO enable this when it's ready.</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>154</a></td> <td><a href="html/-1413930470.html">-1413930470</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d5acfe6eac395e6aef8dc2ef6d115f55d3b67526</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>153</a></td> <td><a href="html/-1413930450.html">-1413930450</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d5acfe6eac395e6aef8dc2ef6d115f55d3b67526</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>evaluate(LoggingEvent)</td> <td>public boolean evaluate(LoggingEvent e)</td> <td>
    return true;
</td> </tr><tr><td>151</a></td> <td><a href="html/-1413930451.html">-1413930451</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>39252aa23f50ea749df34532c1f975aab8f2ea65</td> <td>None</td> <td>TODO check the model if this is selected</td> <td>SATD_ADDED</td> <td>getListCellRendererComponent(JList, Object, int, boolean, boolean)</td> <td>public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus)</td> <td>
    setText(value.toString());
    setBackground(isSelected ? list.getSelectionBackground() : list.getBackground());
    setForeground(isSelected ? list.getSelectionForeground() : list.getForeground());
    setFont(list.getFont());
    setBorder(cellHasFocus ? UIManager.getBorder("List.focusCellHighlightBorder") : noFocusBorder);
    // TODO check the model if this is selected
    return this;
</td> </tr><tr><td>148</a></td> <td><a href="html/-1413930452.html">-1413930452</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>49c9ac1f4169000f90dc0b7710f61278aa717ed7</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>FILE_PATH_CHANGED</td> <td>factor(int)</td> <td>public int[] factor(int number) throws RemoteException</td> <td>
    // The client's host is an important source of information.
    try {
        NDC.push(this.getClientHost());
    } catch (java.rmi.server.ServerNotActiveException e) {
        // we are being called from same VM
        NDC.push("localhost");
    }
    // The information contained within the request is another source of
    // distinctive information. It might reveal the users name, date of request,
    // request ID etc. In servlet type environments, much information is
    // contained in cookies.
    NDC.push(String.valueOf(number));
    cat.info("Beginning to factor.");
    if (number <= 0) {
        throw new IllegalArgumentException(number + " is not a positive integer.");
    } else if (number == 1)
        return new int[] { 1 };
    Vector factors = new Vector();
    int n = number;
    for (int i = 2; (i <= n) && (i * i <= number); i++) {
        // It is bad practice to place log requests within tight loops.
        // It is done here to show interleaved log output from
        // different requests.
        cat.debug("Trying to see if " + i + " is a factor.");
        if ((n % i) == 0) {
            cat.info("Found factor " + i);
            factors.addElement(new Integer(i));
            do {
                n /= i;
            } while ((n % i) == 0);
        }
        // Placing artificial delays in tight-loops will also lead to sub-optimal
        // resuts. :-)
        delay(100);
    }
    if (n != 1) {
        cat.info("Found factor " + n);
        factors.addElement(new Integer(n));
    }
    int len = factors.size();
    int[] result = new int[len];
    for (int i = 0; i < len; i++) {
        result[i] = ((Integer) factors.elementAt(i)).intValue();
    }
    // Before leaving a thread we call NDC.remove. This deletes the reference
    // to the thread in the internal hash table. Version 0.8.5 introduces a
    // a lazy removal mechanism in case you forget to call remove when
    // exiting a thread. See the java documentation in NDC.remove for further
    // details.
    NDC.remove();
    return result;
</td> </tr><tr><td>145</a></td> <td><a href="html/-1413930453.html">-1413930453</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>554511eabc7fa964de70990882050bdd4ed73b5e</td> <td>None</td> <td>TODO undocked toolbar is broken
f.getContentPane().add(</td> <td>SATD_ADDED</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>144</a></td> <td><a href="html/-1413930454.html">-1413930454</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>554511eabc7fa964de70990882050bdd4ed73b5e</td> <td>None</td> <td>TODO fix this menu so that columns can be hidden/displayed</td> <td>SATD_ADDED</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>140</a></td> <td><a href="html/-1413930455.html">-1413930455</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO MDC event stuff is not being output correctly</td> <td>TODO MDC event stuff is not being output correctly</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>139</a></td> <td><a href="html/-1413930456.html">-1413930456</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO fix up this Set Cast-O-Rama
also add it to the unique values list</td> <td>TODO fix up this Set Cast-O-Rama
also add it to the unique values list</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>138</a></td> <td><a href="html/-1413930457.html">-1413930457</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO Rest of the load settings</td> <td>TODO Rest of the load settings</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>137</a></td> <td><a href="html/-1413930458.html">-1413930458</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO save display rule settings</td> <td>TODO save display rule settings</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>136</a></td> <td><a href="html/-1413930459.html">-1413930459</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO more Rule implementation here.
displayFilter.setCustomFilter(
new DisplayFilterEntry(
(String) customFilterList.getSelectedItem(),</td> <td>TODO more Rule implementation here.
displayFilter.setCustomFilter(
new DisplayFilterEntry(
(String) customFilterList.getSelectedItem(),</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>135</a></td> <td><a href="html/-1413930460.html">-1413930460</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO Display rule stuff</td> <td>TODO Display rule stuff</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>134</a></td> <td><a href="html/-1413930461.html">-1413930461</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>HACK - fix the way columns are sized..should be saved off and loaded later</td> <td>HACK - fix the way columns are sized..should be saved off and loaded later</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>133</a></td> <td><a href="html/-1413930462.html">-1413930462</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO refactor so that LogPanel itself knows if Tooltips are enabled</td> <td>TODO refactor so that LogPanel itself knows if Tooltips are enabled</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>132</a></td> <td><a href="html/-1413930463.html">-1413930463</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0cc749b722a851cd985cfaa98c143c9535355ff5</td> <td>TODO reload new Display rule for this panel</td> <td>TODO reload new Display rule for this panel</td> <td>SATD_MOVED_FILE</td> <td>newKeyAdded(NewKeyEvent)</td> <td>public void newKeyAdded(NewKeyEvent e)</td> <td>
    table.addColumn(new TableColumn(e.getNewModelIndex()));
</td> </tr><tr><td>131</a></td> <td><a href="html/-1413930464.html">-1413930464</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>3fd8fbc941ca5c9a9c2cc62361516784b54ff72d</td> <td>None</td> <td>TODO save display rule settings</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>130</a></td> <td><a href="html/-1413930465.html">-1413930465</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>3fd8fbc941ca5c9a9c2cc62361516784b54ff72d</td> <td>None</td> <td>TODO more Rule implementation here.
displayFilter.setCustomFilter(
new DisplayFilterEntry(
(String) customFilterList.getSelectedItem(),</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>129</a></td> <td><a href="html/-1413930466.html">-1413930466</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>3fd8fbc941ca5c9a9c2cc62361516784b54ff72d</td> <td>None</td> <td>TODO Display rule stuff</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>128</a></td> <td><a href="html/-1413930467.html">-1413930467</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>3fd8fbc941ca5c9a9c2cc62361516784b54ff72d</td> <td>None</td> <td>TODO refactor so that LogPanel itself knows if Tooltips are enabled</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>127</a></td> <td><a href="html/-1413930468.html">-1413930468</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>3fd8fbc941ca5c9a9c2cc62361516784b54ff72d</td> <td>None</td> <td>TODO reload new Display rule for this panel</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>123</a></td> <td><a href="html/-1413930469.html">-1413930469</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d41228cc95ab66bc19e91207f2093bd6cbfd09dc</td> <td>None</td> <td>TODO not everything catered for here yet...</td> <td>SATD_ADDED</td> <td>compare(Object, Object)</td> <td>public int compare(Object o1, Object o2)</td> <td>
    int sort = 1;
    if (o1 instanceof LoggingEvent && o2 instanceof LoggingEvent) {
        // TODO not everything catered for here yet...
        LoggingEvent e1 = (LoggingEvent) o1;
        LoggingEvent e2 = (LoggingEvent) o2;
        switch(index + 1) {
            case ChainsawColumns.INDEX_LEVEL_COL_NAME:
                sort = e1.getLevel().isGreaterOrEqual(e2.getLevel()) ? 1 : (-1);
                break;
            case ChainsawColumns.INDEX_LOGGER_COL_NAME:
                sort = e1.getLoggerName().compareToIgnoreCase(e2.getLoggerName());
                break;
            case ChainsawColumns.INDEX_MESSAGE_COL_NAME:
                sort = e1.getMessage().toString().compareToIgnoreCase(e2.getMessage().toString());
                break;
            case ChainsawColumns.INDEX_METHOD_COL_NAME:
                if ((e1.getLocationInformation() != null) & (e2.getLocationInformation() != null)) {
                    sort = e1.getLocationInformation().getMethodName().compareToIgnoreCase(e2.getLocationInformation().getMethodName());
                }
                break;
            case ChainsawColumns.INDEX_CLASS_COL_NAME:
                if ((e1.getLocationInformation() != null) & (e2.getLocationInformation() != null)) {
                    sort = e1.getLocationInformation().getClassName().compareToIgnoreCase(e2.getLocationInformation().getClassName());
                }
                break;
            case ChainsawColumns.INDEX_FILE_COL_NAME:
                if ((e1.getLocationInformation() != null) & (e2.getLocationInformation() != null)) {
                    sort = e1.getLocationInformation().getFileName().compareToIgnoreCase(e2.getLocationInformation().getFileName());
                }
                break;
            case ChainsawColumns.INDEX_TIMESTAMP_COL_NAME:
                sort = (e1.timeStamp < e2.timeStamp ? -1 : (e1.timeStamp == e2.timeStamp ? 0 : 1));
                break;
            case ChainsawColumns.INDEX_THREAD_COL_NAME:
                sort = e1.getThreadName().compareToIgnoreCase(e2.getThreadName());
                break;
        }
    }
    sort = (sort == 0) ? 0 : ((sort < 0) ? (-1) : 1);
    if (!ascending && (sort != 0)) {
        sort = (sort < 0) ? 1 : (-1);
    }
    return sort;
</td> </tr><tr><td>122</a></td> <td><a href="html/-1413930470.html">-1413930470</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>b56782ec09ea8920cb29159209db175d6ee1ba29</td> <td>None</td> <td>need to ensure the button doens't update itself with the text, looks stupid otherwise</td> <td>SATD_ADDED</td> <td>getToolTipText(MouseEvent)</td> <td>public String getToolTipText(MouseEvent ev)</td> <td>
    if (ev == null) {
        return null;
    }
    TreePath path = logTree.getPathForLocation(ev.getX(), ev.getY());
    return getLoggerName(path);
</td> </tr><tr><td>120</a></td> <td><a href="html/-1413930472.html">-1413930472</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0f5f5baf2d50a23710365d884520a4861df4b9b7</td> <td>None</td> <td>TODO MDC event stuff is not being output correctly</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>119</a></td> <td><a href="html/-1413930473.html">-1413930473</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0f5f5baf2d50a23710365d884520a4861df4b9b7</td> <td>None</td> <td>TODO fix up this Set Cast-O-Rama
also add it to the unique values list</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>118</a></td> <td><a href="html/-1413930474.html">-1413930474</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0f5f5baf2d50a23710365d884520a4861df4b9b7</td> <td>None</td> <td>TODO remove this when ready</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    System.exit(0);
</td> </tr><tr><td>116</a></td> <td><a href="html/-1413930476.html">-1413930476</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>1672b02eb269209e396ac6db0d5f8cb5454397b7</td> <td>None</td> <td>TODO this is broken while the change from Vectors -> LoggingEvents occurs</td> <td>SATD_ADDED</td> <td>addFilterChangedListener(FilterChangedListener)</td> <td>public void addFilterChangedListener(FilterChangedListener listener)</td> <td>
    filterListeners.add(listener);
</td> </tr><tr><td>115</a></td> <td><a href="html/-1413930477.html">-1413930477</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>c554e534361610b689c2cb81c5492901e948c964</td> <td>None</td> <td>TODO change when filtering refactor done.</td> <td>SATD_ADDED</td> <td>run()</td> <td>public void run()</td> <td>
    synchronized (syncLock) {
        // TODO change when filtering refactor done.
        if (displayFilter != null) {
            filteredList.clear();
            Vector v2 = null;
            Iterator iter = unfilteredList.iterator();
            while (iter.hasNext()) {
                v2 = (Vector) iter.next();
                if (displayFilter.isDisplayed(v2)) {
                    filteredList.add(v2);
                }
            }
        }
        if (sortEnabled) {
            sort();
        }
    }
    fireTableDataChanged();
    notifyCountListeners();
</td> </tr><tr><td>114</a></td> <td><a href="html/-1413930478.html">-1413930478</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>c554e534361610b689c2cb81c5492901e948c964</td> <td>None</td> <td>TODO hook up the new display filter stuff once converted</td> <td>SATD_ADDED</td> <td>removeLoggerNameListener(LoggerNameListener)</td> <td>public void removeLoggerNameListener(LoggerNameListener l)</td> <td>
    loggerNameModelDelegate.removeLoggerNameListener(l);
</td> </tr><tr><td>113</a></td> <td><a href="html/-1413930479.html">-1413930479</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>c554e534361610b689c2cb81c5492901e948c964</td> <td>None</td> <td>TODO DO we need this method, I can find no references anywhere, but
left as is since it's such a large method....</td> <td>SATD_ADDED</td> <td>removeLoggerNameListener(LoggerNameListener)</td> <td>public void removeLoggerNameListener(LoggerNameListener l)</td> <td>
    loggerNameModelDelegate.removeLoggerNameListener(l);
</td> </tr><tr><td>112</a></td> <td><a href="html/-1413930480.html">-1413930480</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>6a9f2bdf4e3c8882aea9ddbbbb3ba60b6c825d05</td> <td>None</td> <td>TODO enable this when it's ready.</td> <td>SATD_ADDED</td> <td>getToolTipText(MouseEvent)</td> <td>public String getToolTipText(MouseEvent ev)</td> <td>
    if (ev == null) {
        return null;
    }
    TreePath path = logTree.getPathForLocation(ev.getX(), ev.getY());
    if (path != null) {
        Object[] objects = path.getPath();
        StringBuffer buf = new StringBuffer();
        for (int i = 1; i < objects.length; i++) {
            buf.append(objects[i].toString());
            if (i < (objects.length - 1)) {
                buf.append(".");
            }
        }
        // TODO output the Level filter details
        return buf.toString();
    }
    return null;
</td> </tr><tr><td>110</a></td> <td><a href="html/-1413930481.html">-1413930481</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>7bb51aa12cb6f6db2b152a5c83783aba4048d64b</td> <td>None</td> <td>TODO add accelerator to this action</td> <td>SATD_ADDED</td> <td>createToolbar()</td> <td>private void createToolbar()</td> <td>
    Insets buttonMargins = new Insets(1, 1, 1, 1);
    FileMenu fileMenu = (FileMenu) menuBar.getMenu(0);
    JButton fileOpenButton = new SmallButton(fileMenu.getLog4JFileOpenAction());
    fileOpenButton.setMargin(buttonMargins);
    JButton fileSaveButton = new SmallButton(fileMenu.getFileSaveAction());
    fileSaveButton.setMargin(buttonMargins);
    fileOpenButton.setText("");
    fileSaveButton.setText("");
    toolbar.add(fileOpenButton);
    toolbar.add(fileSaveButton);
    toolbar.addSeparator();
    pauseButton.setAction(pauseAction);
    pauseButton.setText("");
    // pauseButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke("F12"),pauseAction.getValue(Action.NAME) );
    pauseButton.getActionMap().put(pauseAction.getValue(Action.NAME), pauseAction);
    detailPaneButton.setAction(toggleDetailPaneAction);
    detailPaneButton.setText("");
    detailPaneButton.getActionMap().put(toggleDetailPaneAction.getValue(Action.NAME), toggleDetailPaneAction);
    detailPaneButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_D, InputEvent.ALT_MASK), toggleDetailPaneAction.getValue(Action.NAME));
    logTreePaneButton.setAction(toggleLogTreeAction);
    // logTreePaneButton.setText(null);
    // TODO add accelerator to this action
    SmallButton prefsButton = new SmallButton(showPreferencesAction);
    SmallButton undockButton = new SmallButton(undockAction);
    undockButton.setText("");
    toolbar.add(undockButton);
    toolbar.add(pauseButton);
    toolbar.add(detailPaneButton);
    toolbar.add(logTreePaneButton);
    toolbar.add(prefsButton);
    toolbar.addSeparator();
    toolbar.add(clearButton);
    clearButton.setAction(clearAction);
    clearButton.setText("");
    toolbar.addSeparator();
    JButton findNextButton = new SmallButton(findNextAction);
    findNextButton.setText("");
    findNextButton.getActionMap().put(findNextAction.getValue(Action.NAME), findNextAction);
    findNextButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put((KeyStroke) findNextAction.getValue(Action.ACCELERATOR_KEY), findNextAction.getValue(Action.NAME));
    toolbar.add(findNextButton);
    Box findBox = Box.createHorizontalBox();
    findBox.add(findTextField);
    toolbar.add(findBox);
    toolbar.addSeparator();
    toolbar.add(showReceiversButton);
    toolbar.add(Box.createHorizontalGlue());
    toolbar.setMargin(buttonMargins);
    toolbar.setFloatable(false);
</td> </tr><tr><td>109</a></td> <td><a href="html/-1413930482.html">-1413930482</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>7bb51aa12cb6f6db2b152a5c83783aba4048d64b</td> <td>None</td> <td>TODO find an icon</td> <td>SATD_ADDED</td> <td>createToggleLogTreeAction()</td> <td>private Action createToggleLogTreeAction()</td> <td>
    Action action = new AbstractAction() {

        public void actionPerformed(ActionEvent e) {
            if (logui.getCurrentLogPanel() != null) {
                logui.getCurrentLogPanel().toggleLogTreePanel();
            }
        }
    };
    action.putValue(Action.NAME, "Logger Tree");
    action.putValue(Action.SHORT_DESCRIPTION, "Toggles the Log Tree panel");
    // TODO find an icon
    return action;
</td> </tr><tr><td>108</a></td> <td><a href="html/-1413930483.html">-1413930483</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0911f32d76f0c1e9bcb752a9a67dc3c6afb18155</td> <td>None</td> <td>TODO decide if Multi-selection is useful, and how it would work</td> <td>SATD_ADDED</td> <td>setupListeners()</td> <td>private void setupListeners()</td> <td>
    /**
     * Enable the actions depending on state of the tree selection
     */
    logTree.addTreeSelectionListener(new TreeSelectionListener() {

        public void valueChanged(TreeSelectionEvent e) {
            TreePath path = e.getNewLeadSelectionPath();
            expandAction.setEnabled(path != null);
        }
    });
    /**
     * Now add a MouseListener that fires the expansion
     * action if CTRL + DBL CLICK is done.
     */
    logTree.addMouseListener(new MouseAdapter() {

        public void mouseClicked(MouseEvent e) {
            super.mouseClicked(e);
            if ((e.getClickCount() > 1) && ((e.getModifiers() & InputEvent.CTRL_MASK) > 0) && ((e.getModifiers() & InputEvent.BUTTON1_MASK) > 0)) {
                expandCurrentlySelectedNode();
            }
        }
    });
</td> </tr><tr><td>107</a></td> <td><a href="html/-1413930484.html">-1413930484</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>0911f32d76f0c1e9bcb752a9a67dc3c6afb18155</td> <td>None</td> <td>TODO output the Level filter details</td> <td>SATD_ADDED</td> <td>getToolTipText(MouseEvent)</td> <td>public String getToolTipText(MouseEvent ev)</td> <td>
    if (ev == null) {
        return null;
    }
    TreePath path = logTree.getPathForLocation(ev.getX(), ev.getY());
    if (path != null) {
        Object[] objects = path.getPath();
        StringBuffer buf = new StringBuffer();
        for (int i = 1; i < objects.length; i++) {
            buf.append(objects[i].toString());
            if (i < (objects.length - 1)) {
                buf.append(".");
            }
        }
        // TODO output the Level filter details
        return buf.toString();
    }
    return null;
</td> </tr><tr><td>106</a></td> <td><a href="html/-1413930485.html">-1413930485</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>c407235586ee9631fe2b3c3651e9c41991ccea18</td> <td>None</td> <td>============================================
TODO remove this WIP node once we're statisfied</td> <td>SATD_ADDED</td> <td>treeNodesChanged(TreeModelEvent)</td> <td>public void treeNodesChanged(TreeModelEvent e)</td> <td>
    ensureRootExpanded();
</td> </tr><tr><td>101</a></td> <td><a href="html/-1413930489.html">-1413930489</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>b8be4e137ab331abcbf7112ccacd3cd2328a99d3</td> <td>None</td> <td>TODO close this dialog(?) and use the file open action</td> <td>SATD_ADDED</td> <td>initComponents()</td> <td>private void initComponents()</td> <td>
    setLayout(new GridBagLayout());
    GridBagConstraints gc = new GridBagConstraints();
    // setBackground(Color.white);
    setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));
    gc.gridx = 1;
    gc.fill = gc.BOTH;
    gc.weightx = 1.0;
    gc.weighty = 1.0;
    JTextArea label = new JTextArea("You have no Receivers defined.\n\nYou will not be able to receive events from a Remote source unless you define one in the Log4J configuration file.\n");
    label.setWrapStyleWord(true);
    label.setLineWrap(true);
    label.setEditable(false);
    label.setOpaque(false);
    add(label, gc);
    gc.weightx = 0;
    gc.weighty = 0;
    gc.gridy = 2;
    add(Box.createVerticalStrut(20), gc);
    JPanel optionpanel = new JPanel();
    optionpanel.setLayout(new GridLayout(3, 1, 3, 3));
    optionpanel.setBackground(getBackground());
    optionpanel.setBorder(BorderFactory.createEtchedBorder());
    final ButtonGroup optionGroup = new ButtonGroup();
    final JRadioButton searchOption = new JRadioButton("Let me locate a config file", false);
    searchOption.setToolTipText("Allows you to choose a Log4J Configuration file that contains Receiver definitions");
    final JRadioButton manualOption = new JRadioButton("Let me define Receivers manually");
    manualOption.setToolTipText("Opens the Receivers panel so you can define them via a GUI");
    final JRadioButton justLoadingFile = new JRadioButton("Let me load a Log4j Log file");
    justLoadingFile.setToolTipText("Use this if you just want to view a Log4J Log file stored somewhere");
    searchOption.setOpaque(false);
    manualOption.setOpaque(false);
    justLoadingFile.setOpaque(false);
    optionGroup.add(searchOption);
    optionGroup.add(manualOption);
    optionGroup.add(justLoadingFile);
    gc.gridy = 3;
    String[] items = new String[] { "", "c:\\blah\blah.xml", "file:///var/doobie/blah/blah.xml" };
    final JComboBox previousConfigs = new JComboBox(items);
    previousConfigs.setOpaque(false);
    previousConfigs.setBackground(getBackground());
    previousConfigs.setToolTipText("Previously loaded configurations can be chosen here");
    final JButton searchButton = new JButton(new AbstractAction("...") {

        public void actionPerformed(ActionEvent e) {
        // TODO close this dialog(?) and use the file open action
        }
    });
    searchButton.setToolTipText("Shows a File Open dialog to allow you to find a config file");
    ActionListener al = new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            previousConfigs.setEnabled(e.getSource() == searchOption);
            searchButton.setEnabled(e.getSource() == searchOption);
        }
    };
    searchOption.addActionListener(al);
    manualOption.addActionListener(al);
    justLoadingFile.addActionListener(al);
    justLoadingFile.doClick();
    JPanel searchOptionPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
    searchOptionPanel.setOpaque(false);
    searchOptionPanel.add(searchOption);
    searchOptionPanel.add(Box.createHorizontalStrut(5));
    searchOptionPanel.add(previousConfigs);
    searchOptionPanel.add(Box.createHorizontalStrut(5));
    searchOptionPanel.add(searchButton);
    optionpanel.add(justLoadingFile);
    optionpanel.add(searchOptionPanel);
    optionpanel.add(manualOption);
    add(optionpanel, gc);
    final JButton okButton = new JButton(new AbstractAction("Ok") {

        public void actionPerformed(ActionEvent e) {
        // TODO Auto-generated method stub
        }
    });
    gc.gridy = gc.RELATIVE;
    gc.weightx = 0;
    gc.fill = gc.NONE;
    gc.anchor = gc.SOUTHEAST;
    add(Box.createVerticalStrut(20), gc);
    add(okButton, gc);
</td> </tr><tr><td>99</a></td> <td><a href="html/-1413930490.html">-1413930490</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>679aa15746508e08c36a7b2e32463c8096a6a9b5</td> <td>None</td> <td>TODO handle if they don't choose a file</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>98</a></td> <td><a href="html/-1413930491.html">-1413930491</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>679aa15746508e08c36a7b2e32463c8096a6a9b5</td> <td>None</td> <td>TODO search for Log4j config</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>97</a></td> <td><a href="html/-1413930492.html">-1413930492</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>679aa15746508e08c36a7b2e32463c8096a6a9b5</td> <td>None</td> <td>TODO This could be done and look better in a custom Dialog</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>96</a></td> <td><a href="html/-1413930493.html">-1413930493</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>679aa15746508e08c36a7b2e32463c8096a6a9b5</td> <td>TODO ensure the Welcome Panel is the selected tab</td> <td>TODO ensure the Welcome Panel is the selected tab</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>94</a></td> <td><a href="html/-1413930494.html">-1413930494</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>854386cc3811cfc5845672469d0b681dbac490b5</td> <td>None</td> <td>TODO ensure the Welcome Panel is the selected tab</td> <td>SATD_ADDED</td> <td>showHelp(URL)</td> <td> void showHelp(URL url)</td> <td>
    removeWelcomePanel();
    addWelcomePanel();
    // TODO ensure the Welcome Panel is the selected tab
    WelcomePanel.getInstance().setURL(url);
</td> </tr><tr><td>91</a></td> <td><a href="html/-1413930496.html">-1413930496</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO Handle the error with a nice msg</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    if (chooser == null) {
        chooser = new JFileChooser();
    }
    chooser.setDialogTitle("Load Events from XML file...");
    chooser.setAcceptAllFileFilterUsed(true);
    chooser.setFileFilter(new FileFilter() {

        public boolean accept(File f) {
            return f.getName().toLowerCase().endsWith(".xml");
        }

        public String getDescription() {
            return "XML files (*.xml)";
        }
    });
    chooser.showOpenDialog(parent);
    File selectedFile = chooser.getSelectedFile();
    if (selectedFile != null) {
        Map additionalProperties = new HashMap();
        additionalProperties.put(ChainsawConstants.LOG4J_MACHINE_KEY, "localhost:" + selectedFile.getName());
        decoder.setAdditionalProperties(additionalProperties);
        try {
            Vector events = decoder.decode(selectedFile);
            parent.handler.appendBatch(events);
        } catch (IOException e1) {
            // TODO Handle the error with a nice msg
            e1.printStackTrace();
        }
    }
</td> </tr><tr><td>90</a></td> <td><a href="html/-1413930497.html">-1413930497</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO refactor to use a single getEvent(row) call, and use a Formatter interface for pluggable formatting</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>89</a></td> <td><a href="html/-1413930498.html">-1413930498</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO Rest of the load settings</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>88</a></td> <td><a href="html/-1413930499.html">-1413930499</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>HACK - fix the way columns are sized..should be saved off and loaded later</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>87</a></td> <td><a href="html/-1413930495.html">-1413930495</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>d0f25ee6b1f27298af8d3474d41d5e2f45dfe342</td> <td>None</td> <td>TODO put the text about Socket Receiver in a Resource Bundle</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    newReceiverPopup.show(buttonPanel.newReceiverButton, 0, buttonPanel.newReceiverButton.getHeight());
</td> </tr><tr><td>86</a></td> <td><a href="html/-1413930500.html">-1413930500</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO Ask the user if they want to save the settings via a dialog.</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>85</a></td> <td><a href="html/-1413930501.html">-1413930501</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO should also tidy up any other references to things... Might need to be able to recover this pane again...</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>84</a></td> <td><a href="html/-1413930502.html">-1413930502</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO: Replace the array list creating with the standard way of retreiving the Level set. (TBD)</td> <td>SATD_ADDED</td> <td>showSplash()</td> <td>private static final void showSplash()</td> <td>
    splash = new ChainsawSplash();
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    splash.setLocation((screenSize.width / 2) - (splash.getWidth() / 2), (screenSize.height / 2) - (splash.getHeight() / 2));
    splash.setVisible(true);
</td> </tr><tr><td>83</a></td> <td><a href="html/-1413930503.html">-1413930503</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO insert the appropriate text</td> <td>SATD_ADDED</td> <td>actionPerformed(ActionEvent)</td> <td>public void actionPerformed(ActionEvent e)</td> <td>
    setVisible(false);
</td> </tr><tr><td>82</a></td> <td><a href="html/-1413930504.html">-1413930504</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO think of some mnemonics and HotKeys for this action</td> <td>SATD_ADDED</td> <td>createUndockAction()</td> <td>private Action createUndockAction()</td> <td>
    Action action = new AbstractAction("Undock", ChainsawIcons.ICON_UNDOCK) {

        public void actionPerformed(ActionEvent arg0) {
            LogUI.LogPanel logPanel = logui.getCurrentLogPanel();
            if (logPanel != null) {
                logPanel.undock();
            }
        }
    };
    action.putValue(Action.SHORT_DESCRIPTION, "Undocks the current Log panel into it's own window");
    // TODO think of some mnemonics and HotKeys for this action
    return action;
</td> </tr><tr><td>81</a></td> <td><a href="html/-1413930505.html">-1413930505</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO think of good mnemonics and HotKey for this action</td> <td>SATD_ADDED</td> <td>createShowPreferencesAction()</td> <td>private Action createShowPreferencesAction()</td> <td>
    Action showPreferences = new AbstractAction("", ChainsawIcons.ICON_PREFERENCES) {

        public void actionPerformed(ActionEvent arg0) {
            LogUI.LogPanel logPanel = logui.getCurrentLogPanel();
            if (logPanel != null) {
                logPanel.showPreferences();
            }
        }
    };
    showPreferences.putValue(Action.SHORT_DESCRIPTION, "Define display and color filters...");
    // TODO think of good mnemonics and HotKey for this action
    return showPreferences;
</td> </tr><tr><td>80</a></td> <td><a href="html/-1413930506.html">-1413930506</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>e932b0f81efea5a6372513e317a4e753c8335ed2</td> <td>None</td> <td>TODO and maybe play a sound?</td> <td>SATD_ADDED</td> <td>remoteConnectionReceived(String)</td> <td> void remoteConnectionReceived(String source)</td> <td>
    lastReceivedConnection = System.currentTimeMillis();
    setMessage("Connection received from " + source);
    connectionThread.interrupt();
// TODO and maybe play a sound?
</td> </tr><tr><td>77</a></td> <td><a href="html/-1413930508.html">-1413930508</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>ad3450477a77a963b46c8c563e7c857e85a994ce</td> <td>None</td> <td>TODO handle active/inactive</td> <td>SATD_ADDED</td> <td>isActive()</td> <td>public boolean isActive()</td> <td>
    // TODO handle active/inactive
    return true;
</td> </tr><tr><td>76</a></td> <td><a href="html/-1413930509.html">-1413930509</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>ad3450477a77a963b46c8c563e7c857e85a994ce</td> <td>None</td> <td>TODO handle active/inactive</td> <td>SATD_ADDED</td> <td>isActive()</td> <td>public boolean isActive()</td> <td>
    // TODO handle active/inactive
    return true;
</td> </tr><tr><td>75</a></td> <td><a href="html/-1413930510.html">-1413930510</td><td>apache/log4j</td><td>Paul Jeffrey Smith</td><td>ad3450477a77a963b46c8c563e7c857e85a994ce</td> <td>None</td> <td>TODO handle active/inactive</td> <td>SATD_ADDED</td> <td>isActive()</td> <td>public boolean isActive()</td> <td>
    // TODO handle active/inactive
    return true;
</td> </tr><tr><td>74</a></td> <td><a href="html/-1413930511.html">-1413930511</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>fbf8e37311c11e1f69bb46f647033722ffd3a9c4</td> <td>None</td> <td>move pointer</td> <td>SATD_ADDED</td> <td>parse()</td> <td>public PatternConverter parse()</td> <td>
    char c;
    i = 0;
    while (i < patternLength) {
        c = pattern.charAt(i++);
        switch(state) {
            case LITERAL_STATE:
                // In literal state, the last char is always a literal.
                if (i == patternLength) {
                    currentLiteral.append(c);
                    continue;
                }
                if (c == ESCAPE_CHAR) {
                    // peek at the next char.
                    switch(pattern.charAt(i)) {
                        case ESCAPE_CHAR:
                            currentLiteral.append(c);
                            // move pointer
                            i++;
                            break;
                        case 'n':
                            currentLiteral.append(Layout.LINE_SEP);
                            // move pointer
                            i++;
                            break;
                        default:
                            if (currentLiteral.length() != 0) {
                                addToList(new LiteralPatternConverter(currentLiteral.toString()));
                            // LogLog.debug("Parsed LITERAL converter: \""
                            // +currentLiteral+"\".");
                            }
                            currentLiteral.setLength(0);
                            // append %
                            currentLiteral.append(c);
                            state = CONVERTER_STATE;
                            formattingInfo.reset();
                    }
                } else {
                    currentLiteral.append(c);
                }
                break;
            case CONVERTER_STATE:
                currentLiteral.append(c);
                switch(c) {
                    case '-':
                        formattingInfo.leftAlign = true;
                        break;
                    case '.':
                        state = DOT_STATE;
                        break;
                    default:
                        if ((c >= '0') && (c <= '9')) {
                            formattingInfo.min = c - '0';
                            state = MIN_STATE;
                        } else {
                            finalizeConverter(c);
                        }
                }
                // switch
                break;
            case MIN_STATE:
                currentLiteral.append(c);
                if ((c >= '0') && (c <= '9')) {
                    formattingInfo.min = (formattingInfo.min * 10) + (c - '0');
                } else if (c == '.') {
                    state = DOT_STATE;
                } else {
                    finalizeConverter(c);
                }
                break;
            case DOT_STATE:
                currentLiteral.append(c);
                if ((c >= '0') && (c <= '9')) {
                    formattingInfo.max = c - '0';
                    state = MAX_STATE;
                } else {
                    LogLog.error("Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\".");
                    state = LITERAL_STATE;
                }
                break;
            case MAX_STATE:
                currentLiteral.append(c);
                if ((c >= '0') && (c <= '9')) {
                    formattingInfo.max = (formattingInfo.max * 10) + (c - '0');
                } else {
                    finalizeConverter(c);
                    state = LITERAL_STATE;
                }
                break;
        }
    // switch
    }
    // while
    if (currentLiteral.length() != 0) {
        addToList(new LiteralPatternConverter(currentLiteral.toString()));
    // LogLog.debug("Parsed LITERAL converter: \""+currentLiteral+"\".");
    }
    return head;
</td> </tr><tr><td>71</a></td> <td><a href="html/-1413930513.html">-1413930513</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>579d6f525526f317fa3cccd4bf8cbf11e8023361</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1
Util.rename(
fileNamePattern.convert(minIndex),</td> <td>move active file name to min</td> <td>SATD_REMOVED</td> <td>rollover()</td> <td>public void rollover()</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i >= minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            switch(compressionMode) {
                case Compress.NONE:
                    Util.rename(activeFileName, fileNamePattern.convert(minIndex));
                    break;
                case Compress.GZ:
                    Compress.GZCompress(activeFileName, fileNamePattern.convert(minIndex));
                    break;
            }
        }
    }
</td> </tr><tr><td>70</a></td> <td><a href="html/-1413930514.html">-1413930514</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>579d6f525526f317fa3cccd4bf8cbf11e8023361</td> <td>move active file name to min
TODO: compress the currently active file into minIndex</td> <td>move active file name to min</td> <td>SATD_REMOVED</td> <td>rollover()</td> <td>public void rollover()</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i >= minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            switch(compressionMode) {
                case Compress.NONE:
                    Util.rename(activeFileName, fileNamePattern.convert(minIndex));
                    break;
                case Compress.GZ:
                    Compress.GZCompress(activeFileName, fileNamePattern.convert(minIndex));
                    break;
            }
        }
    }
</td> </tr><tr><td>69</a></td> <td><a href="html/-1413930513.html">-1413930513</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>abb0a73e829f759efc325177b534aa6b5e746b1d</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1
Util.rename(
fileNamePattern.convert(minIndex),</td> <td>SATD_CHANGED</td> <td>rollover()</td> <td>public void rollover()</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i >= minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            // TODO: compress the currently active file into minIndex
            Util.rename(activeFileName, fileNamePattern.convert(minIndex));
        } else {
        // TODO: compress the currently active file (minIndex) into minIndex+1
        // Util.rename(
        // fileNamePattern.convert(minIndex),
        // fileNamePattern.convert(minIndex + 1));
        }
    }
</td> </tr><tr><td>68</a></td> <td><a href="html/-1413930513.html">-1413930513</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>12333c9f2eeddb0dbd34c24a21fee4e70b60d514</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>rollover(File)</td> <td>public void rollover(File f)</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i > minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            // TODO: compress the currently active file into minIndex
            Util.rename(activeFileName, fileNamePattern.convert(minIndex));
        } else {
            // TODO: compress the currently active file (minIndex) into minIndex+1
            Util.rename(fileNamePattern.convert(minIndex), fileNamePattern.convert(minIndex + 1));
        }
    }
</td> </tr><tr><td>67</a></td> <td><a href="html/-1413930514.html">-1413930514</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>12333c9f2eeddb0dbd34c24a21fee4e70b60d514</td> <td>move active file name to min
TODO: compress the currently active file into minIndex</td> <td>move active file name to min
TODO: compress the currently active file into minIndex</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>rollover(File)</td> <td>public void rollover(File f)</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i > minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            // TODO: compress the currently active file into minIndex
            Util.rename(activeFileName, fileNamePattern.convert(minIndex));
        } else {
            // TODO: compress the currently active file (minIndex) into minIndex+1
            Util.rename(fileNamePattern.convert(minIndex), fileNamePattern.convert(minIndex + 1));
        }
    }
</td> </tr><tr><td>66</a></td> <td><a href="html/-1413930513.html">-1413930513</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2046d0782fcec9b8c00f96f8bb6f4364239cf42e</td> <td>None</td> <td>TODO: compress the currently active file (minIndex) into minIndex+1</td> <td>SATD_ADDED</td> <td>rollover(File)</td> <td>public void rollover(File f)</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i > minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            // TODO: compress the currently active file into minIndex
            Util.rename(activeFileName, fileNamePattern.convert(minIndex));
        } else {
            // TODO: compress the currently active file (minIndex) into minIndex+1
            Util.rename(fileNamePattern.convert(minIndex), fileNamePattern.convert(minIndex + 1));
        }
    }
</td> </tr><tr><td>65</a></td> <td><a href="html/-1413930514.html">-1413930514</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2046d0782fcec9b8c00f96f8bb6f4364239cf42e</td> <td>None</td> <td>move active file name to min
TODO: compress the currently active file into minIndex</td> <td>SATD_ADDED</td> <td>rollover(File)</td> <td>public void rollover(File f)</td> <td>
    // Inside this method it is guaranteed that the hereto active log fil is closed.
    // If maxIndex <= 0, then there is no file renaming to be done.
    if (maxIndex >= 0) {
        // Delete the oldest file, to keep Windows happy.
        File file = new File(fileNamePattern.convert(maxIndex));
        if (file.exists()) {
            file.delete();
        }
        // Map {(maxIndex - 1), ..., minIndex} to {maxIndex, ..., minIndex+1}
        for (int i = maxIndex - 1; i > minIndex; i--) {
            Util.rename(fileNamePattern.convert(i), fileNamePattern.convert(i + 1));
        }
        if (activeFileName != null) {
            // move active file name to min
            // TODO: compress the currently active file into minIndex
            Util.rename(activeFileName, fileNamePattern.convert(minIndex));
        } else {
            // TODO: compress the currently active file (minIndex) into minIndex+1
            Util.rename(fileNamePattern.convert(minIndex), fileNamePattern.convert(minIndex + 1));
        }
    }
</td> </tr><tr><td>63</a></td> <td><a href="html/-1413930515.html">-1413930515</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>54e0894a235cf32342eb9ccc6776b3172c67a65c</td> <td>None</td> <td>TODO: add any more stategies</td> <td>SATD_ADDED</td> <td>main(String[])</td> <td>public static void main(String[] args)</td> <td>
    initLog4J();
    new Main();
</td> </tr><tr><td>62</a></td> <td><a href="html/-1413930516.html">-1413930516</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>54e0894a235cf32342eb9ccc6776b3172c67a65c</td> <td>None</td> <td>TODO: perhaps it should clear the internal TableModel</td> <td>SATD_ADDED</td> <td>close()</td> <td>public void close()</td> <td>
// TODO: perhaps it should clear the internal TableModel
</td> </tr><tr><td>60</a></td> <td><a href="html/-1413930517.html">-1413930517</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>0a2cd5d393fcd730ea5791503fa945f66906adc9</td> <td>None</td> <td>move pointer</td> <td>SATD_ADDED</td> <td>addToList(PatternConverter)</td> <td>private void addToList(PatternConverter pc)</td> <td>
    if (head == null) {
        head = tail = pc;
    } else {
        tail.next = pc;
        tail = pc;
    }
</td> </tr><tr><td>59</a></td> <td><a href="html/-1413930518.html">-1413930518</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>0a2cd5d393fcd730ea5791503fa945f66906adc9</td> <td>None</td> <td>if(c instanceof  ProvisionNode)</td> <td>SATD_ADDED</td> <td>main(String[])</td> <td>public static void main(String[] args)</td> <td>
    LENGTH = args.length;
    if (LENGTH == 0) {
        System.err.println("Usage: java " + StressCategory.class.getName() + " name1 ... nameN\n.");
        System.exit(1);
    }
    if (LENGTH >= 7) {
        System.err.println("This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines");
    }
    names = new String[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        names[i] = args[i];
    }
    cat = new Category[LENGTH];
    ct = new CT[LENGTH];
    permute(0);
// If did not exit, then passed all tests.
</td> </tr><tr><td>58</a></td> <td><a href="html/-1413930519.html">-1413930519</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>62cb0c5f0dc4869fc65f99f12258010da8e6aed7</td> <td>None</td> <td>either ignore the exception or log the fact that the setting of this
custom repository selector failed because another had been set previously
and maybe we should set \"initialized\" to \"true\" in here so this exception doesn't
occur again in this class</td> <td>SATD_ADDED</td> <td>doIdempotentInitialization()</td> <td>public static void doIdempotentInitialization()</td> <td>
    if (!initialized) {
        try {
            Object guard = new Object();
            LogManager.setRepositorySelector(singleton, guard);
            initialized = true;
        } catch (IllegalArgumentException iae) {
        // either ignore the exception or log the fact that the setting of this
        // custom repository selector failed because another had been set previously
        // and maybe we should set "initialized" to "true" in here so this exception doesn't
        // occur again in this class
        }
    }
</td> </tr><tr><td>56</a></td> <td><a href="html/-1413930520.html">-1413930520</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>0f307ca72c7a349ad7b7b516c72b9dd520b6c4c2</td> <td>None</td> <td>This should only ever be called once in this class' entire existence.
The only way to override it is to pass in the exact same guard object
that we set here...which is next to impossible unless we store a
reference to it.  We will not do that unless it becomes a requirement
in the future.</td> <td>SATD_ADDED</td> <td>getHierarchy(ClassLoader)</td> <td>public static Hierarchy getHierarchy(ClassLoader cl)</td> <td>
    return (Hierarchy) hierMap.get(cl);
</td> </tr><tr><td>55</a></td> <td><a href="html/-1413930521.html">-1413930521</td><td>apache/log4j</td><td>pathos</td><td>2ba618f5145e39cd6f2700a7a162a04f5a9387be</td> <td>None</td> <td>FIX ME
FIX ME</td> <td>SATD_ADDED</td> <td>levelChangedEvent(Logger)</td> <td>public void levelChangedEvent(Logger logger)</td> <td>
// FIX ME
// FIX ME
</td> </tr><tr><td>53</a></td> <td><a href="html/-1413930522.html">-1413930522</td><td>apache/log4j</td><td>Mark Dwayne Womack</td><td>f59c1dac5a8fd750e009fcf27059690adb5c4dc9</td> <td>None</td> <td>when deprecated fireAddAppenderEvent(Category,Appender) is removed,
so should this block</td> <td>SATD_ADDED</td> <td>fireAddAppenderEvent(Logger, Appender)</td> <td>public void fireAddAppenderEvent(Logger logger, Appender appender)</td> <td>
    // when deprecated fireAddAppenderEvent(Category,Appender) is removed,
    // so should this block
    if (listeners != null) {
        int size = listeners.size();
        HierarchyEventListener listener;
        for (int i = 0; i < size; i++) {
            listener = (HierarchyEventListener) listeners.elementAt(i);
            listener.addAppenderEvent(logger, appender);
        }
    }
    if (loggerEventListeners != null) {
        int size = loggerEventListeners.size();
        LoggerEventListener listener;
        for (int i = 0; i < size; i++) {
            listener = (LoggerEventListener) loggerEventListeners.elementAt(i);
            listener.appenderAddedEvent(logger, appender);
        }
    }
</td> </tr><tr><td>52</a></td> <td><a href="html/-1413930523.html">-1413930523</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>594e06562e8546287574c84f92eb1d62b413d085</td> <td>None</td> <td>first let us use the addXXX method</td> <td>SATD_ADDED</td> <td>addComponent(String, Object)</td> <td>public void addComponent(String name, Object childComponent)</td> <td>
    Class ccc = childComponent.getClass();
    name = capitalizeFirstLetter(name);
    Method method = getMethod("add" + name);
    // first let us use the addXXX method
    if (method != null) {
        Class[] params = method.getParameterTypes();
        if (params.length == 1) {
            if (params[0].isAssignableFrom(childComponent.getClass())) {
                try {
                    method.invoke(this.obj, new Object[] { childComponent });
                } catch (Exception e) {
                    logger.error("Could not invoke method " + method.getName() + " in class " + obj.getClass().getName() + " with parameter of type " + ccc.getName(), e);
                }
            } else {
                logger.error("A \"" + ccc.getName() + "\" object is not assignable to a \"" + params[0].getName() + "\" variable.");
                logger.error("The class \"" + params[0].getName() + "\" was loaded by ");
                logger.error("[" + params[0].getClassLoader() + "] whereas object of type ");
                logger.error("\"" + ccc.getName() + "\" was loaded by [" + ccc.getClassLoader() + "].");
            }
        }
    } else {
        logger.error("Could not find method [" + "add" + name + "] in class [" + objClass.getName() + "].");
    }
</td> </tr><tr><td>50</a></td> <td><a href="html/-1413930524.html">-1413930524</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>092e79cd773f99af3a934f93d4c1841889e3f168</td> <td>None</td> <td>We don't want the amount of rows to grow without bound,
leading to a out-of-memory-exception.  Especially not good
in a production environment :)</td> <td>SATD_ADDED</td> <td>trimRecords()</td> <td>protected void trimRecords()</td> <td>
    if (needsTrimming()) {
        trimOldestRecords();
    }
</td> </tr><tr><td>49</a></td> <td><a href="html/-1413930525.html">-1413930525</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>092e79cd773f99af3a934f93d4c1841889e3f168</td> <td>None</td> <td>SWING BUG:</td> <td>SATD_ADDED</td> <td>getDateFormatManager()</td> <td>public DateFormatManager getDateFormatManager()</td> <td>
    return _dateFormatManager;
</td> </tr><tr><td>48</a></td> <td><a href="html/-1413930526.html">-1413930526</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>092e79cd773f99af3a934f93d4c1841889e3f168</td> <td>None</td> <td>TODO: Defineable Views.</td> <td>SATD_ADDED</td> <td>getDateFormatManager()</td> <td>public DateFormatManager getDateFormatManager()</td> <td>
    return _dateFormatManager;
</td> </tr><tr><td>47</a></td> <td><a href="html/-1413930527.html">-1413930527</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>7bd0c413a7902328b3e48de73486b7076ae0efbb</td> <td>None</td> <td>Use a StringBuffer in lieu of String concatenation -- it is
much more efficient this way.</td> <td>SATD_ADDED</td> <td>escapeTags(String)</td> <td>public static String escapeTags(String input)</td> <td>
    // Check if the string is null or zero length -- if so, return
    // what was sent in.
    if (input == null || input.length() == 0) {
        return input;
    }
    // Use a StringBuffer in lieu of String concatenation -- it is
    // much more efficient this way.
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    int len = input.length();
    for (int i = 0; i < len; i++) {
        ch = input.charAt(i);
        if (ch == '<') {
            buf.append("&lt;");
        } else if (ch == '>') {
            buf.append("&gt;");
        } else {
            buf.append(ch);
        }
    }
    return buf.toString();
</td> </tr><tr><td>44</a></td> <td><a href="html/-1413930529.html">-1413930529</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>ceeeaaeab71cc09a7e7374003c81863030d8340b</td> <td>None</td> <td>if(c instanceof  ProvisionNode)</td> <td>SATD_ADDED</td> <td>main(String[])</td> <td>public static void main(String[] args)</td> <td>
    LENGTH = args.length;
    if (LENGTH == 0) {
        System.err.println("Usage: java " + StressCategory.class.getName() + " name1 ... nameN\n.");
        System.exit(1);
    }
    if (LENGTH >= 7) {
        System.err.println("This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines");
    }
    names = new String[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        names[i] = args[i];
    }
    cat = new Category[LENGTH];
    ct = new CT[LENGTH];
    permute(0);
// If did not exit, then passed all tests.
</td> </tr><tr><td>43</a></td> <td><a href="html/-1413930530.html">-1413930530</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2ad9566455a98c15a8884b1462b29dae5c20a3dc</td> <td>None</td> <td>REMOVE This code branching for Alexander Cerna's request</td> <td>SATD_ADDED</td> <td>rollOverSize()</td> <td>protected void rollOverSize()</td> <td>
    File file;
    // keep windows happy.
    this.closeFile();
    LogLog.debug("rolling over count=" + ((CountingQuietWriter) qw).getCount());
    LogLog.debug("maxSizeRollBackups = " + maxSizeRollBackups);
    LogLog.debug("curSizeRollBackups = " + curSizeRollBackups);
    LogLog.debug("countDirection = " + countDirection);
    // If maxBackups <= 0, then there is no file renaming to be done.
    if (maxSizeRollBackups != 0) {
        if (countDirection < 0) {
            // Delete the oldest file, to keep Windows happy.
            if (curSizeRollBackups == maxSizeRollBackups) {
                deleteFile(fileName + '.' + maxSizeRollBackups);
                curSizeRollBackups--;
            }
            // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
            for (int i = curSizeRollBackups; i >= 1; i--) {
                rollFile((fileName + "." + i), (fileName + '.' + (i + 1)));
            }
            curSizeRollBackups++;
            // Rename fileName to fileName.1
            rollFile(fileName, fileName + ".1");
        } else // REMOVE This code branching for Alexander Cerna's request
        if (countDirection == 0) {
            // rollFile based on date pattern
            curSizeRollBackups++;
            now.setTime(System.currentTimeMillis());
            scheduledFilename = fileName + sdf.format(now);
            rollFile(fileName, scheduledFilename);
        } else {
            // countDirection > 0
            if (curSizeRollBackups >= maxSizeRollBackups && maxSizeRollBackups > 0) {
                // delete the first and keep counting up.
                int oldestFileIndex = curSizeRollBackups - maxSizeRollBackups + 1;
                deleteFile(fileName + '.' + oldestFileIndex);
            }
            if (staticLogFileName) {
                curSizeRollBackups++;
                rollFile(fileName, fileName + '.' + curSizeRollBackups);
            }
        }
    }
    try {
        // This will also close the file. This is OK since multiple
        // close operations are safe.
        this.setFile(baseFileName, false);
    } catch (IOException e) {
        LogLog.error("setFile(" + fileName + ", false) call failed.", e);
    }
</td> </tr><tr><td>42</a></td> <td><a href="html/-1413930531.html">-1413930531</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>1a29e3ec91205f488d5ad379ecf61282a520bb2c</td> <td>None</td> <td>Failing to reset the object output stream every now and
then creates a serious memory leak.
right now we always reset. TODO - set up frequency counter per oos?</td> <td>SATD_ADDED</td> <td>activateOptions()</td> <td>public void activateOptions()</td> <td>
    startServer();
</td> </tr><tr><td>41</a></td> <td><a href="html/-1413930532.html">-1413930532</td><td>apache/log4j</td><td>oburn</td><td>587e14ed6c4ffd37b73773e1abfdce5a2c75fe7e</td> <td>None</td> <td>hack - but only thing I care about</td> <td>SATD_ADDED</td> <td>endElement(String, String, String)</td> <td>public void endElement(String aNamespaceURI, String aLocalName, String aQName)</td> <td>
    if (TAG_EVENT.equals(aQName)) {
        addEvent();
        resetData();
    } else if (mCurrentElement != TAG_EVENT) {
        // hack - but only thing I care about
        mCurrentElement = TAG_EVENT;
    }
</td> </tr><tr><td>35</a></td> <td><a href="html/-1413930548.html">-1413930548</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>5a6c96b28838873ab88af17be2de9f0186e55e7d</td> <td>Hack finished.</td> <td>Hack finished.</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>findAppenderByName(Document, String)</td> <td>protected Appender findAppenderByName(Document doc, String appenderName)</td> <td>
    Appender appender = (Appender) appenderBag.get(appenderName);
    if (appender != null) {
        return appender;
    } else {
        // Doesn't work on DOM Level 1 :
        // Element element = doc.getElementById(appenderName);
        // Endre's hack:
        Element element = null;
        NodeList list = doc.getElementsByTagName("appender");
        for (int t = 0; t < list.getLength(); t++) {
            Node node = list.item(t);
            NamedNodeMap map = node.getAttributes();
            Node attrNode = map.getNamedItem("name");
            if (appenderName.equals(attrNode.getNodeValue())) {
                element = (Element) node;
                break;
            }
        }
        // Hack finished.
        if (element == null) {
            LogLog.error("No appender named [" + appenderName + "] could be found.");
            return null;
        } else {
            appender = parseAppender(element);
            appenderBag.put(appenderName, appender);
            return appender;
        }
    }
</td> </tr><tr><td>34</a></td> <td><a href="html/-1413930549.html">-1413930549</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>5a6c96b28838873ab88af17be2de9f0186e55e7d</td> <td>Endre's hack:</td> <td>Endre's hack:</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>findAppenderByName(Document, String)</td> <td>protected Appender findAppenderByName(Document doc, String appenderName)</td> <td>
    Appender appender = (Appender) appenderBag.get(appenderName);
    if (appender != null) {
        return appender;
    } else {
        // Doesn't work on DOM Level 1 :
        // Element element = doc.getElementById(appenderName);
        // Endre's hack:
        Element element = null;
        NodeList list = doc.getElementsByTagName("appender");
        for (int t = 0; t < list.getLength(); t++) {
            Node node = list.item(t);
            NamedNodeMap map = node.getAttributes();
            Node attrNode = map.getNamedItem("name");
            if (appenderName.equals(attrNode.getNodeValue())) {
                element = (Element) node;
                break;
            }
        }
        // Hack finished.
        if (element == null) {
            LogLog.error("No appender named [" + appenderName + "] could be found.");
            return null;
        } else {
            appender = parseAppender(element);
            appenderBag.put(appenderName, appender);
            return appender;
        }
    }
</td> </tr><tr><td>31</a></td> <td><a href="html/-1413930547.html">-1413930547</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>60eb91adb2ac2602d73b5055d577d7627ab4d71e</td> <td>writing directly the Class object would be nicer, except that
serialized a Class object can not be read back by JDK
1.1.x. We have to resort to this hack instead.</td> <td>writing directly the Class object would be nicer, except that
serialized a Class object can not be read back by JDK
1.1.x. We have to resort to this hack instead.</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>writePriority(ObjectOutputStream)</td> <td>private void writePriority(ObjectOutputStream oos) throws java.io.IOException</td> <td>
    oos.writeInt(priority.toInt());
    Class clazz = priority.getClass();
    if (clazz == Priority.class) {
        oos.writeObject(null);
    } else {
        // writing directly the Class object would be nicer, except that
        // serialized a Class object can not be read back by JDK
        // 1.1.x. We have to resort to this hack instead.
        oos.writeObject(clazz.getName());
    }
</td> </tr><tr><td>27</a></td> <td><a href="html/-1413930538.html">-1413930538</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>7c3ce808d30a9c5fd8d4043bba50db95b2568c83</td> <td>If the helper is null, we'll inspect the System property \"java.version\" and
figure out which version of the VM we're running on.
Version strings are: [major version].[minor version].[bug fix revision]
So JDK 1.2: 1.2.0
JDK 1.1: 1.1.0</td> <td>Inspect the System property \"java.version\" and figure out which
version of the VM we're running on.  Version strings are: [major
version].[minor version].[bug fix revision] So JDK 1.2: 1.2.0 JDK
1.1: 1.1.0</td> <td>SATD_REMOVED</td> <td>getInstance()</td> <td>public static VersionHelper getInstance()</td> <td>
    if (helper == null) {
        /* Inspect the System property "java.version" and figure out which
	 version of the VM we're running on.  Version strings are: [major
	 version].[minor version].[bug fix revision] So JDK 1.2: 1.2.0 JDK
	 1.1: 1.1.0 */
        String prop = System.getProperty(VERSION_PROPERTY);
        boolean java1 = true;
        if (prop != null) {
            int i = prop.indexOf('.');
            if (i != -1) {
                if (prop.charAt(i + 1) != '1')
                    java1 = false;
            }
        }
        if (java1) {
            helper = new VersionHelper11();
        } else {
            helper = new VersionHelper20();
        }
    }
    return helper;
</td> </tr><tr><td>21</a></td> <td><a href="html/-1413930538.html">-1413930538</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>55e92153783df533add97435d96567765e5ccf38</td> <td>None</td> <td>If the helper is null, we'll inspect the System property \"java.version\" and
figure out which version of the VM we're running on.
Version strings are: [major version].[minor version].[bug fix revision]
So JDK 1.2: 1.2.0
JDK 1.1: 1.1.0</td> <td>SATD_ADDED</td> <td>getInstance()</td> <td>public static VersionHelper getInstance()</td> <td>
    if (helper == null) {
        /* If the helper is null, we'll inspect the System property "java.version" and
			   figure out which version of the VM we're running on.
			   Version strings are: [major version].[minor version].[bug fix revision]
			   So JDK 1.2: 1.2.0
			   JDK 1.1: 1.1.0 
				*/
        String prop = System.getProperty(VERSION_PROPERTY);
        StringTokenizer st = new StringTokenizer(prop, ".");
        // Ignore the initial 1
        st.nextToken();
        String version = st.nextToken();
        try {
            /* Here we'll parse the number and decide which version helper to use */
            switch(Integer.parseInt(version)) {
                case 0:
                case 1:
                    helper = new VersionHelper11();
                    break;
                default:
                    helper = new VersionHelper20();
                    break;
            }
        } catch (NumberFormatException oops) {
            helper = new VersionHelper11();
        }
    }
    return helper;
</td> </tr><tr><td>20</a></td> <td><a href="html/-1413930539.html">-1413930539</td><td>apache/log4j</td><td>pathos</td><td>b47560410ce7c66fb139031057ad594dfcba04f2</td> <td>None</td> <td>Use a StringBuffer in lieu of String concatenation -- it is
much more efficient this way.</td> <td>SATD_ADDED</td> <td>escapeHTMLTags(String)</td> <td>private String escapeHTMLTags(String input)</td> <td>
    // Check if the string is null or zero length -- if so, return
    // what was sent in.
    if (input == null || input.length() == 0) {
        return input;
    }
    // Use a StringBuffer in lieu of String concatenation -- it is
    // much more efficient this way.
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    for (int i = 0; i < input.length(); i++) {
        ch = input.charAt(i);
        if (ch == '<') {
            buf.append("&lt;");
        } else if (ch == '>') {
            buf.append("&gt;");
        } else {
            buf.append(ch);
        }
    }
    return buf.toString();
</td> </tr><tr><td>18</a></td> <td><a href="html/-1413930541.html">-1413930541</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>fac773b99729bfd6a966aaa4a6d109363569b7d9</td> <td>None</td> <td>XXX: Properties encode value.toString()</td> <td>SATD_ADDED</td> <td>foundProperty(Object, String, String, Object)</td> <td>public void foundProperty(Object obj, String prefix, String name, Object value)</td> <td>
    // XXX: Properties encode value.toString()
    if (obj instanceof Appender && "name".equals(name)) {
        return;
    }
    if (doCapitalize) {
        name = capitalize(name);
    }
    out.println(prefix + name + "=" + value.toString());
</td> </tr><tr><td>17</a></td> <td><a href="html/-1413930542.html">-1413930542</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>4649eee6fc9a5efa1253be942d21a239b2a71227</td> <td>None</td> <td>FIXME (remove qwIsOurs)</td> <td>SATD_ADDED</td> <td>closeFile()</td> <td>protected void closeFile()</td> <td>
    // FIXME (remove qwIsOurs)
    if (this.qw != null && this.qwIsOurs) {
        try {
            this.qw.close();
        } catch (java.io.IOException e) {
            // Exceptionally, it does not make sense to delegate to an
            // ErrorHandler. Since a closed appender is basically dead.
            LogLog.error("Could not close " + qw, e);
        }
    }
</td> </tr><tr><td>16</a></td> <td><a href="html/-1413930543.html">-1413930543</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>20d6d037a8b0788b221b86baf18c9a79c618702f</td> <td>None</td> <td>Try to cast directly Object to JDBCIDHandler</td> <td>SATD_ADDED</td> <td>setLogType(String, int, Object)</td> <td>public void setLogType(String _name, int _logtype, Object _value) throws Exception</td> <td>
    if (!isconfigured)
        throw new Exception("JDBCLogger::setLogType(), Not configured !");
    // setLogType() makes only sense for further configuration of configureTable()
    if (sql != null)
        return;
    _name = _name.toUpperCase();
    if (_name == null || !(_name.trim().length() > 0))
        throw new Exception("JDBCLogger::setLogType(), Missing argument name !");
    if (!LogType.isLogType(_logtype))
        throw new Exception("JDBCLogger::setLogType(), Invalid logtype '" + _logtype + "' !");
    if ((_logtype != LogType.MSG && _logtype != LogType.EMPTY) && _value == null)
        throw new Exception("JDBCLogger::setLogType(), Missing argument value !");
    LogColumn logcol;
    for (int i = 0; i < num; i++) {
        logcol = (LogColumn) logcols.get(i);
        if (logcol.name.equals(_name)) {
            if (!logcol.isWritable)
                throw new Exception("JDBCLogger::setLogType(), Column " + _name + " is not writeable !");
            // Column gets the message
            if (_logtype == LogType.MSG) {
                logcol.logtype = _logtype;
                return;
            } else // Column will be provided by JDBCIDHandler::getID()
            if (_logtype == LogType.ID) {
                logcol.logtype = _logtype;
                try {
                    // Try to cast directly Object to JDBCIDHandler
                    logcol.idhandler = (JDBCIDHandler) _value;
                } catch (Exception e) {
                    try {
                        // Assuming _value is of class string which contains the classname of a JDBCIDHandler
                        logcol.idhandler = (JDBCIDHandler) (Class.forName((String) _value).newInstance());
                    } catch (Exception e2) {
                        throw new Exception("JDBCLogger::setLogType(), Cannot cast value of class " + _value.getClass() + " to class JDBCIDHandler !");
                    }
                }
                return;
            } else // Column will be statically defined with Object _value
            if (_logtype == LogType.STATIC) {
                logcol.logtype = _logtype;
                logcol.value = _value;
                return;
            } else // Column will be provided with a actually timestamp
            if (_logtype == LogType.TIMESTAMP) {
                logcol.logtype = _logtype;
                return;
            } else // Column will be fully ignored during process.
            // If this column is not nullable, the column has to be filled by a database trigger,
            // else a database error occurs !
            // Columns which are not nullable, but should be not filled, must be explicit assigned with LogType.EMPTY,
            // else a value is required !
            if (_logtype == LogType.EMPTY) {
                logcol.logtype = _logtype;
                logcol.ignore = true;
                return;
            }
        }
    }
</td> </tr><tr><td>15</a></td> <td><a href="html/-1413930544.html">-1413930544</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>20d6d037a8b0788b221b86baf18c9a79c618702f</td> <td>None</td> <td>2. Use the better way of coding with method setLogType(String columnname, int LogType.xxx, Object xxx)</td> <td>SATD_ADDED</td> <td>main(String[])</td> <td>public static void main(String[] args)</td> <td>
    // A JDBCIDHandler
    MyIDHandler idhandler = new MyIDHandler();
    // Ensure to have all necessary drivers installed !
    try {
        Driver d = (Driver) (Class.forName("oracle.jdbc.driver.OracleDriver").newInstance());
        DriverManager.registerDriver(d);
    } catch (Exception e) {
    }
    // Set the priority which messages have to be logged
    cat.setPriority(Priority.DEBUG);
    // Create a new instance of JDBCAppender
    JDBCAppender ja = new JDBCAppender();
    // Set options with method setOption()
    ja.setOption(JDBCAppender.CONNECTOR_OPTION, "MyConnectionHandler");
    ja.setOption(JDBCAppender.URL_OPTION, "jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(COMMUNITY=tcp.world)(PROTOCOL=TCP)(Host=LENZI)(Port=1521))(ADDRESS=(COMMUNITY=tcp.world)(PROTOCOL=TCP)(Host=LENZI)(Port=1526)))(CONNECT_DATA=(SID=LENZI)))");
    ja.setOption(JDBCAppender.USERNAME_OPTION, "mex_pr_dev60");
    ja.setOption(JDBCAppender.PASSWORD_OPTION, "mex_pr_dev60");
    ja.setOption(JDBCAppender.TABLE_OPTION, "logtest");
    // There are two ways to setup the column-descriptions :
    // 1. Use the the method setOption(JDBCAppender.COLUMNS_OPTION, column-description)
    // ja.setOption(JDBCAppender.COLUMNS_OPTION, "id_seq~EMPTY	id~ID~MyIDHandler	msg~MSG	created_on~TIMESTAMP	created_by~STATIC~:-) Thomas Fenner (t.fenner@klopotek.de)");
    // 2. Use the better way of coding with method setLogType(String columnname, int LogType.xxx, Object xxx)
    ja.setLogType("id_seq", LogType.EMPTY, "");
    ja.setLogType("id", LogType.ID, idhandler);
    ja.setLogType("msg", LogType.MSG, "");
    ja.setLogType("created_on", LogType.TIMESTAMP, "");
    ja.setLogType("created_by", LogType.STATIC, "FEN");
    // If you just want to perform a static sql-statement, forget about the table- and columns-options,
    // and use this one :
    // ja.setOption(JDBCAppender.SQL_OPTION, "INSERT INTO LOGTEST (id, msg, created_on, created_by) VALUES (1, @MSG@, sysdate, 'me')");
    // other options
    // ja.setOption(JDBCAppender.BUFFER_OPTION, "1");
    // ja.setOption(JDBCAppender.COMMIT_OPTION, "Y");
    // Define a layout
    // ja.setLayout(new PatternLayout("%m"));
    // Add the appender to a category
    cat.addAppender(ja);
    // These messages with Priority >= setted priority will be logged to the database.
    cat.debug("debug");
    cat.info("info");
    cat.error("error");
    cat.fatal("fatal");
</td> </tr><tr><td>14</a></td> <td><a href="html/-1413930545.html">-1413930545</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>5095ca00abeb4c0dc66967f3baa1563734ea4d94</td> <td>None</td> <td>Print Stacktrace
Quick Hack maybe there is a better/faster way?</td> <td>SATD_ADDED</td> <td>close()</td> <td>public void close()</td> <td>
</td> </tr><tr><td>13</a></td> <td><a href="html/-1413930546.html">-1413930546</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>5095ca00abeb4c0dc66967f3baa1563734ea4d94</td> <td>None</td> <td>convert to specified encoding - which may be sequence of
8-bit chars, or multi-byte encodings like UTF-8 or UTF-16.
The receiving end had better be expecting whatever encoding
is used here on the sending end!</td> <td>SATD_ADDED</td> <td>write(String)</td> <td>public void write(String string) throws IOException</td> <td>
    if (prefix != null) {
        string = prefix + string;
    }
    byte[] rawData;
    if (this.encoding == null) {
        // convert to byte sequence using platform's default encoding
        rawData = string.getBytes();
    } else {
        // convert to specified encoding - which may be sequence of
        // 8-bit chars, or multi-byte encodings like UTF-8 or UTF-16.
        // The receiving end had better be expecting whatever encoding
        // is used here on the sending end!
        rawData = string.getBytes(encoding);
    }
    DatagramPacket packet = new DatagramPacket(rawData, rawData.length, address, port);
    if (this.ds != null) {
        ds.send(packet);
    } else {
        LogLog.error("write: failed to create DatagramPacket");
    }
</td> </tr><tr><td>12</a></td> <td><a href="html/-1413930547.html">-1413930547</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>2586dda3d3d2d78414119dd9c49a734ce1b5a8d2</td> <td>writing the Class would be nicer, except that serialized
classed can not be read back by JDK 1.1.x. We have to resort
to this hack instead.</td> <td>writing directly the Class object would be nicer, except that
serialized a Class object can not be read back by JDK
1.1.x. We have to resort to this hack instead.</td> <td>SATD_CHANGED</td> <td>writePriority(ObjectOutputStream)</td> <td>private void writePriority(ObjectOutputStream oos) throws java.io.IOException</td> <td>
    oos.writeInt(priority.toInt());
    Class clazz = priority.getClass();
    if (clazz == Priority.class) {
        oos.writeObject(null);
    } else {
        // writing directly the Class object would be nicer, except that
        // serialized a Class object can not be read back by JDK
        // 1.1.x. We have to resort to this hack instead.
        oos.writeObject(clazz.getName());
    }
</td> </tr><tr><td>11</a></td> <td><a href="html/-1413930547.html">-1413930547</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>b702f7145d3f660ac350ec862df9e8e913c1fffa</td> <td>None</td> <td>writing the Class would be nicer, except that serialized
classed can not be read back by JDK 1.1.x. We have to resort
to this hack instead.</td> <td>SATD_ADDED</td> <td>writePriority(ObjectOutputStream)</td> <td>private void writePriority(ObjectOutputStream oos) throws java.io.IOException</td> <td>
    oos.writeInt(priority.toInt());
    Class clazz = priority.getClass();
    if (clazz == Priority.class) {
        oos.writeObject(null);
    } else {
        // writing the Class would be nicer, except that serialized
        // classed can not be read back by JDK 1.1.x. We have to resort
        // to this hack instead.
        oos.writeObject(clazz.getName());
    }
</td> </tr><tr><td>10</a></td> <td><a href="html/-1413930548.html">-1413930548</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>d5d9779ebba5f8bb25a2d1cf1df0312153e1f955</td> <td>None</td> <td>Hack finished.</td> <td>SATD_ADDED</td> <td>findAppenderByReference(Element)</td> <td>protected Appender findAppenderByReference(Element appenderRef)</td> <td>
    String appenderName = appenderRef.getAttribute(REF_ATTR);
    Appender appender = (Appender) appenderBag.get(appenderName);
    if (appender != null) {
        return appender;
    } else {
        Document doc = appenderRef.getOwnerDocument();
        // DOESN'T WORK!! :
        // Element element = doc.getElementById(appenderName);
        // Endre's hack:
        Element element = null;
        NodeList list = doc.getElementsByTagName("appender");
        for (int t = 0; t < list.getLength(); t++) {
            Node node = list.item(t);
            NamedNodeMap map = node.getAttributes();
            Node attrNode = map.getNamedItem("name");
            if (appenderName.equals(attrNode.getNodeValue())) {
                element = (Element) node;
                break;
            }
        }
        // Hack finished.
        if (element == null) {
            LogLog.error("No appender named [" + appenderName + "] could be found.");
            return null;
        } else {
            appender = parseAppender(element);
            appenderBag.put(appenderName, appender);
            return appender;
        }
    }
</td> </tr><tr><td>9</a></td> <td><a href="html/-1413930549.html">-1413930549</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>d5d9779ebba5f8bb25a2d1cf1df0312153e1f955</td> <td>None</td> <td>Endre's hack:</td> <td>SATD_ADDED</td> <td>findAppenderByReference(Element)</td> <td>protected Appender findAppenderByReference(Element appenderRef)</td> <td>
    String appenderName = appenderRef.getAttribute(REF_ATTR);
    Appender appender = (Appender) appenderBag.get(appenderName);
    if (appender != null) {
        return appender;
    } else {
        Document doc = appenderRef.getOwnerDocument();
        // DOESN'T WORK!! :
        // Element element = doc.getElementById(appenderName);
        // Endre's hack:
        Element element = null;
        NodeList list = doc.getElementsByTagName("appender");
        for (int t = 0; t < list.getLength(); t++) {
            Node node = list.item(t);
            NamedNodeMap map = node.getAttributes();
            Node attrNode = map.getNamedItem("name");
            if (appenderName.equals(attrNode.getNodeValue())) {
                element = (Element) node;
                break;
            }
        }
        // Hack finished.
        if (element == null) {
            LogLog.error("No appender named [" + appenderName + "] could be found.");
            return null;
        } else {
            appender = parseAppender(element);
            appenderBag.put(appenderName, appender);
            return appender;
        }
    }
</td> </tr><tr><td>8</a></td> <td><a href="html/-1413930554.html">-1413930554</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>722c517ddfca251f478f2ced576ca18b11a58f6c</td> <td>Yes, it's ugly.  But all of these exceptions point to the same
problem: we can't create an Appender</td> <td>Yes, it's ugly.  But all of these exceptions point to the same
problem: we can't create an Appender</td> <td>CLASS_OR_METHOD_CHANGED</td> <td>parseAppender(Element)</td> <td>protected Appender parseAppender(Element appenderElement)</td> <td>
    String className = appenderElement.getAttribute(CLASS_ATTR);
    LogLog.debug("Class name: [" + className + ']');
    try {
        Object instance = Class.forName(className).newInstance();
        Appender appender = (Appender) instance;
        appender.setName(appenderElement.getAttribute(NAME_ATTR));
        NodeList children = appenderElement.getChildNodes();
        final int length = children.getLength();
        for (int loop = 0; loop < length; loop++) {
            Node currentNode = children.item(loop);
            /* We're only interested in Elements */
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                Element currentElement = (Element) currentNode;
                // Parse appender parameters
                if (currentElement.getTagName().equals(PARAM_TAG)) {
                    if (appender instanceof OptionHandler) {
                        parseParameters(currentElement, (OptionHandler) appender);
                    }
                } else // Set appender layout
                if (currentElement.getTagName().equals(LAYOUT_TAG)) {
                    appender.setLayout(parseLayout(currentElement));
                } else // Add filters
                if (currentElement.getTagName().equals(FILTER_TAG)) {
                    parseFilters(currentElement, appender);
                } else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
                    parseErrorHandler(currentElement, appender);
                } else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
                    String refName = currentElement.getAttribute(REF_ATTR);
                    if (appender instanceof AppenderAttachable) {
                        AppenderAttachable aa = (AppenderAttachable) appender;
                        LogLog.debug("Attaching appender named [" + refName + "] to appender named [" + appender.getName() + "].");
                        aa.addAppender(findAppenderByReference(currentElement));
                    } else {
                        LogLog.error("Requesting attachment of appender named [" + refName + "] to appender named [" + appender.getName() + "] which does not implement org.log4j.spi.AppenderAttachable.");
                    }
                }
            }
        }
        if (appender instanceof OptionHandler) {
            ((OptionHandler) appender).activateOptions();
        }
        return appender;
    }/* Yes, it's ugly.  But all of these exceptions point to the same
       problem: we can't create an Appender */
     catch (Exception oops) {
        LogLog.error("Could not create an Appender. Reported error follows.", oops);
        return null;
    }
</td> </tr><tr><td>7</a></td> <td><a href="html/-1413930550.html">-1413930550</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>8ed4ea15ad019c57010ed9378838cd6e1792d267</td> <td>None</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>SATD_ADDED</td> <td>factor(int)</td> <td>public int[] factor(int number) throws RemoteException</td> <td>
    // The client's host is an important source of information.
    try {
        NDC.push(this.getClientHost());
    } catch (java.rmi.server.ServerNotActiveException e) {
        // we are being called from same VM
        NDC.push("localhost");
    }
    // The information contained within the request is another source of
    // distinctive information. It might reveal the users name, date of request,
    // request ID etc. In servlet type environments, much information is
    // contained in cookies.
    NDC.push(String.valueOf(number));
    cat.info("Beginning to factor.");
    if (number <= 0) {
        throw new IllegalArgumentException(number + " is not a positive integer.");
    } else if (number == 1)
        return new int[] { 1 };
    Vector factors = new Vector();
    int n = number;
    for (int i = 2; (i <= n) && (i * i <= number); i++) {
        // It is bad practice to place log requests within tight loops.
        // It is done here to show interleaved log output from
        // different requests.
        cat.debug("Trying to see if " + i + " is a factor.");
        if ((n % i) == 0) {
            cat.info("Found factor " + i);
            factors.addElement(new Integer(i));
            do {
                n /= i;
            } while ((n % i) == 0);
        }
        // Placing artificial delays in tight-loops will also lead to sub-optimal
        // resuts. :-)
        delay(100);
    }
    if (n != 1) {
        cat.info("Found factor " + n);
        factors.addElement(new Integer(n));
    }
    int len = factors.size();
    int[] result = new int[len];
    for (int i = 0; i < len; i++) {
        result[i] = ((Integer) factors.elementAt(i)).intValue();
    }
    // Before leaving a thread we call NDC.remove. This deletes the reference
    // to the thread in the internal hash table. Version 0.8.5 introduces a
    // a lazy removal mechanism in case you forget to call remove when
    // exiting a thread. See the java documentation in NDC.remove for further
    // details.
    NDC.remove();
    return result;
</td> </tr><tr><td>6</a></td> <td><a href="html/-1413930551.html">-1413930551</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>947517357402f5ff3800d18c8106c52533c91e09</td> <td>None</td> <td>move pointer</td> <td>SATD_ADDED</td> <td>addToList(PatternConverter)</td> <td>private void addToList(PatternConverter pc)</td> <td>
    if (head == null) {
        head = tail = pc;
    } else {
        tail.next = pc;
        tail = pc;
    }
</td> </tr><tr><td>5</a></td> <td><a href="html/-1413930552.html">-1413930552</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>947517357402f5ff3800d18c8106c52533c91e09</td> <td>None</td> <td>Print Stacktrace
Quick Hack maybe there is a better/faster way?</td> <td>SATD_ADDED</td> <td>append(LoggingEvent)</td> <td>public void append(LoggingEvent event)</td> <td>
    String text = this.layout.format(event);
    String trace = "";
    // Print Stacktrace
    // Quick Hack maybe there is a better/faster way?
    if (event.throwable != null) {
        event.throwable.printStackTrace(tp);
        for (int i = 0; i < sw.getBuffer().length(); i++) {
            if (sw.getBuffer().charAt(i) == '\t')
                sw.getBuffer().replace(i, i + 1, "        ");
        }
        trace = sw.toString();
        sw.getBuffer().delete(0, sw.getBuffer().length());
    }
    try {
        if (fancy) {
            textpane.setEditable(true);
            textpane.insertIcon((ImageIcon) icons.get(event.priority));
            textpane.setEditable(false);
        }
        doc.insertString(doc.getLength(), text + trace, (MutableAttributeSet) attributes.get(event.priority));
    } catch (BadLocationException badex) {
        System.err.println(badex);
    }
    textpane.setCaretPosition(doc.getLength());
</td> </tr><tr><td>4</a></td> <td><a href="html/-1413930553.html">-1413930553</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>947517357402f5ff3800d18c8106c52533c91e09</td> <td>None</td> <td>Print Stacktrace
Quick Hack maybe there is a better/faster way?</td> <td>SATD_ADDED</td> <td>append(LoggingEvent)</td> <td>public void append(LoggingEvent event)</td> <td>
    String text = this.layout.format(event);
    String trace = "";
    // Print Stacktrace
    // Quick Hack maybe there is a better/faster way?
    if (event.throwable != null) {
        event.throwable.printStackTrace(tp);
        for (int i = 0; i < sw.getBuffer().length(); i++) {
            if (sw.getBuffer().charAt(i) == '\t')
                sw.getBuffer().replace(i, i + 1, "        ");
        }
        trace = sw.toString();
        sw.getBuffer().delete(0, sw.getBuffer().length());
    }
    try {
        if (fancy) {
            textpane.setEditable(true);
            textpane.insertIcon((ImageIcon) icons.get(event.priority));
            textpane.setEditable(false);
        }
        doc.insertString(doc.getLength(), text + trace, (MutableAttributeSet) attributes.get(event.priority));
    } catch (BadLocationException badex) {
        System.err.println(badex);
    }
    textpane.setCaretPosition(doc.getLength());
</td> </tr><tr><td>3</a></td> <td><a href="html/-1413930554.html">-1413930554</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>4e7121c85b7353a8dff17f7669c270ad963763a6</td> <td>None</td> <td>Yes, it's ugly.  But all of these exceptions point to the same
problem: we can't create an Appender</td> <td>SATD_ADDED</td> <td>parseAppender(Element)</td> <td>protected Appender parseAppender(Element appenderElement)</td> <td>
    String className = appenderElement.getAttribute(CLASS_ATTR);
    LogLog.debug("Class name: [" + className + ']');
    try {
        Object instance = Class.forName(className).newInstance();
        Appender appender = (Appender) instance;
        appender.setName(appenderElement.getAttribute(NAME_ATTR));
        NodeList children = appenderElement.getChildNodes();
        final int length = children.getLength();
        for (int loop = 0; loop < length; loop++) {
            Node currentNode = children.item(loop);
            /* We're only interested in Elements */
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                Element currentElement = (Element) currentNode;
                // Parse appender parameters
                if (currentElement.getTagName().equals(PARAM_TAG)) {
                    if (appender instanceof OptionHandler) {
                        parseParameters(currentElement, (OptionHandler) appender);
                    }
                } else // Set appender layout
                if (currentElement.getTagName().equals(LAYOUT_TAG)) {
                    appender.setLayout(parseLayout(currentElement));
                } else // Add filters
                if (currentElement.getTagName().equals(FILTER_TAG)) {
                    parseFilters(currentElement, appender);
                } else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
                    parseErrorHandler(currentElement, appender);
                } else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
                    String refName = currentElement.getAttribute(REF_ATTR);
                    if (appender instanceof AppenderAttachable) {
                        AppenderAttachable aa = (AppenderAttachable) appender;
                        LogLog.debug("Attaching appender named [" + refName + "] to appender named [" + appender.getName() + "].");
                        aa.addAppender(findAppenderByReference(currentElement));
                    } else {
                        LogLog.error("Requesting attachment of appender named [" + refName + "] to appender named [" + appender.getName() + "] which does not implement org.log4j.spi.AppenderAttachable.");
                    }
                }
            }
        }
        if (appender instanceof OptionHandler) {
            ((OptionHandler) appender).activateOptions();
        }
        return appender;
    }/* Yes, it's ugly.  But all of these exceptions point to the same
       problem: we can't create an Appender */
     catch (Exception oops) {
        LogLog.error("Could not create an Appender. Reported error follows.", oops);
        return null;
    }
</td> </tr><tr><td>2</a></td> <td><a href="html/-1413930555.html">-1413930555</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>4e7121c85b7353a8dff17f7669c270ad963763a6</td> <td>None</td> <td>half of the way, create new childres</td> <td>SATD_ADDED</td> <td>run()</td> <td>public void run()</td> <td>
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug("In run loop, loopLength = " + loopLength);
    // half of the way, create new childres
    int createIndex = loopLength / 2;
    for (int i = 0; i <= loopLength; i++) {
        if (i == createIndex)
            createChildren(randomInt(BRANCHING_FACTOR));
        synchronized (lock) {
            root.debug("Message number " + msgCounter++);
        }
    // delay(1+randomInt(4)*100);
    }
    synchronized (lock) {
        StressAsyncAppender.threadCounter--;
        root.debug("Exiting run loop. " + threadCounter);
        if (StressAsyncAppender.threadCounter <= 0) {
            root.debug("Notifying [main] thread.");
            // wake up the main thread
            lock.notify();
        }
    }
</td> </tr><tr><td>1</a></td> <td><a href="html/-1413930556.html">-1413930556</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>26f8d8a8cd3f272b3fa5d912889207c64844aa61</td> <td>None</td> <td>if(c instanceof  ProvisionNode)</td> <td>SATD_ADDED</td> <td>main(String[])</td> <td>public static void main(String[] args)</td> <td>
    LENGTH = args.length;
    if (LENGTH == 0) {
        System.err.println("Usage: java " + StressCategory.class.getName() + " name1 ... nameN\n.");
        System.exit(1);
    }
    if (LENGTH >= 7) {
        System.err.println("This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines");
    }
    names = new String[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        names[i] = args[i];
    }
    cat = new Category[LENGTH];
    ct = new CT[LENGTH];
    permute(0);
// If did not exit, then passed all tests.
</td> </tr></table></body></html>