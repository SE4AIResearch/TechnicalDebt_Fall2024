<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5494</td> <td>-1009652232</td><td>apache/hadoop</td><td>Eli Collins</td><td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> <td>None</td> <td>TODO: Fix</td> <td>SATD_ADDED</td> <td>dump()</td> <td>private synchronized void dump()</td> <td>
    synchronized (eventLog) {
        eventLog.log("BEGIN_DUMP");
        // List jobs in order of submit time
        ArrayList<JobInProgress> jobs = new ArrayList<JobInProgress>(infos.keySet());
        Collections.sort(jobs, new Comparator<JobInProgress>() {

            public int compare(JobInProgress j1, JobInProgress j2) {
                return (int) Math.signum(j1.getStartTime() - j2.getStartTime());
            }
        });
        // Dump info for each job
        for (JobInProgress job : jobs) {
            JobProfile profile = job.getProfile();
            JobInfo info = infos.get(job);
            Schedulable ms = info.mapSchedulable;
            Schedulable rs = info.reduceSchedulable;
            eventLog.log("JOB", profile.getJobID(), profile.name, profile.user, job.getPriority(), poolMgr.getPoolName(job), job.numMapTasks, ms.getRunningTasks(), ms.getDemand(), ms.getFairShare(), ms.getWeight(), job.numReduceTasks, rs.getRunningTasks(), rs.getDemand(), rs.getFairShare(), rs.getWeight());
        }
        // List pools in alphabetical order
        List<Pool> pools = new ArrayList<Pool>(poolMgr.getPools());
        Collections.sort(pools, new Comparator<Pool>() {

            public int compare(Pool p1, Pool p2) {
                if (p1.isDefaultPool())
                    return 1;
                else if (p2.isDefaultPool())
                    return -1;
                else
                    return p1.getName().compareTo(p2.getName());
            }
        });
        for (Pool pool : pools) {
            int runningMaps = 0;
            int runningReduces = 0;
            for (JobInProgress job : pool.getJobs()) {
                JobInfo info = infos.get(job);
                if (info != null) {
                // TODO: Fix
                // runningMaps += info.runningMaps;
                // runningReduces += info.runningReduces;
                }
            }
            String name = pool.getName();
            eventLog.log("POOL", name, poolMgr.getPoolWeight(name), pool.getJobs().size(), poolMgr.getAllocation(name, TaskType.MAP), runningMaps, poolMgr.getAllocation(name, TaskType.REDUCE), runningReduces);
        }
        // Dump info for each pool
        eventLog.log("END_DUMP");
    }
</td> </tr></table></body></html>