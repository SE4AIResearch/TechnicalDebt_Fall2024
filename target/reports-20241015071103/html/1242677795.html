<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4303</td> 
     <td>1242677795</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>3ea1d5567cbceed5d17921546a02a3e1d8b093ef</td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createEntry(IntraLineDiffKey)</td> 
     <td>public IntraLineDiff createEntry(IntraLineDiffKey key) throws Exception</td> 
     <td> List<edit>
        edits = new ArrayList 
       <edit>
         (key.getEdits()); Text aContent = key.getTextA(); Text bContent = key.getTextB(); combineLineEdits(edits, aContent, bContent); for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); CharTextComparator cmp = new CharTextComparator(); List 
        <edit>
          wordEdits = MyersDiff.INSTANCE.diff(cmp, a, b); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (cmp.equals(a, ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; cmp.equals(a, ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; cmp.equals(a, ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (cmp.equals(b, bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; cmp.equals(b, bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; cmp.equals(b, bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new IntraLineDiff(edits); 
        </edit> 
       </edit> 
      </edit></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4294</td> 
     <td>1242677795</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>122ea72ba296928896a36daa42b3367f9873b0cd</td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>newEntry(ObjectReader, Text, Text, List<edit>
        , RevTree, RevTree, FileHeader) 
      </edit></td> 
     <td>private PatchListEntry newEntry(ObjectReader reader, Text aContent, Text bContent, List<edit>
        edits, RevTree aTree, RevTree bTree, FileHeader fileHeader) throws IOException 
      </edit></td> 
     <td> for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { if (aContent == null) { edits = new ArrayList<edit>
        (edits); aContent = read(reader, fileHeader.getOldPath(), aTree); bContent = read(reader, fileHeader.getNewPath(), bTree); combineLineEdits(edits, aContent, bContent); // restart the entire scan after combining lines. i = -1; continue; } CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); List 
       <edit>
         wordEdits = new MyersDiff(a, b).getEdits(); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (a.equals(ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; a.equals(ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; a.equals(ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (b.equals(bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; b.equals(bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; b.equals(bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new PatchListEntry(fileHeader, edits); 
       </edit> 
      </edit></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4290</td> 
     <td>1242677795</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>e3995a87ebdeec73bbfd8f1e2903ba6bb27e78c7</td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>newEntry(Repository, Text, Text, List<edit>
        , RevTree, RevTree, FileHeader) 
      </edit></td> 
     <td>private PatchListEntry newEntry(Repository repo, Text aContent, Text bContent, List<edit>
        edits, RevTree aTree, RevTree bTree, FileHeader fileHeader) throws IOException 
      </edit></td> 
     <td> for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { if (aContent == null) { edits = new ArrayList<edit>
        (edits); aContent = read(repo, fileHeader.getOldName(), aTree); bContent = read(repo, fileHeader.getNewName(), bTree); combineLineEdits(edits, aContent, bContent); // restart the entire scan after combining lines. i = -1; continue; } CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); List 
       <edit>
         wordEdits = new MyersDiff(a, b).getEdits(); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (a.equals(ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; a.equals(ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; a.equals(ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (b.equals(bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; b.equals(bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; b.equals(bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new PatchListEntry(fileHeader, edits); 
       </edit> 
      </edit></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4269</td> 
     <td>1242677795</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>e76ca310aa62c2076bdc6841a85f21c70098fb60</td> 
     <td>None</td> 
     <td>We sometimes collapsed an edit together in a strange way, such that the edges of each text is identical. Fix by by dropping out that incorrectly replaced region. </td> 
     <td>SATD_ADDED</td> 
     <td>newEntry(Repository, RevTree, RevTree, FileHeader)</td> 
     <td>private static PatchListEntry newEntry(Repository repo, RevTree aTree, RevTree bTree, FileHeader fileHeader) throws IOException</td> 
     <td> final FileMode oldMode = fileHeader.getOldMode(); final FileMode newMode = fileHeader.getNewMode(); if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) { return new PatchListEntry(fileHeader, Collections.<edit>
       emptyList()); } if (// want combined diff aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) { return new PatchListEntry(fileHeader, Collections.
       <edit>
        emptyList()); } List
        <edit>
          edits = fileHeader.toEditList(); if (edits.isEmpty()) { return new PatchListEntry(fileHeader, Collections.
         <edit>
          emptyList()); } switch(fileHeader.getChangeType()) { case ADD: case DELETE: return new PatchListEntry(fileHeader, edits); } Text aContent = null; Text bContent = null; for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { if (aContent == null) { edits = new ArrayList
          <edit>
           (edits); aContent = read(repo, fileHeader.getOldName(), aTree); bContent = read(repo, fileHeader.getNewName(), bTree); } CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); List
           <edit>
             wordEdits = new MyersDiff(a, b).getEdits(); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; a.equals(ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShiftRight = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (a.equals(ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShiftRight = false; } } } if (aShiftRight) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; a.equals(ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } boolean bShiftRight = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (b.equals(bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShiftRight = false; } } } if (bShiftRight) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; b.equals(bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new PatchListEntry(fileHeader, edits); 
           </edit>
          </edit>
         </edit>
        </edit>
       </edit>
      </edit></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>