<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4757</td> 
     <td>1242678053</td>
     <td>GerritCodeReview/gerrit</td>
     <td>David Pursehouse</td>
     <td>7273df290a812f28c28e2fbd3dcaccb1e34b4d76</td> 
     <td>None</td> 
     <td>TODO(dborowitz): Use try/finally when this doesn't double-close the repo.</td> 
     <td>SATD_ADDED</td> 
     <td>doOnlySubscriptionTableOperations(String, Branch.NameKey, List<submodulesubscription>
       , List
       <submodulesubscription>
        )
       </submodulesubscription>
      </submodulesubscription></td> 
     <td>private void doOnlySubscriptionTableOperations(final String gitModulesFileContent, final Branch.NameKey mergedBranch, final List<submodulesubscription>
        extractedSubscriptions, final List
       <submodulesubscription>
         previousSubscriptions) throws Exception
       </submodulesubscription>
      </submodulesubscription></td> 
     <td> expect(schemaFactory.open()).andReturn(schema); try (Repository realDb = createWorkRepository()) { // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git git = new Git(realDb); addRegularFileToIndex(".gitmodules", gitModulesFileContent, realDb); final RevCommit mergeTip = git.commit().setMessage("test").call(); expect(urlProvider.get()).andReturn("http://localhost:8080").times(2); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); expect(subscriptions.bySuperProject(mergedBranch)).andReturn(new ListResultSet&lt;&gt;(previousSubscriptions)); SortedSet<project.namekey>
        existingProjects = new TreeSet&lt;&gt;(); for (SubmoduleSubscription extracted : extractedSubscriptions) { existingProjects.add(extracted.getSubmodule().getParentKey()); } for (int index = 0; index &lt; extractedSubscriptions.size(); index++) { expect(repoManager.list()).andReturn(existingProjects); } final Set
       <submodulesubscription>
         alreadySubscribeds = new HashSet&lt;&gt;(); for (SubmoduleSubscription s : extractedSubscriptions) { if (previousSubscriptions.contains(s)) { alreadySubscribeds.add(s); } } final Set
        <submodulesubscription>
          subscriptionsToRemove = new HashSet&lt;&gt;(previousSubscriptions); final List
         <submodulesubscription>
           subscriptionsToInsert = new ArrayList&lt;&gt;(extractedSubscriptions); subscriptionsToRemove.removeAll(subscriptionsToInsert); subscriptionsToInsert.removeAll(alreadySubscribeds); if (!subscriptionsToRemove.isEmpty()) { expect(schema.submoduleSubscriptions()).andReturn(subscriptions); subscriptions.delete(subscriptionsToRemove); } expect(schema.submoduleSubscriptions()).andReturn(subscriptions); subscriptions.insert(subscriptionsToInsert); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); expect(subscriptions.bySubmodule(mergedBranch)).andReturn(new ListResultSet&lt;&gt;(new ArrayList
          <submodulesubscription>
           ())); schema.close(); doReplay(); final SubmoduleOp submoduleOp = new SubmoduleOp(mergedBranch, mergeTip, new RevWalk(realDb), urlProvider, schemaFactory, realDb, new Project(mergedBranch.getParentKey()), new ArrayList
           <change>
            (), null, null, repoManager, null, null, null); submoduleOp.update(); } 
           </change>
          </submodulesubscription>
         </submodulesubscription>
        </submodulesubscription>
       </submodulesubscription>
      </project.namekey></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4744</td> 
     <td>1242678053</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>16f552165aac8497576a5fded23d7027e951c547</td> 
     <td>None</td> 
     <td>TODO(dborowitz): Use try/finally when this doesn't double-close the repo.</td> 
     <td>SATD_ADDED</td> 
     <td>doOnlySubscriptionTableOperations(String, Branch.NameKey, List<submodulesubscription>
       , List
       <submodulesubscription>
        )
       </submodulesubscription>
      </submodulesubscription></td> 
     <td>private void doOnlySubscriptionTableOperations(final String gitModulesFileContent, final Branch.NameKey mergedBranch, final List<submodulesubscription>
        extractedSubscriptions, final List
       <submodulesubscription>
         previousSubscriptions) throws Exception
       </submodulesubscription>
      </submodulesubscription></td> 
     <td> expect(schemaFactory.open()).andReturn(schema); try (Repository realDb = createWorkRepository()) { // TODO(dborowitz): Use try/finally when this doesn't double-close the repo. @SuppressWarnings("resource") final Git git = new Git(realDb); addRegularFileToIndex(".gitmodules", gitModulesFileContent, realDb); final RevCommit mergeTip = git.commit().setMessage("test").call(); expect(urlProvider.get()).andReturn("http://localhost:8080").times(2); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); expect(subscriptions.bySuperProject(mergedBranch)).andReturn(new ListResultSet&lt;&gt;(previousSubscriptions)); SortedSet<project.namekey>
        existingProjects = new TreeSet&lt;&gt;(); for (SubmoduleSubscription extracted : extractedSubscriptions) { existingProjects.add(extracted.getSubmodule().getParentKey()); } for (int index = 0; index &lt; extractedSubscriptions.size(); index++) { expect(repoManager.list()).andReturn(existingProjects); } final Set
       <submodulesubscription>
         alreadySubscribeds = new HashSet&lt;&gt;(); for (SubmoduleSubscription s : extractedSubscriptions) { if (previousSubscriptions.contains(s)) { alreadySubscribeds.add(s); } } final Set
        <submodulesubscription>
          subscriptionsToRemove = new HashSet&lt;&gt;(previousSubscriptions); final List
         <submodulesubscription>
           subscriptionsToInsert = new ArrayList&lt;&gt;(extractedSubscriptions); subscriptionsToRemove.removeAll(subscriptionsToInsert); subscriptionsToInsert.removeAll(alreadySubscribeds); if (!subscriptionsToRemove.isEmpty()) { expect(schema.submoduleSubscriptions()).andReturn(subscriptions); subscriptions.delete(subscriptionsToRemove); } expect(schema.submoduleSubscriptions()).andReturn(subscriptions); subscriptions.insert(subscriptionsToInsert); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); expect(subscriptions.bySubmodule(mergedBranch)).andReturn(new ListResultSet&lt;&gt;(new ArrayList
          <submodulesubscription>
           ())); schema.close(); doReplay(); final SubmoduleOp submoduleOp = new SubmoduleOp(mergedBranch, mergeTip, new RevWalk(realDb), urlProvider, schemaFactory, realDb, new Project(mergedBranch.getParentKey()), new ArrayList
           <change>
            (), null, null, repoManager, null, null, null); submoduleOp.update(); } 
           </change>
          </submodulesubscription>
         </submodulesubscription>
        </submodulesubscription>
       </submodulesubscription>
      </project.namekey></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>