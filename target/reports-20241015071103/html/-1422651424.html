<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1212</td> 
     <td>-1422651424</td>
     <td>apache/camel</td>
     <td>James Strachan</td>
     <td>f599b0649a49dbbaf02e7fb299228054921f99cb</td> 
     <td>if the exchange is transacted then let the underlying system handle the redelivery etc. this DeadLetterChannel is only for non transacted exchanges TODO: Should be possible to remove with Claus got the TX error handler sorted</td> 
     <td>do not handle transacted exchanges that failed as this error handler does not support it</td> 
     <td>SATD_REMOVED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { return deliverToFaultProcessor(exchange, callback, data); } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, callback, data); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (exchange.getException() != null &amp;&amp; !ExchangeHelper.isFailureHandled(exchange)) { // TODO Call the Timer for the asyncProcessor asyncProcess(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1207</td> 
     <td>-1422651424</td>
     <td>apache/camel</td>
     <td>James Strachan</td>
     <td>5b1bc67eb9116b43570f4a7622f9051cb658b2b5</td> 
     <td>None</td> 
     <td>if the exchange is transacted then let the underlying system handle the redelivery etc. this DeadLetterChannel is only for non transacted exchanges TODO: Should be possible to remove with Claus got the TX error handler sorted</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (LOG.isDebugEnabled()) { LOG.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // if the exchange is transacted then let the underlying system handle the redelivery etc. // this DeadLetterChannel is only for non transacted exchanges // TODO: Should be possible to remove with Claus got the TX error handler sorted if (exchange.isTransacted() &amp;&amp; exchange.getException() != null) { if (LOG.isDebugEnabled()) { LOG.debug("This is a transacted exchange, bypassing this DeadLetterChannel: " + this + " for exchange: " + exchange); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { return deliverToFaultProcessor(exchange, callback, data); } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { LOG.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, callback, data); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (exchange.getException() != null &amp;&amp; !ExchangeHelper.isFailureHandled(exchange)) { // TODO Call the Timer for the asyncProcessor asyncProcess(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>