<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4796</td> 
     <td>1242678076</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>90ed9414c2d4e0f8ec60d5e7c0d1463b30f2eee8</td> 
     <td>TODO(dborowitz): Support assertions signed by a trusted key.</td> 
     <td>TODO(dborowitz): Support assertions signed by a trusted key.</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>readPublicKey(long, PushCertificateIdent)</td> 
     <td>private PGPPublicKey readPublicKey(long keyId, PushCertificateIdent expectedIdent) throws IOException</td> 
     <td> try (Repository repo = repoManager.openRepository(allUsers); RevWalk rw = new RevWalk(repo)) { Ref ref = repo.getRefDatabase().exactRef(RefNames.REFS_GPG_KEYS); if (ref == null) { return null; } NoteMap notes = NoteMap.read(rw.getObjectReader(), rw.parseCommit(ref.getObjectId())); Note note = notes.getNote(keyObjectId(keyId)); if (note == null) { return null; } try (InputStream objIn = rw.getObjectReader().open(note.getData(), OBJ_BLOB).openStream(); ArmoredInputStream in = new ArmoredInputStream(objIn)) { PGPObjectFactory factory = new BcPGPObjectFactory(in); PGPPublicKey matched = null; Object obj; while ((obj = factory.nextObject()) != null) { if (!(obj instanceof PGPPublicKeyRing)) { // TODO(dborowitz): Support assertions signed by a trusted key. log.info("Ignoring {} packet in {}", obj.getClass().getSimpleName(), note.getName()); continue; } PGPPublicKeyRing keyRing = (PGPPublicKeyRing) obj; PGPPublicKey key = keyRing.getPublicKey(keyId); if (key == null) { log.warn("Public key ring in {} does not contain key ID {}", note.getName(), keyObjectId(keyId)); continue; } if (matched != null) { // TODO(dborowitz): Try all keys. log.warn("Ignoring key with duplicate ID: {}", toString(key)); continue; } if (!verifyPublicKey(key, expectedIdent)) { continue; } matched = key; } return matched; } } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4794</td> 
     <td>1242678076</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>c5861d81cb404b5b6a103a139767c2efecaf0ccc</td> 
     <td>None</td> 
     <td>TODO(dborowitz): Support assertions signed by a trusted key.</td> 
     <td>SATD_ADDED</td> 
     <td>readPublicKey(long)</td> 
     <td>private PGPPublicKey readPublicKey(long keyId) throws IOException</td> 
     <td> try (Repository repo = repoManager.openRepository(allUsers); RevWalk rw = new RevWalk(repo)) { Ref ref = repo.getRefDatabase().exactRef(RefNames.REFS_GPG_KEYS); if (ref == null) { return null; } NoteMap notes = NoteMap.read(rw.getObjectReader(), rw.parseCommit(ref.getObjectId())); Note note = notes.getNote(keyObjectId(keyId)); if (note == null) { return null; } try (InputStream objIn = rw.getObjectReader().open(note.getData(), OBJ_BLOB).openStream(); ArmoredInputStream in = new ArmoredInputStream(objIn)) { PGPObjectFactory factory = new BcPGPObjectFactory(in); PGPPublicKey matched = null; Object obj; while ((obj = factory.nextObject()) != null) { if (!(obj instanceof PGPPublicKeyRing)) { // TODO(dborowitz): Support assertions signed by a trusted key. log.info("Ignoring {} packet in {}", obj.getClass().getSimpleName(), note.getName()); continue; } PGPPublicKeyRing keyRing = (PGPPublicKeyRing) obj; PGPPublicKey key = keyRing.getPublicKey(keyId); if (key == null) { log.warn("Public key ring in {} does not contain key ID {}", note.getName(), keyObjectId(keyId)); continue; } if (matched != null) { // TODO(dborowitz): Try all keys. log.warn("Ignoring key with duplicate ID: {}", toString(key)); continue; } matched = key; } // TODO(dborowitz): Additional key verification, at least user ID // signature. return matched; } } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>