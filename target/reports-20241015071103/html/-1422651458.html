<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1158</td> 
     <td>-1422651458</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>016918b2e276f95a7e8868dc6cd00fc3ca6fb71c</td> 
     <td>TODO: Stream is not supported</td> 
     <td>TODO: Stream is not supported</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>createJmsMessage(Exchange, Object, Map<string, object>
       , Session, CamelContext)
      </string,></td> 
     <td>protected Message createJmsMessage(Exchange exchange, Object body, Map<string, object>
        headers, Session session, CamelContext context) throws JMSException
      </string,></td> 
     <td> JmsMessageType type = null; // special for transferExchange if (endpoint != null &amp;&amp; endpoint.isTransferExchange()) { if (LOG.isDebugEnabled()) { LOG.debug("Option transferExchange=true so we use JmsMessageType: Object"); } Serializable holder = DefaultExchangeHolder.marshal(exchange); return session.createObjectMessage(holder); } // check if header have a type set, if so we force to use it if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) { type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE)); } else if (endpoint != null &amp;&amp; endpoint.getConfiguration().getJmsMessageType() != null) { // force a specific type from the endpoint configuration type = endpoint.getConfiguration().getJmsMessageType(); } else { // let body deterime the type if (body instanceof Node || body instanceof String) { type = Text; } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer) { type = Bytes; } else if (body instanceof Map) { type = Map; } else if (body instanceof Serializable) { type = Object; } } // create the JmsMessage based on the type if (type != null) { if (LOG.isDebugEnabled()) { LOG.debug("Using JmsMessageType: " + type); } switch(type) { case Text: { TextMessage message = session.createTextMessage(); String payload = context.getTypeConverter().convertTo(String.class, body); message.setText(payload); return message; } case Bytes: { BytesMessage message = session.createBytesMessage(); byte[] payload = context.getTypeConverter().convertTo(byte[].class, body); message.writeBytes(payload); return message; } case Map: { MapMessage message = session.createMapMessage(); Map payload = context.getTypeConverter().convertTo(Map.class, body); populateMapMessage(message, payload, context); return message; } case Object: return session.createObjectMessage((Serializable) body); case Strem: // TODO: Stream is not supported break; default: break; } } // TODO: should we throw an exception instead? if (LOG.isDebugEnabled()) { LOG.debug("Could not determine specific JmsMessage type to use from body." + " Will use generic JmsMessage. Body class: " + body.getClass().getCanonicalName()); } // return a default message return session.createMessage(); </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1147</td> 
     <td>-1422651458</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>3ca5c0259dab33a903bc08ac678359d2cd108a21</td> 
     <td>None</td> 
     <td>TODO: Stream is not supported</td> 
     <td>SATD_ADDED</td> 
     <td>createJmsMessage(Object, Map<string, object>
       , Session, CamelContext)
      </string,></td> 
     <td>protected Message createJmsMessage(Object body, Map<string, object>
        headers, Session session, CamelContext context) throws JMSException
      </string,></td> 
     <td> JmsMessageType type = null; // check if header have a type set, if so we force to use it if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) { type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE)); } else if (endpoint != null &amp;&amp; endpoint.getConfiguration().getJmsMessageType() != null) { // force a specific type from the endpoint configuration type = endpoint.getConfiguration().getJmsMessageType(); } else { // let body deterime the type if (body instanceof Node || body instanceof String) { type = Text; } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer) { type = Bytes; } else if (body instanceof Map) { type = Map; } else if (body instanceof Serializable) { type = Object; } } // create the JmsMessage based on the type if (type != null) { if (LOG.isDebugEnabled()) { LOG.debug("Using JmsMessageType: " + type); } switch(type) { case Text: { TextMessage message = session.createTextMessage(); String payload = context.getTypeConverter().convertTo(String.class, body); message.setText(payload); return message; } case Bytes: { BytesMessage message = session.createBytesMessage(); byte[] payload = context.getTypeConverter().convertTo(byte[].class, body); message.writeBytes(payload); return message; } case Map: { MapMessage message = session.createMapMessage(); Map payload = context.getTypeConverter().convertTo(Map.class, body); populateMapMessage(message, payload, context); return message; } case Object: return session.createObjectMessage((Serializable) body); case Strem: // TODO: Stream is not supported break; default: break; } } // TODO: should we throw an exception instead? if (LOG.isDebugEnabled()) { LOG.debug("Could not determine specific JmsMessage type to use from body." + " Will use generic JmsMessage. Body class: " + body.getClass().getCanonicalName()); } // return a default message return session.createMessage(); </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>