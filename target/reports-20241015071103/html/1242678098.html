<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4851</td> <td>1242678098</td><td>GerritCodeReview/gerrit</td><td>David Pursehouse</td><td>7a7fa9cc1cb3fdf6e1e1a603dc06fc06206f0265</td> <td>None</td> <td>TODO(dborowitz): Kill once callers are migrated.
Eventually, callers should always be responsible for executing.</td> <td>SATD_ADDED</td> <td>insert()</td> <td>public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException</td> <td>
    init();
    validate();
    final AtomicReference<Change> updatedChange = new AtomicReference<>();
    final AtomicReference<SetMultimap<ReviewerState, Account.Id>> oldReviewers = new AtomicReference<>();
    // TODO(dborowitz): Kill once callers are migrated.
    // Eventually, callers should always be responsible for executing.
    boolean executeBatch = false;
    BatchUpdate bu = batchUpdate;
    if (batchUpdate == null) {
        bu = batchUpdateFactory.create(db, ctl.getChange().getProject(), patchSet.getCreatedOn());
        executeBatch = true;
    }
    try {
        bu.getBatchRefUpdate().addCommand(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName(), ReceiveCommand.Type.CREATE));
        bu.addChangeOp(new ChangeOp(ctl) {

            @Override
            public void call(ReviewDb db, ChangeUpdate update) throws Exception {
                Change c = db.changes().get(update.getChange().getId());
                final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
                if (!c.getStatus().isOpen() && !allowClosed) {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
                }
                ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
                if (groups != null) {
                    patchSet.setGroups(groups);
                } else {
                    patchSet.setGroups(GroupCollector.getCurrentGroups(db, c));
                }
                db.patchSets().insert(Collections.singleton(patchSet));
                if (sendMail) {
                    oldReviewers.set(approvalsUtil.getReviewers(db, ctl.getNotes()));
                }
                updatedChange.set(db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed() && !allowClosed) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                        ChangeUtil.updated(change);
                        return change;
                    }
                }));
                if (updatedChange.get() == null) {
                    throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
                }
                approvalCopier.copy(db, ctl, patchSet);
                if (messageIsForChange()) {
                    cmUtil.addChangeMessage(db, update, changeMessage);
                }
            }
        });
        if (!messageIsForChange()) {
            commitMessageNotForChange(bu);
        }
        if (sendMail) {
            bu.addPostOp(new Callable<Void>() {

                @Override
                public Void call() {
                    Change c = updatedChange.get();
                    try {
                        PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                        ReplacePatchSetSender cm = replacePatchSetFactory.create(c.getId());
                        cm.setFrom(user.getAccountId());
                        cm.setPatchSet(patchSet, info);
                        cm.setChangeMessage(changeMessage);
                        cm.addReviewers(oldReviewers.get().get(ReviewerState.REVIEWER));
                        cm.addExtraCC(oldReviewers.get().get(ReviewerState.CC));
                        cm.send();
                    } catch (Exception err) {
                        log.error("Cannot send email for new patch set on change " + c.getId(), err);
                    }
                    return null;
                }
            });
        }
        if (runHooks) {
            bu.addPostOp(new Callable<Void>() {

                @Override
                public Void call() throws OrmException {
                    hooks.doPatchsetCreatedHook(updatedChange.get(), patchSet, db);
                    return null;
                }
            });
        }
        if (executeBatch) {
            bu.execute();
        }
    } catch (UpdateException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), NoSuchChangeException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), InvalidChangeOperationException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), OrmException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        Throwables.propagateIfPossible(e.getCause());
        throw new OrmException(e);
    } finally {
        if (executeBatch) {
            bu.close();
        }
    }
    return updatedChange.get();
</td> </tr></table></body></html>