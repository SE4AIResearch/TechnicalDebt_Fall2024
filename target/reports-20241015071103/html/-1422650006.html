<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>3802</td> <td>-1422650006</td><td>apache/camel</td><td>Claus Ibsen</td><td>6e0550c78674866d1a68665e60f62f8db32c472f</td> <td>None</td> <td>only if we support alternative syntax, and the uri contains the username and password in the authority
part of the uri, then we would need some special logic to capture that information and strip those
details from the uri, so we can continue parsing the uri using the normal syntax</td> <td>SATD_ADDED</td> <td>String> endpointProperties(String)</td> <td>public Map<String, String> endpointProperties(String uri) throws URISyntaxException</td> <td>
    // NOTICE: This logic is similar to org.apache.camel.util.EndpointHelper#endpointProperties
    // as the catalog also offers similar functionality (without having camel-core on classpath)
    // need to normalize uri first
    // parse the uri
    URI u = normalizeUri(uri);
    String scheme = u.getScheme();
    String json = componentJSonSchema(scheme);
    if (json == null) {
        throw new IllegalArgumentException("Cannot find endpoint with scheme " + scheme);
    }
    // grab the syntax
    String syntax = null;
    String alternativeSyntax = null;
    List<Map<String, String>> rows = JSonSchemaHelper.parseJsonSchema("component", json, false);
    for (Map<String, String> row : rows) {
        if (row.containsKey("syntax")) {
            syntax = row.get("syntax");
        }
        if (row.containsKey("alternativeSyntax")) {
            alternativeSyntax = row.get("alternativeSyntax");
        }
    }
    if (syntax == null) {
        throw new IllegalArgumentException("Endpoint with scheme " + scheme + " has no syntax defined in the json schema");
    }
    // only if we support alternative syntax, and the uri contains the username and password in the authority
    // part of the uri, then we would need some special logic to capture that information and strip those
    // details from the uri, so we can continue parsing the uri using the normal syntax
    Map<String, String> userInfoOptions = new LinkedHashMap<String, String>();
    if (alternativeSyntax != null && alternativeSyntax.contains("@")) {
        // clip the scheme from the syntax
        alternativeSyntax = after(alternativeSyntax, ":");
        // trim so only userinfo
        int idx = alternativeSyntax.indexOf("@");
        String fields = alternativeSyntax.substring(0, idx);
        String[] names = fields.split(":");
        // grab authority part and grab username and/or password
        String authority = u.getAuthority();
        if (authority != null && authority.contains("@")) {
            String username = null;
            String password = null;
            // grab unserinfo part before @
            String userInfo = authority.substring(0, authority.indexOf("@"));
            String[] parts = userInfo.split(":");
            if (parts.length == 2) {
                username = parts[0];
                password = parts[1];
            } else {
                // only username
                username = userInfo;
            }
            // remember the username and/or password which we add later to the options
            if (names.length == 2) {
                userInfoOptions.put(names[0], username);
                if (password != null) {
                    // password is optional
                    userInfoOptions.put(names[1], password);
                }
            }
        }
    }
    // clip the scheme from the syntax
    syntax = after(syntax, ":");
    // clip the scheme from the uri
    uri = after(uri, ":");
    String uriPath = stripQuery(uri);
    // strip user info from uri path
    if (!userInfoOptions.isEmpty()) {
        int idx = uriPath.indexOf('@');
        if (idx > -1) {
            uriPath = uriPath.substring(idx + 1);
        }
    }
    // strip double slash in the start
    if (uriPath != null && uriPath.startsWith("//")) {
        uriPath = uriPath.substring(2);
    }
    // parse the syntax and find the names of each option
    Matcher matcher = SYNTAX_PATTERN.matcher(syntax);
    List<String> word = new ArrayList<String>();
    while (matcher.find()) {
        String s = matcher.group(1);
        if (!scheme.equals(s)) {
            word.add(s);
        }
    }
    // parse the syntax and find each token between each option
    String[] tokens = SYNTAX_PATTERN.split(syntax);
    // find the position where each option start/end
    List<String> word2 = new ArrayList<String>();
    int prev = 0;
    for (String token : tokens) {
        if (token.isEmpty()) {
            continue;
        }
        // special for some tokens where :// can be used also, eg http://foo
        int idx = -1;
        int len = 0;
        if (":".equals(token)) {
            idx = uriPath.indexOf("://", prev);
            len = 3;
        }
        if (idx == -1) {
            idx = uriPath.indexOf(token, prev);
            len = token.length();
        }
        if (idx > 0) {
            String option = uriPath.substring(prev, idx);
            word2.add(option);
            prev = idx + len;
        }
    }
    // special for last or if we did not add anyone
    if (prev > 0 || word2.isEmpty()) {
        String option = uriPath.substring(prev);
        word2.add(option);
    }
    rows = JSonSchemaHelper.parseJsonSchema("properties", json, true);
    boolean defaultValueAdded = false;
    // now parse the uri to know which part isw what
    Map<String, String> options = new LinkedHashMap<String, String>();
    // include the username and password from the userinfo section
    if (!userInfoOptions.isEmpty()) {
        options.putAll(userInfoOptions);
    }
    // word contains the syntax path elements
    Iterator<String> it = word2.iterator();
    for (int i = 0; i < word.size(); i++) {
        String key = word.get(i);
        boolean allOptions = word.size() == word2.size();
        boolean required = isPropertyRequired(rows, key);
        String defaultValue = getPropertyDefaultValue(rows, key);
        // we have all options so no problem
        if (allOptions) {
            String value = it.next();
            options.put(key, value);
        } else {
            // we have a little problem as we do not not have all options
            if (!required) {
                String value = defaultValue;
                if (value != null) {
                    options.put(key, value);
                    defaultValueAdded = true;
                }
            } else {
                String value = it.hasNext() ? it.next() : null;
                if (value != null) {
                    options.put(key, value);
                }
            }
        }
    }
    Map<String, String> answer = new LinkedHashMap<String, String>();
    // remove all options which are using default values and are not required
    for (Map.Entry<String, String> entry : options.entrySet()) {
        String key = entry.getKey();
        String value = entry.getValue();
        if (defaultValueAdded) {
            boolean required = isPropertyRequired(rows, key);
            String defaultValue = getPropertyDefaultValue(rows, key);
            if (!required && defaultValue != null) {
                if (defaultValue.equals(value)) {
                    continue;
                }
            }
        }
        // we should keep this in the answer
        answer.put(key, value);
    }
    // now parse the uri parameters
    Map<String, Object> parameters = URISupport.parseParameters(u);
    // and covert the values to String so its JMX friendly
    for (Map.Entry<String, Object> entry : parameters.entrySet()) {
        String key = entry.getKey();
        String value = entry.getValue() != null ? entry.getValue().toString() : "";
        answer.put(key, value);
    }
    return answer;
</td> </tr></table></body></html>