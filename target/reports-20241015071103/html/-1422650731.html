<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2711</td> 
     <td>-1422650731</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>0266aba78a386ce3faafdda4cffc96ab7818a3cb</td> 
     <td>The replaceAll is an ugly workaround for CAMEL-4954, awaiting a cleaner fix once CAMEL-4425 is fully resolved in all components</td> 
     <td>use a linked map so the parameters is in the same order</td> 
     <td>SATD_REMOVED</td> 
     <td>Object&gt; parseQuery(String)</td> 
     <td>public static Map<string, object>
        parseQuery(String uri) throws URISyntaxException
      </string,></td> 
     <td> // must check for trailing &amp; as the uri.split("&amp;") will ignore those if (uri != null &amp;&amp; uri.endsWith("&amp;")) { throw new URISyntaxException(uri, "Invalid uri syntax: Trailing &amp; marker found. " + "Check the uri and remove the trailing &amp; marker."); } if (ObjectHelper.isEmpty(uri)) { // return an empty map return new LinkedHashMap<string, object>
       (0); } // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;, // as &amp; can be used in a parameter value as well. try { // use a linked map so the parameters is in the same order Map
       <string, object>
         rc = new LinkedHashMap
        <string, object>
         (); boolean isKey = true; boolean isValue = false; boolean isRaw = false; StringBuilder key = new StringBuilder(); StringBuilder value = new StringBuilder(); // parse the uri parameters char by char for (int i = 0; i &lt; uri.length(); i++) { // current char char ch = uri.charAt(i); // look ahead of the next char char next; if (i &lt; uri.length() - 2) { next = uri.charAt(i + 1); } else { next = '\u0000'; } // are we a raw value isRaw = value.toString().startsWith(RAW_TOKEN_START); // if we are in raw mode, then we keep adding until we hit the end marker if (isRaw) { if (isKey) { key.append(ch); } else if (isValue) { value.append(ch); } // we only end the raw marker if its )&amp; or at the end of the value boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000'); if (end) { // raw value end, so add that as a parameter, and reset flags addParameter(key.toString(), value.toString(), rc, isRaw); key.setLength(0); value.setLength(0); isKey = true; isValue = false; isRaw = false; // skip to next as we are in raw mode and have already added the value i++; } continue; } // if its a key and there is a = sign then the key ends and we are in value mode if (isKey &amp;&amp; ch == '=') { isKey = false; isValue = true; isRaw = false; continue; } // the &amp; denote parameter is ended if (ch == '&amp;') { // parameter is ended, as we hit &amp; separator addParameter(key.toString(), value.toString(), rc, isRaw); key.setLength(0); value.setLength(0); isKey = true; isValue = false; isRaw = false; continue; } // regular char so add it to the key or value if (isKey) { key.append(ch); } else if (isValue) { value.append(ch); } } // any left over parameters, then add that if (key.length() &gt; 0) { addParameter(key.toString(), value.toString(), rc, isRaw); } return rc; } catch (UnsupportedEncodingException e) { URISyntaxException se = new URISyntaxException(e.toString(), "Invalid encoding"); se.initCause(e); throw se; } 
        </string,>
       </string,>
      </string,></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>2464</td> 
     <td>-1422650731</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>04066a8eba5e6e0b9e6c4c3076e06b59c462cce9</td> 
     <td>None</td> 
     <td>The replaceAll is an ugly workaround for CAMEL-4954, awaiting a cleaner fix once CAMEL-4425 is fully resolved in all components</td> 
     <td>SATD_ADDED</td> 
     <td>Object&gt; parseQuery(String)</td> 
     <td>public static Map<string, object>
        parseQuery(String uri) throws URISyntaxException
      </string,></td> 
     <td> // must check for trailing &amp; as the uri.split("&amp;") will ignore those if (uri != null &amp;&amp; uri.endsWith("&amp;")) { throw new URISyntaxException(uri, "Invalid uri syntax: Trailing &amp; marker found. " + "Check the uri and remove the trailing &amp; marker."); } try { // use a linked map so the parameters is in the same order Map<string, object>
        rc = new LinkedHashMap
       <string, object>
        (); if (uri != null) { String[] parameters = uri.split("&amp;"); for (String parameter : parameters) { int p = parameter.indexOf("="); if (p &gt;= 0) { // The replaceAll is an ugly workaround for CAMEL-4954, awaiting a cleaner fix once CAMEL-4425 // is fully resolved in all components String name = URLDecoder.decode(parameter.substring(0, p), CHARSET); String value = URLDecoder.decode(parameter.substring(p + 1).replaceAll("%", "%25"), CHARSET); // does the key already exist? if (rc.containsKey(name)) { // yes it does, so make sure we can support multiple values, but using a list // to hold the multiple values Object existing = rc.get(name); List
        <string>
          list; if (existing instanceof List) { list = CastUtils.cast((List<!--?-->) existing); } else { // create a new list to hold the multiple values list = new ArrayList
         <string>
          (); String s = existing != null ? existing.toString() : null; if (s != null) { list.add(s); } } list.add(value); rc.put(name, list); } else { rc.put(name, value); } } else { rc.put(parameter, null); } } } return rc; } catch (UnsupportedEncodingException e) { URISyntaxException se = new URISyntaxException(e.toString(), "Invalid encoding"); se.initCause(e); throw se; } 
         </string>
        </string>
       </string,>
      </string,></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>