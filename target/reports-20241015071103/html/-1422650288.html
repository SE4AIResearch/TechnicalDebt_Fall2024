<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>3201</td> <td>-1422650288</td><td>apache/camel</td><td>Dhiraj Bokde</td><td>9a92064cf9977a1cafa916441995e5e7804ec19e</td> <td>None</td> <td>TODO do we need to handle response based on other UriTypes???</td> <td>SATD_ADDED</td> <td>writeContent(Edm, HttpEntityEnclosingRequestBase, UriInfoImpl, Object, Olingo2ResponseHandler<T>)</td> <td>private void writeContent(final Edm edm, HttpEntityEnclosingRequestBase httpEntityRequest, final UriInfoImpl uriInfo, final Object content, final Olingo2ResponseHandler<T> responseHandler)</td> <td>
    try {
        // process resource by UriType
        final ODataResponse response = writeContent(edm, uriInfo, content);
        // copy all response headers
        for (String header : response.getHeaderNames()) {
            httpEntityRequest.setHeader(header, response.getHeader(header));
        }
        // get (http) entity which is for default Olingo2 implementation an InputStream
        if (response.getEntity() instanceof InputStream) {
            httpEntityRequest.setEntity(new InputStreamEntity((InputStream) response.getEntity()));
        /*
                // avoid sending it without a header field set
                if (!httpEntityRequest.containsHeader(HttpHeaders.CONTENT_TYPE)) {
                    httpEntityRequest.addHeader(HttpHeaders.CONTENT_TYPE, getContentType());
                }
*/
        }
        // execute HTTP request
        execute(httpEntityRequest, contentType, new AbstractFutureCallback<T>(responseHandler) {

            @SuppressWarnings("unchecked")
            @Override
            public void onCompleted(HttpResponse result) throws IOException, EntityProviderException, BatchException, ODataApplicationException {
                // if a entity is created (via POST request) the response body contains the new created entity
                HttpStatusCodes statusCode = HttpStatusCodes.fromStatusCode(result.getStatusLine().getStatusCode());
                if (statusCode != HttpStatusCodes.NO_CONTENT) {
                    // TODO do we need to handle response based on other UriTypes???
                    switch(uriInfo.getUriType()) {
                        case URI9:
                            // $batch
                            final List<BatchSingleResponse> singleResponses = EntityProvider.parseBatchResponse(result.getEntity().getContent(), result.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue());
                            // parse batch response bodies
                            final List<Olingo2BatchResponse> responses = new ArrayList<Olingo2BatchResponse>();
                            Map<String, String> contentIdLocationMap = new HashMap<String, String>();
                            final List<Olingo2BatchRequest> batchRequests = (List<Olingo2BatchRequest>) content;
                            final Iterator<Olingo2BatchRequest> iterator = batchRequests.iterator();
                            for (BatchSingleResponse response : singleResponses) {
                                final Olingo2BatchRequest request = iterator.next();
                                if (request instanceof Olingo2BatchChangeRequest && ((Olingo2BatchChangeRequest) request).getContentId() != null) {
                                    contentIdLocationMap.put("$" + ((Olingo2BatchChangeRequest) request).getContentId(), response.getHeader(HttpHeaders.LOCATION));
                                }
                                try {
                                    responses.add(parseResponse(edm, contentIdLocationMap, request, response));
                                } catch (Exception e) {
                                    // report any parsing errors as error response
                                    responses.add(new Olingo2BatchResponse(Integer.parseInt(response.getStatusCode()), response.getStatusInfo(), response.getContentId(), response.getHeaders(), new ODataApplicationException("Error parsing response for " + request + ": " + e.getMessage(), Locale.ENGLISH, e)));
                                }
                            }
                            responseHandler.onResponse((T) responses);
                            break;
                        default:
                            // get the response content as an ODataEntry object
                            responseHandler.onResponse((T) EntityProvider.readEntry(response.getContentHeader(), uriInfo.getTargetEntitySet(), result.getEntity().getContent(), EntityProviderReadProperties.init().build()));
                            break;
                    }
                } else {
                    responseHandler.onResponse((T) HttpStatusCodes.fromStatusCode(result.getStatusLine().getStatusCode()));
                }
            }
        });
    } catch (ODataException e) {
        responseHandler.onException(e);
    } catch (URISyntaxException e) {
        responseHandler.onException(e);
    } catch (UnsupportedEncodingException e) {
        responseHandler.onException(e);
    } catch (IOException e) {
        responseHandler.onException(e);
    }
</td> </tr></table></body></html>