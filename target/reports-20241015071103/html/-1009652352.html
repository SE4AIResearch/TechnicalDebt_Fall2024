<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>5623</td> 
     <td>-1009652352</td> 
     <td>apache/hadoop</td> 
     <td>Tsz-wo Sze</td> 
     <td>09b6f98de431628c80bc8a6faf0070eeaf72ff2a</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>processReport(DatanodeDescriptor, BlockListAsLongs)</td> 
     <td>public void processReport(DatanodeDescriptor node, BlockListAsLongs report) throws IOException</td> 
     <td> boolean isFirstBlockReport = (node.numBlocks() == 0); if (isFirstBlockReport) { // Initial block reports can be processed a lot more efficiently than // ordinary block reports. This shortens NN restart times. processFirstBlockReport(node, report); return; } // Normal case: // Modify the (block--&gt;datanode) map, according to the difference // between the old and new block report. // Collection<blockinfo>
        toAdd = new LinkedList 
       <blockinfo>
         (); Collection 
        <block>
          toRemove = new LinkedList 
         <block>
           (); Collection 
          <block>
            toInvalidate = new LinkedList 
           <block>
             (); Collection 
            <blockinfo>
              toCorrupt = new LinkedList 
             <blockinfo>
               (); Collection 
              <statefulblockinfo>
                toUC = new LinkedList 
               <statefulblockinfo>
                 (); reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC); // Process the blocks on each queue for (StatefulBlockInfo b : toUC) { addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState); } for (Block b : toRemove) { removeStoredBlock(b, node); } for (BlockInfo b : toAdd) { addStoredBlock(b, node, null, true); } for (Block b : toInvalidate) { NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: block " + b + " on " + node.getName() + " size " + b.getNumBytes() + " does not belong to any file."); addToInvalidates(b, node); } for (BlockInfo b : toCorrupt) { markBlockAsCorrupt(b, node); } 
               </statefulblockinfo> 
              </statefulblockinfo> 
             </blockinfo> 
            </blockinfo> 
           </block> 
          </block> 
         </block> 
        </block> 
       </blockinfo> 
      </blockinfo></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>5616</td> 
     <td>-1009652352</td> 
     <td>apache/hadoop</td> 
     <td>Tsz-wo Sze</td> 
     <td>97b6ca4dd7d1233e8f8c90b1c01e47228c044e13</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>processReport(DatanodeDescriptor, BlockListAsLongs)</td> 
     <td>public void processReport(DatanodeDescriptor node, BlockListAsLongs report) throws IOException</td> 
     <td> boolean isFirstBlockReport = (node.numBlocks() == 0); if (isFirstBlockReport) { // Initial block reports can be processed a lot more efficiently than // ordinary block reports. This shortens NN restart times. processFirstBlockReport(node, report); return; } // Normal case: // Modify the (block--&gt;datanode) map, according to the difference // between the old and new block report. // Collection<blockinfo>
        toAdd = new LinkedList 
       <blockinfo>
         (); Collection 
        <block>
          toRemove = new LinkedList 
         <block>
           (); Collection 
          <block>
            toInvalidate = new LinkedList 
           <block>
             (); Collection 
            <blockinfo>
              toCorrupt = new LinkedList 
             <blockinfo>
               (); Collection 
              <statefulblockinfo>
                toUC = new LinkedList 
               <statefulblockinfo>
                 (); reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC); // Process the blocks on each queue for (StatefulBlockInfo b : toUC) { addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState); } for (Block b : toRemove) { removeStoredBlock(b, node); } for (BlockInfo b : toAdd) { addStoredBlock(b, node, null, true); } for (Block b : toInvalidate) { NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: block " + b + " on " + node.getName() + " size " + b.getNumBytes() + " does not belong to any file."); addToInvalidates(b, node); } for (BlockInfo b : toCorrupt) { markBlockAsCorrupt(b, node); } 
               </statefulblockinfo> 
              </statefulblockinfo> 
             </blockinfo> 
            </blockinfo> 
           </block> 
          </block> 
         </block> 
        </block> 
       </blockinfo> 
      </blockinfo></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>5597</td> 
     <td>-1009652352</td> 
     <td>apache/hadoop</td> 
     <td>Eli Collins</td> 
     <td>1bcfe45e47775b98cce5541f328c4fd46e5eb13d</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>processReport(DatanodeDescriptor, BlockListAsLongs)</td> 
     <td>public void processReport(DatanodeDescriptor node, BlockListAsLongs report) throws IOException</td> 
     <td> boolean isFirstBlockReport = (node.numBlocks() == 0); if (isFirstBlockReport) { // Initial block reports can be processed a lot more efficiently than // ordinary block reports. This shortens NN restart times. processFirstBlockReport(node, report); return; } // Normal case: // Modify the (block--&gt;datanode) map, according to the difference // between the old and new block report. // Collection<blockinfo>
        toAdd = new LinkedList 
       <blockinfo>
         (); Collection 
        <block>
          toRemove = new LinkedList 
         <block>
           (); Collection 
          <block>
            toInvalidate = new LinkedList 
           <block>
             (); Collection 
            <blockinfo>
              toCorrupt = new LinkedList 
             <blockinfo>
               (); Collection 
              <statefulblockinfo>
                toUC = new LinkedList 
               <statefulblockinfo>
                 (); reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC); // Process the blocks on each queue for (StatefulBlockInfo b : toUC) { addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState); } for (Block b : toRemove) { removeStoredBlock(b, node); } for (BlockInfo b : toAdd) { addStoredBlock(b, node, null, true); } for (Block b : toInvalidate) { NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: block " + b + " on " + node.getName() + " size " + b.getNumBytes() + " does not belong to any file."); addToInvalidates(b, node); } for (BlockInfo b : toCorrupt) { markBlockAsCorrupt(b, node); } 
               </statefulblockinfo> 
              </statefulblockinfo> 
             </blockinfo> 
            </blockinfo> 
           </block> 
          </block> 
         </block> 
        </block> 
       </blockinfo> 
      </blockinfo></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>5374</td> 
     <td>-1009652352</td>
     <td>apache/hadoop</td>
     <td>Eli Collins</td>
     <td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> 
     <td>None</td> 
     <td>Initial block reports can be processed a lot more efficiently than ordinary block reports. This shortens NN restart times.</td> 
     <td>SATD_ADDED</td> 
     <td>processReport(DatanodeDescriptor, BlockListAsLongs)</td> 
     <td>public void processReport(DatanodeDescriptor node, BlockListAsLongs report) throws IOException</td> 
     <td> boolean isFirstBlockReport = (node.numBlocks() == 0); if (isFirstBlockReport) { // Initial block reports can be processed a lot more efficiently than // ordinary block reports. This shortens NN restart times. processFirstBlockReport(node, report); return; } // Normal case: // Modify the (block--&gt;datanode) map, according to the difference // between the old and new block report. // Collection<blockinfo>
        toAdd = new LinkedList
       <blockinfo>
        (); Collection
        <block>
          toRemove = new LinkedList
         <block>
          (); Collection
          <block>
            toInvalidate = new LinkedList
           <block>
            (); Collection
            <blockinfo>
              toCorrupt = new LinkedList
             <blockinfo>
              (); Collection
              <statefulblockinfo>
                toUC = new LinkedList
               <statefulblockinfo>
                (); reportDiff(node, report, toAdd, toRemove, toInvalidate, toCorrupt, toUC); // Process the blocks on each queue for (StatefulBlockInfo b : toUC) { addStoredBlockUnderConstruction(b.storedBlock, node, b.reportedState); } for (Block b : toRemove) { removeStoredBlock(b, node); } for (BlockInfo b : toAdd) { addStoredBlock(b, node, null, true); } for (Block b : toInvalidate) { NameNode.stateChangeLog.info("BLOCK* NameSystem.processReport: block " + b + " on " + node.getName() + " size " + b.getNumBytes() + " does not belong to any file."); addToInvalidates(b, node); } for (BlockInfo b : toCorrupt) { markBlockAsCorrupt(b, node); } 
               </statefulblockinfo>
              </statefulblockinfo>
             </blockinfo>
            </blockinfo>
           </block>
          </block>
         </block>
        </block>
       </blockinfo>
      </blockinfo></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>