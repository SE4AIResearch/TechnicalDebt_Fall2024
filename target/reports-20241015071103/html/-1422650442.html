<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>2972</td> 
     <td>-1422650442</td>
     <td>apache/camel</td>
     <td>Babak Vahdat</td>
     <td>f138f4564d588c7b65f10c04181a70858cea3f6f</td> 
     <td>TODO we should enable streaming here with CashedOutputStream!!</td> 
     <td>enable streaming via OutputStreamCache</td> 
     <td>SATD_REMOVED</td> 
     <td>unmarshal(Exchange, InputStream)</td> 
     <td>public Object unmarshal(Exchange exchange, InputStream encryptedStream) throws Exception</td> 
     <td> if (encryptedStream == null) { return null; } InputStream in = PGPUtil.getDecoderStream(encryptedStream); PGPObjectFactory pgpFactory = new PGPObjectFactory(in); Object o = pgpFactory.nextObject(); // the first object might be a PGP marker packet PGPEncryptedDataList enc; if (o instanceof PGPEncryptedDataList) { enc = (PGPEncryptedDataList) o; } else { enc = (PGPEncryptedDataList) pgpFactory.nextObject(); } PGPPublicKeyEncryptedData pbe = null; PGPPrivateKey key = null; // find encrypted data for which a private key exists in the secret key ring for (int i = 0; i &lt; enc.size() &amp;&amp; key == null; i++) { pbe = (PGPPublicKeyEncryptedData) enc.get(i); key = PGPDataFormatUtil.findPrivateKeyWithKeyId(exchange.getContext(), findKeyFileName(exchange), findEncryptionKeyRing(exchange), pbe.getKeyID(), findKeyPassword(exchange), getPassphraseAccessor(), getProvider()); } if (key == null) { throw new PGPException("Provided input is encrypted with unknown pair of keys."); } InputStream encData = pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(getProvider()).build(key)); pgpFactory = new PGPObjectFactory(encData); PGPCompressedData comData = (PGPCompressedData) pgpFactory.nextObject(); pgpFactory = new PGPObjectFactory(comData.getDataStream()); Object object = pgpFactory.nextObject(); PGPOnePassSignature signature; if (object instanceof PGPOnePassSignatureList) { signature = getSignature(exchange, (PGPOnePassSignatureList) object); object = pgpFactory.nextObject(); } else { signature = null; } PGPLiteralData ld = (PGPLiteralData) object; InputStream litData = ld.getInputStream(); // enable streaming via OutputStreamCache CachedOutputStream cos; ByteArrayOutputStream bos; OutputStream os; if (exchange.getContext().getStreamCachingStrategy().isEnabled()) { cos = new CachedOutputStream(exchange); bos = null; os = cos; } else { cos = null; bos = new ByteArrayOutputStream(); os = bos; } try { byte[] buffer = new byte[BUFFER_SIZE]; int bytesRead; while ((bytesRead = litData.read(buffer)) != -1) { os.write(buffer, 0, bytesRead); if (signature != null) { signature.update(buffer, 0, bytesRead); } os.flush(); } } finally { IOHelper.close(os, litData, encData, in); } if (signature != null) { PGPSignatureList sigList = (PGPSignatureList) pgpFactory.nextObject(); if (!signature.verify(getSignatureWithKeyId(signature.getKeyID(), sigList))) { throw new SignatureException("Cannot verify PGP signature"); } } if (cos != null) { return cos.newStreamCache(); } else { return bos.toByteArray(); } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>2966</td> 
     <td>-1422650442</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>dabc2dbaa006741eacc2e4a7aa389c3975ff8823</td> 
     <td>None</td> 
     <td>TODO we should enable streaming here with CashedOutputStream!!</td> 
     <td>SATD_ADDED</td> 
     <td>unmarshal(Exchange, InputStream)</td> 
     <td>public Object unmarshal(Exchange exchange, InputStream encryptedStream) throws Exception</td> 
     <td> if (encryptedStream == null) { return null; } InputStream in; try { byte[] encryptedData = IOUtils.toByteArray(encryptedStream); // TODO why do we need a byte array input stream? --&gt; streaming not possible? InputStream byteStream = new ByteArrayInputStream(encryptedData); in = PGPUtil.getDecoderStream(byteStream); } finally { IOUtils.closeQuietly(encryptedStream); } PGPObjectFactory pgpFactory = new PGPObjectFactory(in); Object o = pgpFactory.nextObject(); // the first object might be a PGP marker packet PGPEncryptedDataList enc; if (o instanceof PGPEncryptedDataList) { enc = (PGPEncryptedDataList) o; } else { enc = (PGPEncryptedDataList) pgpFactory.nextObject(); } IOHelper.close(in); PGPPublicKeyEncryptedData pbe = null; PGPPrivateKey key = null; // find encrypted data for which a private key exists in the secret key ring for (int i = 0; i &lt; enc.size() &amp;&amp; key == null; i++) { pbe = (PGPPublicKeyEncryptedData) enc.get(i); key = PGPDataFormatUtil.findPrivateKeyWithKeyId(exchange.getContext(), findKeyFileName(exchange), findEncryptionKeyRing(exchange), pbe.getKeyID(), findKeyPassword(exchange), getPassphraseAccessor(), getProvider()); } if (key == null) { throw new PGPException("Provided input is encrypted with unknown pair of keys."); } InputStream encData = pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(getProvider()).build(key)); pgpFactory = new PGPObjectFactory(encData); PGPCompressedData comData = (PGPCompressedData) pgpFactory.nextObject(); pgpFactory = new PGPObjectFactory(comData.getDataStream()); Object object = pgpFactory.nextObject(); PGPOnePassSignature signature; if (object instanceof PGPOnePassSignatureList) { signature = getSignature(exchange, (PGPOnePassSignatureList) object); object = pgpFactory.nextObject(); } else { signature = null; } PGPLiteralData ld = (PGPLiteralData) object; InputStream litData = ld.getInputStream(); // TODO we should enable streaming here with CashedOutputStream!! byte[] answer; try { answer = Streams.readAll(litData); } finally { IOHelper.close(litData, encData, in); } if (signature != null) { signature.update(answer); PGPSignatureList sigList = (PGPSignatureList) pgpFactory.nextObject(); if (!signature.verify(getSignatureWithKeyId(signature.getKeyID(), sigList))) { throw new SignatureException("Cannot verify PGP signature"); } } return answer; </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>