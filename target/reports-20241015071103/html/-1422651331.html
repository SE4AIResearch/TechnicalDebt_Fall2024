<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2821</td> 
     <td>-1422651331</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>13a454b27d55d11c6560b7ecf8a567e4768da827</td> 
     <td>error occurred so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>process(Exchange, AsyncCallback)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback)</td> 
     <td> final RedeliveryData data = new RedeliveryData(); // do a defensive copy of the original Exchange, which is needed for redelivery so we can ensure the // original Exchange is being redelivered, and not a mutated Exchange data.original = defensiveCopyExchangeIfNeeded(exchange); // use looping to have redelivery attempts while (true) { // can we still run if (!isRunAllowed(data)) { log.trace("Run not allowed, will reject executing exchange: {}", exchange); if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } // we cannot process so invoke callback callback.done(data.sync); return data.sync; } // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we are exhausted, and whether redelivery is allowed boolean exhausted = isExhausted(exchange, data); boolean redeliverAllowed = isRedeliveryAllowed(data); // if we are exhausted or redelivery is not allowed, then deliver to failure processor (eg such as DLC) if (!redeliverAllowed || exhausted) { Processor target = null; boolean deliver = true; // the unit of work may have an optional callback associated we need to leverage SubUnitOfWorkCallback uowCallback = exchange.getUnitOfWork().getSubUnitOfWorkCallback(); if (uowCallback != null) { // signal to the callback we are exhausted uowCallback.onExhausted(exchange); // do not deliver to the failure processor as its been handled by the callback instead deliver = false; } if (deliver) { // should deliver to failure processor (either from onException or the dead letter channel) target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; } // we should always invoke the deliverToFailureProcessor as it prepares, logs and does a fair // bit of work for exhausted exchanges (its only the target processor which may be null if handled by a savepoint) boolean isDeadLetterChannel = isDeadLetterChannel() &amp;&amp; target == data.deadLetterProcessor; boolean sync = deliverToFailureProcessor(target, isDeadLetterChannel, exchange, data, callback); // we are breaking out return sync; } if (data.redeliveryCounter &gt; 0) { // calculate delay data.redeliveryDelay = determineRedeliveryDelay(exchange, data.currentRedeliveryPolicy, data.redeliveryDelay, data.redeliveryCounter); if (data.redeliveryDelay &gt; 0) { // okay there is a delay so create a scheduled task to have it executed in the future if (data.currentRedeliveryPolicy.isAsyncDelayedRedelivery() &amp;&amp; !exchange.isTransacted()) { // we are doing a redelivery then a thread pool must be configured (see the doStart method) ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this); // let the RedeliverTask be the logic which tries to redeliver the Exchange which we can used a scheduler to // have it being executed in the future, or immediately // we are continuing asynchronously // mark we are routing async from now and that this redelivery task came from a synchronous routing data.sync = false; data.redeliverFromSync = true; AsyncRedeliveryTask task = new AsyncRedeliveryTask(exchange, callback, data); // schedule the redelivery task if (log.isTraceEnabled()) { log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", data.redeliveryDelay, exchange.getExchangeId()); } executorService.schedule(task, data.redeliveryDelay, TimeUnit.MILLISECONDS); return false; } else { // async delayed redelivery was disabled or we are transacted so we must be synchronous // as the transaction manager requires to execute in the same thread context try { data.currentRedeliveryPolicy.sleep(data.redeliveryDelay); } catch (InterruptedException e) { // we was interrupted so break out exchange.setException(e); // mark the exchange to stop continue routing when interrupted // as we do not want to continue routing (for example a task has been cancelled) exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE); callback.done(data.sync); return data.sync; } } } // prepare for redelivery prepareExchangeForRedelivery(exchange, data); // letting onRedeliver be executed deliverToOnRedeliveryProcessor(exchange, data); // emmit event we are doing redelivery EventHelper.notifyExchangeRedelivery(exchange.getContext(), exchange, data.redeliveryCounter); } // process the exchange (also redelivery) boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // if we are done then notify callback and exit if (isDone(exchange)) { callback.done(sync); return; } // error occurred so loop back around which we do by invoking the processAsyncErrorHandler // method which takes care of this in a asynchronous manner processAsyncErrorHandler(exchange, callback, data); } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } // we continue to route synchronously // if we are done then notify callback and exit boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1893</td> 
     <td>-1422651331</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>a24f83b12e90ce52f41c256dea6e4b9b7528ee2a</td> 
     <td>error occurred so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // did previous processing cause an exception? boolean handle = shouldHandleException(exchange); if (handle) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // no we should not redeliver to the same output so either try an onException (if any given) // or the dead letter queue Processor target = data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor; // deliver to the failure processor (either an on exception or dead letter queue deliverToFailureProcessor(target, exchange, data); // prepare the exchange for failure before returning prepareExchangeAfterFailure(exchange, data); // fire event if we had a failure processor to handle it if (target != null) { boolean deadLetterChannel = target == data.deadLetterProcessor &amp;&amp; data.deadLetterProcessor != null; EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, target, deadLetterChannel); } boolean shouldContinue = shouldContinue(exchange, data); if (shouldContinue) { // okay we want to continue then prepare the exchange for that as well prepareExchangeForContinue(exchange, data); } // and then return return data.sync; } if (shouldRedeliver &amp;&amp; data.redeliveryCounter &gt; 0) { // prepare for redelivery prepareExchangeForRedelivery(exchange); // if we are redelivering then sleep before trying again // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { if (log.isDebugEnabled()) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); } // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange (also redelivery) boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // this callback should only handle the async case if (sync) { return; } // mark we are in async mode now data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (!isDone(exchange)) { // TODO: async process redelivery (eg duplicate the error handler logic) // And have a timer task scheduled when redelivery should occur to avoid blocking thread } else { callback.done(sync); } } }); if (!sync) { // the remainder of the Exchange is being processed asynchronously so we should return return false; } boolean done = isDone(exchange); if (done) { callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1404</td> 
     <td>-1422651331</td>
     <td>apache/camel</td>
     <td>William Tam</td>
     <td>7aa107f96e03eed7f231a5799019de46296df91f</td> 
     <td>error occurred so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>SATD_MOVED_FILE</td> 
     <td>processErrorHandler(Exchange, RedeliveryData)</td> 
     <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); return; } } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { // TODO: divde into onException and deadLetterQueue // no then move it to the dead letter queue deliverToFailureProcessor(exchange, data); // prepare the exchange for failure prepareExchangeAfterFailure(exchange, data); // we could not process the exchange succesfully so break return; } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange try { output.process(exchange); } catch (Exception e) { exchange.setException(e); } // only process if the exchange hasn't failed // and it has not been handled by the error processor boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange); if (done) { return; } // error occurred so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>