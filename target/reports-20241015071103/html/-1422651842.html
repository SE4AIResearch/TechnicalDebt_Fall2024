<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1283</td> 
     <td>-1422651842</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>b64e8a8c4b15c88b0cb86c5b64f1ed1c8d1292cd</td> 
     <td>error occurred so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>processErrorHandler(Exchange, RedeliveryData)</td> 
     <td>protected void processErrorHandler(final Exchange exchange, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { deliverToFaultProcessor(exchange, data); // we should not try redeliver so we are finished return; } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, data); } // process the exchange try { output.process(exchange); } catch (Exception e) { exchange.setException(e); } // only process if the exchange hasn't failed // and it has not been handled by the error processor boolean done = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange); if (done) { return; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1214</td> 
     <td>-1422651842</td> 
     <td>apache/camel</td> 
     <td>James Strachan</td> 
     <td>f599b0649a49dbbaf02e7fb299228054921f99cb</td> 
     <td>error occurred so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>processErrorHandler(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>protected boolean processErrorHandler(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // we can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (log.isDebugEnabled()) { log.debug("Rejected execution as we are not started for exchange: " + exchange); } if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } // do not handle transacted exchanges that failed as this error handler does not support it if (exchange.isTransacted() &amp;&amp; !supportTransacted() &amp;&amp; exchange.getException() != null) { if (log.isDebugEnabled()) { log.debug("This error handler does not support transacted exchanges." + " Bypassing this error handler: " + this + " for exchangeId: " + exchange.getExchangeId()); } return data.sync; } // did previous processing caused an exception? if (exchange.getException() != null) { handleException(exchange, data); } // compute if we should redeliver or not boolean shouldRedeliver = shouldRedeliver(exchange, data); if (!shouldRedeliver) { return deliverToFaultProcessor(exchange, callback, data); } // if we are redelivering then sleep before trying again if (data.redeliveryCounter &gt; 0) { prepareExchangeForRedelivery(exchange); // wait until we should redeliver try { data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay, data.redeliveryCounter); } catch (InterruptedException e) { log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped())); // continue from top continue; } // letting onRedeliver be executed deliverToRedeliveryProcessor(exchange, callback, data); } // process the exchange boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; // only process if the exchange hasn't failed // and it has not been handled by the error processor if (exchange.getException() != null &amp;&amp; !ExchangeHelper.isFailureHandled(exchange)) { // TODO Call the Timer for the asyncProcessor asyncProcess(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>593</td> 
     <td>-1422651842</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>b640efdd6c0f0a87895d951e4b36415ab1c15483</td> 
     <td>error occured so loop back around.....</td> 
     <td>error occurred so loop back around.....</td> 
     <td>SATD_CHANGED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { // We can't keep retrying if the route is being shutdown. if (!isRunAllowed()) { if (exchange.getException() == null) { exchange.setException(new RejectedExecutionException()); } callback.done(data.sync); return data.sync; } if (exchange.getException() != null) { Throwable e = exchange.getException(); // Reset it since we are handling it. exchange.setException(null); logger.log("Failed delivery for exchangeId: " + exchange.getExchangeId() + ". On delivery attempt: " + data.redeliveryCounter + " caught: " + e, e); data.redeliveryCounter = incrementRedeliveryCounter(exchange, e); ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e); if (exceptionPolicy != null) { data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy); Processor processor = exceptionPolicy.getErrorHandler(); if (processor != null) { data.failureProcessor = processor; } } } if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) { setFailureHandled(exchange, true); AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor); boolean sync = afp.process(exchange, new AsyncCallback() { public void done(boolean sync) { restoreExceptionOnExchange(exchange); callback.done(data.sync); } }); restoreExceptionOnExchange(exchange); logger.log("Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Handled by the failure processor: " + data.failureProcessor); return sync; } if (data.redeliveryCounter &gt; 0) { // Figure out how long we should wait to resend this message. data.redeliveryDelay = data.currentRedeliveryPolicy.getRedeliveryDelay(data.redeliveryDelay); sleep(data.redeliveryDelay); } exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, exchange.getException()); exchange.setException(null); boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } data.sync = false; if (exchange.getException() != null) { process(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null || isFailureHandled(exchange)) { // If everything went well.. then we exit here.. callback.done(true); return true; } // error occurred so loop back around..... } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>393</td> 
     <td>-1422651842</td>
     <td>apache/camel</td>
     <td>James Strachan</td>
     <td>d2898cb66ced806cba53e27f23f99f0f20c6cabb</td> 
     <td>None</td> 
     <td>error occured so loop back around.....</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange, AsyncCallback, RedeliveryData)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data)</td> 
     <td> while (true) { if (exchange.getException() != null) { Throwable e = exchange.getException(); // Reset it since we are handling it. exchange.setException(null); logger.log("On delivery attempt: " + data.redeliveryCounter + " caught: " + e, e); data.redeliveryCounter = incrementRedeliveryCounter(exchange, e); ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e); if (exceptionPolicy != null) { data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy); Processor processor = exceptionPolicy.getErrorHandler(); if (processor != null) { data.failureProcessor = processor; } } } if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) { AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor); return afp.process(exchange, callback); } if (data.redeliveryCounter &gt; 0) { // Figure out how long we should wait to resend this message. data.redeliveryDelay = data.currentRedeliveryPolicy.getRedeliveryDelay(data.redeliveryDelay); sleep(data.redeliveryDelay); } boolean sync = outputAsync.process(exchange, new AsyncCallback() { public void done(boolean sync) { // Only handle the async case... if (sync) { return; } if (exchange.getException() != null) { process(exchange, callback, data); } else { callback.done(sync); } } }); if (!sync) { // It is going to be processed async.. return false; } if (exchange.getException() == null) { // If everything went well.. then we exit here.. return true; } // error occured so loop back around..... } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>