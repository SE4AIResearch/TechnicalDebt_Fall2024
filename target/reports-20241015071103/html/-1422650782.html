<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2385</td> <td>-1422650782</td><td>apache/camel</td><td>William Tam</td><td>414d6c8eb763c8916ea6d74a61dcd23f2f3ae0e8</td> <td>None</td> <td>based on the parameter types the binary operator support, we need to set this state into
the following booleans so we know how to proceed in the grammar</td> <td>SATD_ADDED</td> <td>binaryOperator()</td> <td>protected boolean binaryOperator()</td> <td>
    if (accept(TokenType.binaryOperator)) {
        // remember the binary operator
        BinaryOperatorType operatorType = BinaryOperatorType.asOperator(token.getText());
        nextToken();
        // there should be at least one whitespace after the operator
        expectAndAcceptMore(TokenType.whiteSpace);
        // okay a binary operator may not support all kind if preceding parameters, so we need to limit this
        BinaryOperatorType.ParameterType[] types = BinaryOperatorType.supportedParameterTypes(operatorType);
        // based on the parameter types the binary operator support, we need to set this state into
        // the following booleans so we know how to proceed in the grammar
        boolean literalWithFunctionsSupported = false;
        boolean literalSupported = false;
        boolean functionSupported = false;
        boolean numericSupported = false;
        boolean booleanSupported = false;
        boolean nullSupported = false;
        if (types == null || types.length == 0) {
            literalWithFunctionsSupported = true;
            // favor literal with functions over literals without functions
            literalSupported = false;
            functionSupported = true;
            numericSupported = true;
            booleanSupported = true;
            nullSupported = true;
        } else {
            for (BinaryOperatorType.ParameterType parameterType : types) {
                literalSupported |= parameterType.isLiteralSupported();
                literalWithFunctionsSupported |= parameterType.isLiteralWithFunctionSupport();
                functionSupported |= parameterType.isFunctionSupport();
                nullSupported |= parameterType.isNumericValueSupported();
                booleanSupported |= parameterType.isBooleanValueSupported();
                nullSupported |= parameterType.isNullValueSupported();
            }
        }
        // then we proceed in the grammar according to the parameter types supported by the given binary operator
        // CHECKSTYLE:OFF
        if ((literalWithFunctionsSupported && singleQuotedLiteralWithFunctionsText()) || (literalWithFunctionsSupported && doubleQuotedLiteralWithFunctionsText()) || (literalSupported && singleQuotedLiteralText()) || (literalSupported && doubleQuotedLiteralText()) || (functionSupported && functionText()) || (numericSupported && numericValue()) || (booleanSupported && booleanValue()) || (nullSupported && nullValue())) {
            // then after the right hand side value, there should be a whitespace if there is more tokens
            nextToken();
            if (!token.getType().isEol()) {
                expect(TokenType.whiteSpace);
            }
        } else {
            throw new SimpleParserException("Binary operator " + operatorType + " does not support token " + token, token.getIndex());
        }
        // CHECKSTYLE:ON
        return true;
    }
    return false;
</td> </tr></table></body></html>