<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>7</td> <td>-1413930550</td><td>apache/log4j</td><td>Ceki Gulcu</td><td>8ed4ea15ad019c57010ed9378838cd6e1792d267</td> <td>None</td> <td>The information contained within the request is another source of
distinctive information. It might reveal the users name, date of request,
request ID etc. In servlet type environments, much information is
contained in cookies.</td> <td>SATD_ADDED</td> <td>factor(int)</td> <td>public int[] factor(int number) throws RemoteException</td> <td>
    // The client's host is an important source of information.
    try {
        NDC.push(this.getClientHost());
    } catch (java.rmi.server.ServerNotActiveException e) {
        // we are being called from same VM
        NDC.push("localhost");
    }
    // The information contained within the request is another source of
    // distinctive information. It might reveal the users name, date of request,
    // request ID etc. In servlet type environments, much information is
    // contained in cookies.
    NDC.push(String.valueOf(number));
    cat.info("Beginning to factor.");
    if (number <= 0) {
        throw new IllegalArgumentException(number + " is not a positive integer.");
    } else if (number == 1)
        return new int[] { 1 };
    Vector factors = new Vector();
    int n = number;
    for (int i = 2; (i <= n) && (i * i <= number); i++) {
        // It is bad practice to place log requests within tight loops.
        // It is done here to show interleaved log output from
        // different requests.
        cat.debug("Trying to see if " + i + " is a factor.");
        if ((n % i) == 0) {
            cat.info("Found factor " + i);
            factors.addElement(new Integer(i));
            do {
                n /= i;
            } while ((n % i) == 0);
        }
        // Placing artificial delays in tight-loops will also lead to sub-optimal
        // resuts. :-)
        delay(100);
    }
    if (n != 1) {
        cat.info("Found factor " + n);
        factors.addElement(new Integer(n));
    }
    int len = factors.size();
    int[] result = new int[len];
    for (int i = 0; i < len; i++) {
        result[i] = ((Integer) factors.elementAt(i)).intValue();
    }
    // Before leaving a thread we call NDC.remove. This deletes the reference
    // to the thread in the internal hash table. Version 0.8.5 introduces a
    // a lazy removal mechanism in case you forget to call remove when
    // exiting a thread. See the java documentation in NDC.remove for further
    // details.
    NDC.remove();
    return result;
</td> </tr></table></body></html>