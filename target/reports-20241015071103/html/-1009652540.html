<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5057</td> <td>-1009652540</td><td>apache/hadoop</td><td>Thomas White</td><td>7a9ec5d90b55076c1e59249f13ac75030090b55a</td> <td>This may have been a misparse. java.net.URI specifies that
a URI is of the form:
URI ::= [SCHEME-PART:]SCHEME-SPECIFIC-PART

The scheme-specific-part may be parsed in numerous ways, but if
it starts with a '/' character, that makes it a \"hierarchical URI\",
subject to the following parsing:
SCHEME-SPECIFIC-PART ::= \"//\" AUTHORITY-PART
AUTHORITY-PART ::= [USER-INFO-PART] HOSTNAME [ \":\" PORT ]

In Hadoop, we require a host-based authority as well.
java.net.URI parses left-to-right, so deprecated hostnames of the
form 'foo:8020' will have 'foo' as their scheme and '8020' as their
scheme-specific-part. We don't want this behavior.</td> <td>unqualified is \"hdfs://\"</td> <td>SATD_REMOVED</td> <td>get(Configuration)</td> <td>public static FileSystem get(Configuration conf) throws IOException</td> <td>
    return get(getDefaultUri(conf), conf);
</td> </tr></table></body></html>