<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>3885</td> 
     <td>-1422649942</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>9bfad3cb84679a4bebb5861833a8bc752c3139e8</td> 
     <td>TODO: why only object or text messages?</td> 
     <td>TODO: why only object or text messages?</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>consumeBatchesOnLoop(Session, MessageConsumer)</td> 
     <td>private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer) throws JMSException</td> 
     <td> final boolean usingTimeout = completionTimeout &gt; 0; LOG.trace("BatchConsumptionTask +++ start +++"); while (running.get()) { LOG.trace("BatchConsumptionTask running"); if (timeout.compareAndSet(true, false) || timeoutInterval.compareAndSet(true, false)) { // trigger timeout LOG.trace("Completion batch due timeout"); completionBatch(session); reset(); continue; } if (completionSize &gt; 0 &amp;&amp; messageCount &gt;= completionSize) { // trigger completion size LOG.trace("Completion batch due size"); completionBatch(session); reset(); continue; } // check periodically to see whether we should be shutting down long waitTime = (usingTimeout &amp;&amp; (timeElapsed &gt; 0)) ? getReceiveWaitTime(timeElapsed) : pollDuration; Message message = consumer.receive(waitTime); if (running.get()) { // no interruptions received if (message == null) { // timed out, no message received LOG.trace("No message received"); } else { messageCount++; LOG.debug("#{} messages received", messageCount); if (usingTimeout &amp;&amp; startTime == 0) { // this is the first message start counting down the period for this batch startTime = new Date().getTime(); } // TODO: why only object or text messages? if (message instanceof ObjectMessage || message instanceof TextMessage) { final Exchange exchange = getEndpoint().createExchange(message, session); aggregatedExchange = aggregationStrategy.aggregate(aggregatedExchange, exchange); aggregatedExchange.setProperty(SjmsBatchEndpoint.PROPERTY_BATCH_SIZE, messageCount); } else { throw new IllegalArgumentException("Unexpected message type: " + message.getClass().toString()); } } if (usingTimeout &amp;&amp; startTime &gt; 0) { // a batch has been started, check whether it should be timed out long currentTime = new Date().getTime(); timeElapsed = currentTime - startTime; if (timeElapsed &gt; completionTimeout) { // batch finished by timeout timeout.set(true); } else { LOG.trace("This batch has more time until the timeout, elapsed: {} timeout: {}", timeElapsed, completionTimeout); } } } else { LOG.info("Shutdown signal received - rolling back batch"); session.rollback(); } } LOG.trace("BatchConsumptionTask +++ end +++"); </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>3884</td> 
     <td>-1422649942</td>
     <td>apache/camel</td>
     <td>Andrea Cosentino</td>
     <td>cf288b6a1ce8828ea500077f55161c67c4d95a33</td> 
     <td>None</td> 
     <td>TODO: why only object or text messages?</td> 
     <td>SATD_ADDED</td> 
     <td>consumeBatchesOnLoop(Session, MessageConsumer, AtomicBoolean)</td> 
     <td>private void consumeBatchesOnLoop(final Session session, final MessageConsumer consumer, final AtomicBoolean timeoutInterval) throws JMSException</td> 
     <td> final boolean usingTimeout = completionTimeout &gt; 0; batchConsumption: while (running.get()) { // reset the state boolean timeout = false; int messageCount = 0; long timeElapsed = 0; long startTime = 0; Exchange aggregatedExchange = null; batch: // loop while no timeout or interval triggered and while we have room still for messages in the batch while (!timeout &amp;&amp; !timeoutInterval.compareAndSet(true, false) &amp;&amp; (usingTimeout || (completionSize &gt; 0 &amp;&amp; messageCount &lt; completionSize))) { // check periodically to see whether we should be shutting down long waitTime = (usingTimeout &amp;&amp; (timeElapsed &gt; 0)) ? getReceiveWaitTime(timeElapsed) : pollDuration; Message message = consumer.receive(waitTime); if (running.get()) { // no interruptions received if (message == null) { // timed out, no message received LOG.trace("No message received"); } else { if (usingTimeout &amp;&amp; messageCount == 0) { // this is the first message // start counting down the period for this batch startTime = new Date().getTime(); } messageCount++; LOG.debug("#{} messages received", messageCount); // TODO: why only object or text messages? if (message instanceof ObjectMessage || message instanceof TextMessage) { final Exchange exchange = getEndpoint().createExchange(message, session); aggregatedExchange = aggregationStrategy.aggregate(aggregatedExchange, exchange); aggregatedExchange.setProperty(SjmsBatchEndpoint.PROPERTY_BATCH_SIZE, messageCount); } else { throw new IllegalArgumentException("Unexpected message type: " + message.getClass().toString()); } } if (usingTimeout &amp;&amp; startTime &gt; 0) { // a batch has been started, check whether it should be timed out long currentTime = new Date().getTime(); timeElapsed = currentTime - startTime; if (timeElapsed &gt; completionTimeout) { // batch finished by timeout timeout = true; } } } else { LOG.info("Shutdown signal received - rolling batch back"); session.rollback(); break batchConsumption; } } // batch if (aggregatedExchange == null &amp;&amp; getEndpoint().isSendEmptyMessageWhenIdle()) { processEmptyMessage(); } else if (aggregatedExchange != null) { processBatch(aggregatedExchange, session); } } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>