<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>1739</td> 
     <td>-1422651157</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>cb59b662bfc011453aa2e12907ee650542966233</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>let the prepared process it</td> 
     <td>SATD_REMOVED</td> 
     <td>doProcess(Processor, Processor, Exchange)</td> 
     <td>private void doProcess(Processor processor, Processor prepared, Exchange exchange)</td> 
     <td> TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null; // compute time taken if sending to another endpoint long start = 0; if (processor instanceof Producer) { start = System.currentTimeMillis(); } try { // prepare tracing starting from a new block if (traced != null) { traced.pushBlock(); } // let the prepared process it prepared.process(exchange); } catch (Exception e) { exchange.setException(e); } finally { // pop the block so by next round we have the same staring point and thus the tracing looks accurate if (traced != null) { traced.popBlock(); } if (processor instanceof Producer) { long timeTaken = System.currentTimeMillis() - start; Endpoint endpoint = ((Producer) processor).getEndpoint(); // emit event that the exchange was sent to the endpoint EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken); } } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1701</td> 
     <td>-1422651157</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>0a881b9f5553477a844e71c0718b8c8ddc0c8fc2</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinitionHelper.wrapInErrorHandler)</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinition.wrapInErrorHandler)</td> 
     <td>SATD_CHANGED</td> 
     <td>doProcess(Processor, Exchange)</td> 
     <td>private void doProcess(Processor producer, Exchange exchange)</td> 
     <td> TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null; try { // prepare tracing starting from a new block if (traced != null) { traced.pushBlock(); } // set property which endpoint we send to setToEndpoint(exchange, producer); if (exchange.getUnitOfWork() != null &amp;&amp; exchange.getUnitOfWork().getRouteContext() != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again RouteContext routeContext = exchange.getUnitOfWork().getRouteContext(); ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinition.wrapInErrorHandler) producer = builder.createErrorHandler(routeContext, producer); } // let the producer process it producer.process(exchange); } catch (Exception e) { exchange.setException(e); } finally { // pop the block so by next round we have the same staring point and thus the tracing looks accurate if (traced != null) { traced.popBlock(); } } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1700</td> 
     <td>-1422651157</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>4166ac74981605c86956a503d9d13ce5654b02ba</td> 
     <td>None</td> 
     <td>create error handler (create error handler directly to keep it light weight, instead of using ProcessorDefinitionHelper.wrapInErrorHandler)</td> 
     <td>SATD_ADDED</td> 
     <td>doProcess(Processor, Exchange)</td> 
     <td>private void doProcess(Processor producer, Exchange exchange)</td> 
     <td> TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null; try { // prepare tracing starting from a new block if (traced != null) { traced.pushBlock(); } // set property which endpoint we send to setToEndpoint(exchange, producer); if (exchange.getUnitOfWork() != null &amp;&amp; exchange.getUnitOfWork().getRouteContext() != null) { // wrap the producer in error handler so we have fine grained error handling on // the output side instead of the input side // this is needed to support redelivery on that output alone and not doing redelivery // for the entire multicast block again which will start from scratch again RouteContext routeContext = exchange.getUnitOfWork().getRouteContext(); ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder(); // create error handler (create error handler directly to keep it light weight, // instead of using ProcessorDefinitionHelper.wrapInErrorHandler) producer = builder.createErrorHandler(routeContext, producer); } // let the producer process it producer.process(exchange); } catch (Exception e) { exchange.setException(e); } finally { // pop the block so by next round we have the same staring point and thus the tracing looks accurate if (traced != null) { traced.popBlock(); } } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>