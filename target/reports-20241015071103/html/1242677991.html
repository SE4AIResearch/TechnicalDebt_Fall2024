<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>4799</td> 
     <td>1242677991</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Edwin Kempin</td>
     <td>e326a1dada8a2705a33f50921dc2b921a4ce3917</td> 
     <td>TODO(yyonas): atomic update was not propagated</td> 
     <td>TODO(yyonas): atomic update was not propagated</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>abandon(ChangeControl, String, Account)</td> 
     <td>public Change abandon(ChangeControl control, String msgTxt, Account acc) throws ResourceConflictException, OrmException, IOException</td> 
     <td> Change change; ChangeMessage message; ChangeUpdate update; Change.Id changeId = control.getChange().getId(); ReviewDb db = dbProvider.get(); db.changes().beginTransaction(changeId); try { change = db.changes().atomicUpdate(changeId, new AtomicUpdate<change>
       () { @Override public Change update(Change change) { if (change.getStatus().isOpen()) { change.setStatus(Change.Status.ABANDONED); ChangeUtil.updated(change); return change; } return null; } }); if (change == null) { throw new ResourceConflictException("change is " + status(db.changes().get(changeId))); } // TODO(yyonas): atomic update was not propagated update = updateFactory.create(control, change.getLastUpdatedOn()); message = newMessage(msgTxt, acc != null ? acc.getId() : null, change); cmUtil.addChangeMessage(db, update, message); db.commit(); } finally { db.rollback(); } update.commit(); indexer.index(db, change); try { ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId()); if (acc != null) { cm.setFrom(acc.getId()); } cm.setChangeMessage(message); cm.send(); } catch (Exception e) { log.error("Cannot email update for change " + change.getChangeId(), e); } hooks.doChangeAbandonedHook(change, acc, db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(msgTxt), db); return change; 
      </change></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>4646</td> 
     <td>1242677991</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Dave Borowitz</td>
     <td>086006ec35ef2a5bddb14a3a4ef427ad6085b01e</td> 
     <td>None</td> 
     <td>TODO(yyonas): atomic update was not propagated</td> 
     <td>SATD_ADDED</td> 
     <td>apply(ChangeResource, AbandonInput)</td> 
     <td>public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException</td> 
     <td> ChangeControl control = req.getControl(); IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser(); Change change = req.getChange(); if (!control.canAbandon()) { throw new AuthException("abandon not permitted"); } else if (!change.getStatus().isOpen()) { throw new ResourceConflictException("change is " + status(change)); } else if (change.getStatus() == Change.Status.DRAFT) { throw new ResourceConflictException("draft changes cannot be abandoned"); } ChangeMessage message; ChangeUpdate update; ReviewDb db = dbProvider.get(); db.changes().beginTransaction(change.getId()); try { change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<change>
       () { @Override public Change update(Change change) { if (change.getStatus().isOpen()) { change.setStatus(Change.Status.ABANDONED); ChangeUtil.updated(change); return change; } return null; } }); if (change == null) { throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId()))); } // TODO(yyonas): atomic update was not propagated update = updateFactory.create(control, change.getLastUpdatedOn()); message = newMessage(input, caller, change); cmUtil.addChangeMessage(db, update, message); db.commit(); } finally { db.rollback(); } update.commit(); CheckedFuture<!--?, IOException--> indexFuture = indexer.indexAsync(change.getId()); try { ReplyToChangeSender cm = abandonedSenderFactory.create(change); cm.setFrom(caller.getAccountId()); cm.setChangeMessage(message); cm.send(); } catch (Exception e) { log.error("Cannot email update for change " + change.getChangeId(), e); } hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db); ChangeInfo result = json.format(change); indexFuture.checkedGet(); return result; 
      </change></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>