<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>6070</td> 
     <td>-1009652499</td> 
     <td>apache/hadoop</td> 
     <td>Arun Murthy</td> 
     <td>0f6dfeeacbab65a31a33927a4eb84871d371fe52</td> 
     <td>TO DO: - more efficient to not split the path, but simply compare</td> 
     <td>TO DO: - more efficient to not split the path, but simply compare</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>resolve(String, boolean)</td> 
     <td> // TO DO: - more efficient to not split the path, but simply compare String[] path = breakIntoPathComponents(p); if (path.length &lt;= 1) { // special case for when path is "/" ResolveResult<t>
        res = new ResolveResult 
       <t>
         (ResultKind.isInternalDir, root.InodeDirFs, root.fullPath, SlashPath); return res; } INodeDir 
        <t>
          curInode = root; int i; // ignore first slash for (i = 1; i &lt; path.length - (resolveLastComponent ? 0 : 1); i++) { INode 
         <t>
           nextInode = curInode.resolveInternal(path[i]); if (nextInode == null) { StringBuilder failedAt = new StringBuilder(path[0]); for (int j = 1; j &lt;= i; ++j) { failedAt.append('/').append(path[j]); } throw (new FileNotFoundException(failedAt.toString())); } if (nextInode instanceof INodeLink) { final INodeLink 
          <t>
            link = (INodeLink 
           <t>
             ) nextInode; final Path remainingPath; if (i &gt;= path.length - 1) { remainingPath = SlashPath; } else { StringBuilder remainingPathStr = new StringBuilder("/" + path[i + 1]); for (int j = i + 2; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult 
            <t>
              res = new ResolveResult 
             <t>
               (ResultKind.isExternalDir, link.targetFileSystem, nextInode.fullPath, remainingPath); return res; } else if (nextInode instanceof INodeDir) { curInode = (INodeDir 
              <t>
                ) nextInode; } } // We have resolved to an internal dir in mount table. Path remainingPath; if (resolveLastComponent) { remainingPath = SlashPath; } else { // note we have taken care of when path is "/" above // for internal dirs rem-path does not start with / since the lookup // that follows will do a children.get(remaningPath) and will have to // strip-out the initial / StringBuilder remainingPathStr = new StringBuilder("/" + path[i]); for (int j = i + 1; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult 
               <t>
                 res = new ResolveResult 
                <t>
                  (ResultKind.isInternalDir, curInode.InodeDirFs, curInode.fullPath, remainingPath); return res; 
                </t> 
               </t> 
              </t> 
             </t> 
            </t> 
           </t> 
          </t> 
         </t> 
        </t> 
       </t> 
      </t></td> 
     <td> ResolveResult<t>
        resolve(final String p, final boolean resolveLastComponent) throws FileNotFoundException 
      </t></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>5171</td> 
     <td>-1009652499</td> 
     <td>apache/hadoop</td> 
     <td>Eli Collins</td> 
     <td>a196766ea07775f18ded69bd9e8d239f8cfd3ccc</td> 
     <td>TO DO: - more efficient to not split the path, but simply compare</td> 
     <td>TO DO: - more efficient to not split the path, but simply compare</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>resolve(String, boolean)</td> 
     <td> // TO DO: - more efficient to not split the path, but simply compare String[] path = breakIntoPathComponents(p); if (path.length &lt;= 1) { // special case for when path is "/" ResolveResult<t>
        res = new ResolveResult 
       <t>
         (ResultKind.isInternalDir, root.InodeDirFs, root.fullPath, SlashPath); return res; } INodeDir 
        <t>
          curInode = root; int i; // ignore first slash for (i = 1; i &lt; path.length - (resolveLastComponent ? 0 : 1); i++) { INode 
         <t>
           nextInode = curInode.resolveInternal(path[i]); if (nextInode == null) { StringBuilder failedAt = new StringBuilder(path[0]); for (int j = 1; j &lt;= i; ++j) { failedAt.append('/').append(path[j]); } throw (new FileNotFoundException(failedAt.toString())); } if (nextInode instanceof INodeLink) { final INodeLink 
          <t>
            link = (INodeLink 
           <t>
             ) nextInode; final Path remainingPath; if (i &gt;= path.length - 1) { remainingPath = SlashPath; } else { StringBuilder remainingPathStr = new StringBuilder("/" + path[i + 1]); for (int j = i + 2; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult 
            <t>
              res = new ResolveResult 
             <t>
               (ResultKind.isExternalDir, link.targetFileSystem, nextInode.fullPath, remainingPath); return res; } else if (nextInode instanceof INodeDir) { curInode = (INodeDir 
              <t>
                ) nextInode; } } // We have resolved to an internal dir in mount table. Path remainingPath; if (resolveLastComponent) { remainingPath = SlashPath; } else { // note we have taken care of when path is "/" above // for internal dirs rem-path does not start with / since the lookup // that follows will do a children.get(remaningPath) and will have to // strip-out the initial / StringBuilder remainingPathStr = new StringBuilder("/" + path[i]); for (int j = i + 1; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult 
               <t>
                 res = new ResolveResult 
                <t>
                  (ResultKind.isInternalDir, curInode.InodeDirFs, curInode.fullPath, remainingPath); return res; 
                </t> 
               </t> 
              </t> 
             </t> 
            </t> 
           </t> 
          </t> 
         </t> 
        </t> 
       </t> 
      </t></td> 
     <td> ResolveResult<t>
        resolve(final String p, final boolean resolveLastComponent) throws FileNotFoundException 
      </t></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>5121</td> 
     <td>-1009652499</td>
     <td>apache/hadoop</td>
     <td>Tsz-wo Sze</td>
     <td>f1c74df922058e88791ed6971bbb96b53f6770f1</td> 
     <td>None</td> 
     <td>TO DO: - more efficient to not split the path, but simply compare</td> 
     <td>SATD_ADDED</td> 
     <td>resolve(String, boolean)</td> 
     <td> // TO DO: - more efficient to not split the path, but simply compare String[] path = breakIntoPathComponents(p); if (path.length &lt;= 1) { // special case for when path is "/" ResolveResult<t>
        res = new ResolveResult
       <t>
        (ResultKind.isInternalDir, root.InodeDirFs, root.fullPath, SlashPath); return res; } INodeDir
        <t>
          curInode = root; int i; // ignore first slash for (i = 1; i &lt; path.length - (resolveLastComponent ? 0 : 1); i++) { INode
         <t>
           nextInode = curInode.resolveInternal(path[i]); if (nextInode == null) { StringBuilder failedAt = new StringBuilder(path[0]); for (int j = 1; j &lt;= i; ++j) { failedAt.append('/').append(path[j]); } throw (new FileNotFoundException(failedAt.toString())); } if (nextInode instanceof INodeLink) { final INodeLink
          <t>
            link = (INodeLink
           <t>
            ) nextInode; final Path remainingPath; if (i &gt;= path.length - 1) { remainingPath = SlashPath; } else { StringBuilder remainingPathStr = new StringBuilder("/" + path[i + 1]); for (int j = i + 2; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult
            <t>
              res = new ResolveResult
             <t>
              (ResultKind.isExternalDir, link.targetFileSystem, nextInode.fullPath, remainingPath); return res; } else if (nextInode instanceof INodeDir) { curInode = (INodeDir
              <t>
               ) nextInode; } } // We have resolved to an internal dir in mount table. Path remainingPath; if (resolveLastComponent) { remainingPath = SlashPath; } else { // note we have taken care of when path is "/" above // for internal dirs rem-path does not start with / since the lookup // that follows will do a children.get(remaningPath) and will have to // strip-out the initial / StringBuilder remainingPathStr = new StringBuilder("/" + path[i]); for (int j = i + 1; j &lt; path.length; ++j) { remainingPathStr.append('/').append(path[j]); } remainingPath = new Path(remainingPathStr.toString()); } final ResolveResult
               <t>
                 res = new ResolveResult
                <t>
                 (ResultKind.isInternalDir, curInode.InodeDirFs, curInode.fullPath, remainingPath); return res; 
                </t>
               </t>
              </t>
             </t>
            </t>
           </t>
          </t>
         </t>
        </t>
       </t>
      </t></td> 
     <td> ResolveResult<t>
        resolve(final String p, final boolean resolveLastComponent) throws FileNotFoundException
      </t></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>