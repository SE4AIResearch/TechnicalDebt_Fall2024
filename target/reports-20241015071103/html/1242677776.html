<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4792</td> 
     <td>1242677776</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>a3d67882125065c86ae55ccbb45e36d2ca6e453e</td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>makeSiteConfig(SitePaths, Config, SshInfo)</td> 
     <td>private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException</td> 
     <td> if (!Files.exists(site.tmp_dir)) { Files.createDirectories(site.tmp_dir); } Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl"); // To make our configuration file only readable or writable by us; // this reduces the chances of someone tampering with the file. // // TODO(dborowitz): Is there a portable way to do this with NIO? File myconfFile = myconf.toFile(); myconfFile.setWritable(false, false); myconfFile.setReadable(false, false); myconfFile.setExecutable(false, false); myconfFile.setWritable(true, true); myconfFile.setReadable(true, true); myconfFile.deleteOnExit(); _env.set("GIT_DIR", "."); _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString()); try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) { p.print("# Autogenerated by Gerrit Code Review \n"); p.print("# DO NOT EDIT\n"); p.print("\n"); // We are mounted at the same level in the context as the main // UI, so we can include the same header and footer scheme. // Path hdr = site.site_header; if (Files.isRegularFile(hdr)) { p.print("$site_header = " + quoteForPerl(hdr) + ";\n"); } Path ftr = site.site_footer; if (Files.isRegularFile(ftr)) { p.print("$site_footer = " + quoteForPerl(ftr) + ";\n"); } // Top level should return to Gerrit's UI. // p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n"); p.print("$home_link_str = 'Code Review';\n"); p.print("$favicon = 'favicon.ico';\n"); p.print("$logo = 'gitweb-logo.png';\n"); p.print("$javascript = 'gitweb.js';\n"); p.print("@stylesheets = ('gitweb-default.css');\n"); Path css = site.site_css; if (Files.isRegularFile(css)) { p.print("push @stylesheets, 'gitweb-site.css';\n"); } // Try to make the title match Gerrit's normal window title // scheme of host followed by 'Code Review'. // p.print("$site_name = $home_link_str;\n"); p.print("$site_name = qq{$1 $site_name} if "); p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n"); // Assume by default that XSS is a problem, and try to prevent it. // p.print("$prevent_xss = 1;\n"); // Generate URLs using smart http:// // p.print("{\n"); p.print(" my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n"); p.print(" my $http_url = $secure ? 'https://' : 'http://';\n"); p.print(" $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n"); p.print(" unless $ENV{'GERRIT_ANONYMOUS_READ'};\n"); p.print(" $http_url .= $ENV{'SERVER_NAME'};\n"); p.print(" $http_url .= qq{:$ENV{'SERVER_PORT'}}\n"); p.print(" if (( $secure &amp;&amp; $ENV{'SERVER_PORT'} != 443)\n"); p.print(" || (!$secure &amp;&amp; $ENV{'SERVER_PORT'} != 80)\n"); p.print(" );\n"); p.print(" $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n"); p.print(" push @git_base_url_list, $http_url;\n"); p.print("}\n"); // Generate URLs using anonymous git:// // String url = cfg.getString("gerrit", null, "canonicalGitUrl"); if (url != null) { if (url.endsWith("/")) { url = url.substring(0, url.length() - 1); } p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n"); p.print(" push @git_base_url_list, "); p.print(quoteForPerl(url)); p.print(";\n"); p.print("}\n"); } // Generate URLs using authenticated ssh:// // if (sshInfo != null &amp;&amp; !sshInfo.getHostKeys().isEmpty()) { String sshAddr = sshInfo.getHostKeys().get(0).getHost(); p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n"); p.print(" push @git_base_url_list, join('', 'ssh://'"); p.print(", $ENV{'GERRIT_USER_NAME'}"); p.print(", '@'"); if (sshAddr.startsWith("*:") || "".equals(sshAddr)) { p.print(", $ENV{'SERVER_NAME'}"); } if (sshAddr.startsWith("*")) { sshAddr = sshAddr.substring(1); } p.print(", " + quoteForPerl(sshAddr)); p.print(");\n"); p.print("}\n"); } // Link back to Gerrit (when possible, to matching review record). // Supported Gitweb's hash values are: // - (missing), // - HEAD, // - refs/heads/<branch>
        , // - refs/changes/*/ 
       <change>
         /*, // - 
        <revision>
          . // p.print("sub add_review_link {\n"); p.print(" my $h = shift;\n"); p.print(" my $q;\n"); p.print(" if (!$h || $h eq 'HEAD') {\n"); p.print(" $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n"); p.print(" } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n"); p.print(" $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}"); // wrapped p.print("+branch:$1};\n"); p.print(" } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) "); // wrapped p.print("{\n"); p.print(" $q = qq{#/c/$1};\n"); p.print(" } else {\n"); p.print(" $q = qq{#/q/$h};\n"); p.print(" }\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("}\n"); p.print("if ($cgi-&gt;param('hb')) {\n"); p.print(" add_review_link($cgi-&gt;param('hb'));\n"); p.print("} elsif ($cgi-&gt;param('h')) {\n"); p.print(" add_review_link($cgi-&gt;param('h'));\n"); p.print("} else {\n"); p.print(" add_review_link();\n"); p.print("}\n"); // If the administrator has created a site-specific gitweb_config, // load that before we perform any final overrides. // Path sitecfg = site.site_gitweb; if (Files.isRegularFile(sitecfg)) { p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n"); p.print("if (-e $GITWEB_CONFIG) {\n"); p.print(" do " + quoteForPerl(sitecfg) + ";\n"); p.print("}\n"); } Path root = repoManager.getBasePath(); p.print("$projectroot = " + quoteForPerl(root) + ";\n"); // Permit exporting only the project we were started for. // We use the name under $projectroot in case symlinks // were involved in the path. // p.print("$export_auth_hook = sub {\n"); p.print(" my $dir = shift;\n"); p.print(" my $name = $ENV{'GERRIT_PROJECT_NAME'};\n"); p.print(" my $allow = qq{$projectroot/$name.git};\n"); p.print(" return $dir eq $allow;\n"); p.print(" };\n"); // Do not allow the administrator to enable path info, its // not a URL format we currently support. // p.print("$feature{'pathinfo'}{'override'} = 0;\n"); p.print("$feature{'pathinfo'}{'default'} = [0];\n"); // We don't do forking, so don't allow it to be enabled. // p.print("$feature{'forks'}{'override'} = 0;\n"); p.print("$feature{'forks'}{'default'} = [0];\n"); } myconfFile.setReadOnly(); 
        </revision> 
       </change> 
      </branch></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4789</td> 
     <td>1242677776</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>David Ostrovsky</td> 
     <td>9480fb45b9bcb34f5d88a639628a958d455532ad</td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>makeSiteConfig(SitePaths, Config, SshInfo)</td> 
     <td>private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException</td> 
     <td> if (!Files.exists(site.tmp_dir)) { Files.createDirectories(site.tmp_dir); } Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl"); // To make our configuration file only readable or writable by us; // this reduces the chances of someone tampering with the file. // // TODO(dborowitz): Is there a portable way to do this with NIO? File myconfFile = myconf.toFile(); myconfFile.setWritable(false, false); myconfFile.setReadable(false, false); myconfFile.setExecutable(false, false); myconfFile.setWritable(true, true); myconfFile.setReadable(true, true); myconfFile.deleteOnExit(); _env.set("GIT_DIR", "."); _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString()); try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) { p.print("# Autogenerated by Gerrit Code Review \n"); p.print("# DO NOT EDIT\n"); p.print("\n"); // We are mounted at the same level in the context as the main // UI, so we can include the same header and footer scheme. // Path hdr = site.site_header; if (Files.isRegularFile(hdr)) { p.print("$site_header = " + quoteForPerl(hdr) + ";\n"); } Path ftr = site.site_footer; if (Files.isRegularFile(ftr)) { p.print("$site_footer = " + quoteForPerl(ftr) + ";\n"); } // Top level should return to Gerrit's UI. // p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n"); p.print("$home_link_str = 'Code Review';\n"); p.print("$favicon = 'favicon.ico';\n"); p.print("$logo = 'gitweb-logo.png';\n"); p.print("$javascript = 'gitweb.js';\n"); p.print("@stylesheets = ('gitweb-default.css');\n"); Path css = site.site_css; if (Files.isRegularFile(css)) { p.print("push @stylesheets, 'gitweb-site.css';\n"); } // Try to make the title match Gerrit's normal window title // scheme of host followed by 'Code Review'. // p.print("$site_name = $home_link_str;\n"); p.print("$site_name = qq{$1 $site_name} if "); p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n"); // Assume by default that XSS is a problem, and try to prevent it. // p.print("$prevent_xss = 1;\n"); // Generate URLs using smart http:// // p.print("{\n"); p.print(" my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n"); p.print(" my $http_url = $secure ? 'https://' : 'http://';\n"); p.print(" $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n"); p.print(" unless $ENV{'GERRIT_ANONYMOUS_READ'};\n"); p.print(" $http_url .= $ENV{'SERVER_NAME'};\n"); p.print(" $http_url .= qq{:$ENV{'SERVER_PORT'}}\n"); p.print(" if (( $secure &amp;&amp; $ENV{'SERVER_PORT'} != 443)\n"); p.print(" || (!$secure &amp;&amp; $ENV{'SERVER_PORT'} != 80)\n"); p.print(" );\n"); p.print(" $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n"); p.print(" push @git_base_url_list, $http_url;\n"); p.print("}\n"); // Generate URLs using anonymous git:// // String url = cfg.getString("gerrit", null, "canonicalGitUrl"); if (url != null) { if (url.endsWith("/")) { url = url.substring(0, url.length() - 1); } p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n"); p.print(" push @git_base_url_list, "); p.print(quoteForPerl(url)); p.print(";\n"); p.print("}\n"); } // Generate URLs using authenticated ssh:// // if (sshInfo != null &amp;&amp; !sshInfo.getHostKeys().isEmpty()) { String sshAddr = sshInfo.getHostKeys().get(0).getHost(); p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n"); p.print(" push @git_base_url_list, join('', 'ssh://'"); p.print(", $ENV{'GERRIT_USER_NAME'}"); p.print(", '@'"); if (sshAddr.startsWith("*:") || "".equals(sshAddr)) { p.print(", $ENV{'SERVER_NAME'}"); } if (sshAddr.startsWith("*")) { sshAddr = sshAddr.substring(1); } p.print(", " + quoteForPerl(sshAddr)); p.print(");\n"); p.print("}\n"); } // Link back to Gerrit (when possible, to matching review record). // Supported Gitweb's hash values are: // - (missing), // - HEAD, // - refs/heads/<branch>
        , // - refs/changes/*/ 
       <change>
         /*, // - 
        <revision>
          . // p.print("sub add_review_link {\n"); p.print(" my $h = shift;\n"); p.print(" my $q;\n"); p.print(" if (!$h || $h eq 'HEAD') {\n"); p.print(" $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n"); p.print(" } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n"); p.print(" $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}"); // wrapped p.print("+branch:$1};\n"); p.print(" } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) "); // wrapped p.print("{\n"); p.print(" $q = qq{#/c/$1};\n"); p.print(" } else {\n"); p.print(" $q = qq{#/q/$h};\n"); p.print(" }\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("}\n"); p.print("if ($cgi-&gt;param('hb')) {\n"); p.print(" add_review_link($cgi-&gt;param('hb'));\n"); p.print("} elsif ($cgi-&gt;param('h')) {\n"); p.print(" add_review_link($cgi-&gt;param('h'));\n"); p.print("} else {\n"); p.print(" add_review_link();\n"); p.print("}\n"); // If the administrator has created a site-specific gitweb_config, // load that before we perform any final overrides. // Path sitecfg = site.site_gitweb; if (Files.isRegularFile(sitecfg)) { p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n"); p.print("if (-e $GITWEB_CONFIG) {\n"); p.print(" do " + quoteForPerl(sitecfg) + ";\n"); p.print("}\n"); } Path root = repoManager.getBasePath(); p.print("$projectroot = " + quoteForPerl(root) + ";\n"); // Permit exporting only the project we were started for. // We use the name under $projectroot in case symlinks // were involved in the path. // p.print("$export_auth_hook = sub {\n"); p.print(" my $dir = shift;\n"); p.print(" my $name = $ENV{'GERRIT_PROJECT_NAME'};\n"); p.print(" my $allow = qq{$projectroot/$name.git};\n"); p.print(" return $dir eq $allow;\n"); p.print(" };\n"); // Do not allow the administrator to enable path info, its // not a URL format we currently support. // p.print("$feature{'pathinfo'}{'override'} = 0;\n"); p.print("$feature{'pathinfo'}{'default'} = [0];\n"); // We don't do forking, so don't allow it to be enabled. // p.print("$feature{'forks'}{'override'} = 0;\n"); p.print("$feature{'forks'}{'default'} = [0];\n"); } myconfFile.setReadOnly(); 
        </revision> 
       </change> 
      </branch></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4240</td> 
     <td>1242677776</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>bbf1aaccde2cd0c9d9becff1f7a784466726abda</td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>makeSiteConfig(SitePaths, GerritConfig)</td> 
     <td>private void makeSiteConfig(final SitePaths site, final GerritConfig gerritConfig) throws IOException</td> 
     <td> final File myconf = File.createTempFile("gitweb_config_", ".perl"); // To make our configuration file only readable or writable by us; // this reduces the chances of someone tampering with the file. // myconf.setWritable(false, false); myconf.setReadable(false, false); myconf.setExecutable(false, false); myconf.setWritable(true, true); myconf.setReadable(true, true); myconf.deleteOnExit(); _env.set("GIT_DIR", "."); _env.set("GITWEB_CONFIG", myconf.getAbsolutePath()); final PrintWriter p = new PrintWriter(new FileWriter(myconf)); try { p.print("# Autogenerated by Gerrit Code Review \n"); p.print("# DO NOT EDIT\n"); p.print("\n"); // We are mounted at the same level in the context as the main // UI, so we can include the same header and footer scheme. // final File hdr = site.site_header; if (hdr.isFile()) { p.print("$site_header = " + quoteForPerl(hdr) + ";\n"); } final File ftr = site.site_footer; if (ftr.isFile()) { p.print("$site_footer = " + quoteForPerl(ftr) + ";\n"); } // Top level should return to Gerrit's UI. // p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n"); p.print("$home_link_str = 'Code Review';\n"); p.print("$favicon = 'favicon.ico';\n"); p.print("$logo = 'gitweb-logo.png';\n"); p.print("@stylesheets = ('gitweb-default.css');\n"); final File css = site.site_css; if (css.isFile()) { p.print("push @stylesheets, 'gitweb-site.css';\n"); } // Try to make the title match Gerrit's normal window title // scheme of host followed by 'Code Review'. // p.print("$site_name = $home_link_str;\n"); p.print("$site_name = qq{$1 $site_name} if "); p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n"); // Assume by default that XSS is a problem, and try to prevent it. // p.print("$prevent_xss = 1;\n"); // Generate URLs using the anonymous git:// and secured ssh:// scheme, // this matches the pull URLs we publish on each change screen. // if (gerritConfig.getGitDaemonUrl() != null) { String url = gerritConfig.getGitDaemonUrl(); if (url.endsWith("/")) { url = url.substring(0, url.length() - 1); } p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n"); p.print(" push @git_base_url_list, "); p.print(quoteForPerl(url)); p.print(";\n"); p.print("}\n"); } if (gerritConfig.getSshdAddress() != null) { String sshAddr = gerritConfig.getSshdAddress(); p.print("if ($ENV{'GERRIT_SSH_USER_NAME'}) {\n"); p.print(" push @git_base_url_list, join('', 'ssh://'"); p.print(", $ENV{'GERRIT_SSH_USER_NAME'}"); p.print(", '@'"); if (sshAddr.startsWith("*:") || "".equals(sshAddr)) { p.print(", $ENV{'SERVER_NAME'}"); } if (sshAddr.startsWith("*")) { sshAddr = sshAddr.substring(1); } p.print(", " + quoteForPerl(sshAddr)); p.print(");\n"); p.print("}\n"); } // If the administrator has created a site-specific gitweb_config, // load that before we perform any final overrides. // final File sitecfg = site.site_gitweb; if (sitecfg.isFile()) { p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n"); p.print("if (-e $GITWEB_CONFIG) {\n"); p.print(" do " + quoteForPerl(sitecfg) + ";\n"); p.print("}\n"); } final File root = repoManager.getBasePath(); p.print("$projectroot = " + quoteForPerl(root) + ";\n"); // Link from commits to their matching review record. // p.print("if ($cgi-&gt;param('a') =~ /^(commit|commitdiff)$/) {\n"); p.print(" my $h = $cgi-&gt;param('h');\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}#q,$h,n,z};"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("} elsif ($cgi-&gt;param('a') =~ /^(tree|blob)$/) {\n"); p.print(" my $h = $cgi-&gt;param('hb');\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}#q,$h,n,z};"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("}\n"); // Permit exporting only the project we were started for. // We use the name under $projectroot in case symlinks // were involved in the path. // p.print("$export_auth_hook = sub {\n"); p.print(" my $dir = shift;\n"); p.print(" my $name = $ENV{'GERRIT_PROJECT_NAME'};\n"); p.print(" my $allow = qq{$projectroot/$name.git};\n"); p.print(" return $dir eq $allow;\n"); p.print(" };\n"); // Do not allow the administrator to enable path info, its // not a URL format we currently support. // p.print("$feature{'pathinfo'}{'override'} = 0;\n"); p.print("$feature{'pathinfo'}{'default'} = [0];\n"); // We don't do forking, so don't allow it to be enabled. // p.print("$feature{'forks'}{'override'} = 0;\n"); p.print("$feature{'forks'}{'default'} = [0];\n"); } finally { p.close(); } myconf.setReadOnly(); </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4238</td> 
     <td>1242677776</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>b906a3e22fdb636a9e5b0eeb3ec82102a7c82d92</td> 
     <td>None</td> 
     <td>The identity information reported about the connection by a RFC 1413 [11] request to the remote agent, if available. Servers MAY choose not to support this feature, or not to request the data for efficiency reasons. \"REMOTE_IDENT\" =&gt; \"NYI\" </td> 
     <td>SATD_ADDED</td> 
     <td>makeSiteConfig(File, GerritConfig)</td> 
     <td>private void makeSiteConfig(final File sitePath, final GerritConfig gerritConfig) throws IOException</td> 
     <td> final File myconf = File.createTempFile("gitweb_config_", ".perl"); // To make our configuration file only readable or writable by us; // this reduces the chances of someone tampering with the file. // myconf.setWritable(false, false); myconf.setReadable(false, false); myconf.setExecutable(false, false); myconf.setWritable(true, true); myconf.setReadable(true, true); myconf.deleteOnExit(); _env.set("GIT_DIR", "."); _env.set("GITWEB_CONFIG", myconf.getAbsolutePath()); final PrintWriter p = new PrintWriter(new FileWriter(myconf)); try { p.print("# Autogenerated by Gerrit Code Review \n"); p.print("# DO NOT EDIT\n"); p.print("\n"); // We are mounted at the same level in the context as the main // UI, so we can include the same header and footer scheme. // final File hdr = new File(sitePath, "GerritSiteHeader.html"); if (hdr.isFile()) { p.print("$site_header = " + quoteForPerl(hdr) + ";\n"); } final File ftr = new File(sitePath, "GerritSiteFooter.html"); if (ftr.isFile()) { p.print("$site_footer = " + quoteForPerl(ftr) + ";\n"); } // Top level should return to Gerrit's UI. // p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n"); p.print("$home_link_str = 'Code Review';\n"); p.print("$favicon = 'favicon.ico';\n"); p.print("$logo = 'gitweb-logo.png';\n"); p.print("@stylesheets = ('gitweb-default.css');\n"); final File css = new File(sitePath, "GerritSite.css"); if (css.isFile()) { p.print("push @stylesheets, 'gitweb-site.css';\n"); } // Try to make the title match Gerrit's normal window title // scheme of host followed by 'Code Review'. // p.print("$site_name = $home_link_str;\n"); p.print("$site_name = qq{$1 $site_name} if "); p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n"); // Assume by default that XSS is a problem, and try to prevent it. // p.print("$prevent_xss = 1;\n"); // Generate URLs using the anonymous git:// and secured ssh:// scheme, // this matches the pull URLs we publish on each change screen. // if (gerritConfig.getGitDaemonUrl() != null) { String url = gerritConfig.getGitDaemonUrl(); if (url.endsWith("/")) { url = url.substring(0, url.length() - 1); } p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n"); p.print(" push @git_base_url_list, "); p.print(quoteForPerl(url)); p.print(";\n"); p.print("}\n"); } if (gerritConfig.getSshdAddress() != null) { String sshAddr = gerritConfig.getSshdAddress(); p.print("if ($ENV{'GERRIT_SSH_USER_NAME'}) {\n"); p.print(" push @git_base_url_list, join('', 'ssh://'"); p.print(", $ENV{'GERRIT_SSH_USER_NAME'}"); p.print(", '@'"); if (sshAddr.startsWith("*:") || "".equals(sshAddr)) { p.print(", $ENV{'SERVER_NAME'}"); } if (sshAddr.startsWith("*")) { sshAddr = sshAddr.substring(1); } p.print(", " + quoteForPerl(sshAddr)); p.print(");\n"); p.print("}\n"); } // If the administrator has created a site-specific gitweb_config, // load that before we perform any final overrides. // final File sitecfg = new File(sitePath, "gitweb_config.perl"); if (sitecfg.isFile()) { p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n"); p.print("if (-e $GITWEB_CONFIG) {\n"); p.print(" do " + quoteForPerl(sitecfg) + ";\n"); p.print("}\n"); } final File root = repoManager.getBasePath(); p.print("$projectroot = " + quoteForPerl(root) + ";\n"); // Link from commits to their matching review record. // p.print("if ($cgi-&gt;param('a') =~ /^(commit|commitdiff)$/) {\n"); p.print(" my $h = $cgi-&gt;param('h');\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}#q,$h,n,z};"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("} elsif ($cgi-&gt;param('a') =~ /^(tree|blob)$/) {\n"); p.print(" my $h = $cgi-&gt;param('hb');\n"); p.print(" my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}#q,$h,n,z};"); p.print(" push @{$feature{'actions'}{'default'}},\n"); p.print(" ('review',$r,'commitdiff');\n"); p.print("}\n"); // Permit exporting only the project we were started for. // We use the name under $projectroot in case symlinks // were involved in the path. // p.print("$export_auth_hook = sub {\n"); p.print(" my $dir = shift;\n"); p.print(" my $name = $ENV{'GERRIT_PROJECT_NAME'};\n"); p.print(" my $allow = qq{$projectroot/$name.git};\n"); p.print(" return $dir eq $allow;\n"); p.print(" };\n"); // Do not allow the administrator to enable path info, its // not a URL format we currently support. // p.print("$feature{'pathinfo'}{'override'} = 0;\n"); p.print("$feature{'pathinfo'}{'default'} = [0];\n"); // We don't do forking, so don't allow it to be enabled. // p.print("$feature{'forks'}{'override'} = 0;\n"); p.print("$feature{'forks'}{'default'} = [0];\n"); } finally { p.close(); } myconf.setReadOnly(); </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>