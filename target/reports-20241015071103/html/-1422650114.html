<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>3878</td> 
     <td>-1422650114</td>
     <td>apache/camel</td>
     <td>Andrea Cosentino</td>
     <td>3ec88a547cd2de69fc8b4f0ef47fba82d867bb67</td> 
     <td>depending on what kind of error handler we should</td> 
     <td>do not log handled</td> 
     <td>SATD_REMOVED</td> 
     <td>logFailedDelivery(boolean, boolean, boolean, boolean, boolean, Exchange, String, RedeliveryData, Throwable)</td> 
     <td>private void logFailedDelivery(boolean shouldRedeliver, boolean newException, boolean handled, boolean continued, boolean isDeadLetterChannel, Exchange exchange, String message, RedeliveryData data, Throwable e)</td> 
     <td> if (logger == null) { return; } if (!exchange.isRollbackOnly()) { if (newException &amp;&amp; !data.currentRedeliveryPolicy.isLogNewException()) { // do not log new exception return; } // if we should not rollback, then check whether logging is enabled if (!newException &amp;&amp; handled &amp;&amp; !data.currentRedeliveryPolicy.isLogHandled()) { // do not log handled return; } if (!newException &amp;&amp; continued &amp;&amp; !data.currentRedeliveryPolicy.isLogContinued()) { // do not log handled return; } if (!newException &amp;&amp; shouldRedeliver &amp;&amp; !data.currentRedeliveryPolicy.isLogRetryAttempted()) { // do not log retry attempts return; } if (!newException &amp;&amp; !shouldRedeliver &amp;&amp; !data.currentRedeliveryPolicy.isLogExhausted()) { // do not log exhausted return; } } LoggingLevel newLogLevel; boolean logStackTrace; if (exchange.isRollbackOnly()) { newLogLevel = data.currentRedeliveryPolicy.getRetriesExhaustedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogStackTrace(); } else if (shouldRedeliver) { newLogLevel = data.currentRedeliveryPolicy.getRetryAttemptedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogRetryStackTrace(); } else { newLogLevel = data.currentRedeliveryPolicy.getRetriesExhaustedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogStackTrace(); } if (e == null) { e = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class); } if (newException) { // log at most WARN level if (newLogLevel == LoggingLevel.ERROR) { newLogLevel = LoggingLevel.WARN; } String msg = message; if (msg == null) { msg = "New exception " + ExchangeHelper.logIds(exchange); // special for logging the new exception Throwable cause = e; if (cause != null) { msg = msg + " due: " + cause.getMessage(); } } if (e != null &amp;&amp; logStackTrace) { logger.log(msg, e, newLogLevel); } else { logger.log(msg, newLogLevel); } } else if (exchange.isRollbackOnly()) { String msg = "Rollback " + ExchangeHelper.logIds(exchange); Throwable cause = exchange.getException() != null ? exchange.getException() : exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class); if (cause != null) { msg = msg + " due: " + cause.getMessage(); } // should we include message history if (!shouldRedeliver &amp;&amp; data.currentRedeliveryPolicy.isLogExhaustedMessageHistory()) { // only use the exchange formatter if we should log exhausted message body (and if using a custom formatter then always use it) ExchangeFormatter formatter = customExchangeFormatter ? exchangeFormatter : (data.currentRedeliveryPolicy.isLogExhaustedMessageBody() ? exchangeFormatter : null); String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, formatter, false); if (routeStackTrace != null) { msg = msg + "\n" + routeStackTrace; } } if (newLogLevel == LoggingLevel.ERROR) { // log intended rollback on maximum WARN level (no ERROR) logger.log(msg, LoggingLevel.WARN); } else { // otherwise use the desired logging level logger.log(msg, newLogLevel); } } else { String msg = message; // should we include message history if (!shouldRedeliver &amp;&amp; data.currentRedeliveryPolicy.isLogExhaustedMessageHistory()) { // only use the exchange formatter if we should log exhausted message body (and if using a custom formatter then always use it) ExchangeFormatter formatter = customExchangeFormatter ? exchangeFormatter : (data.currentRedeliveryPolicy.isLogExhaustedMessageBody() ? exchangeFormatter : null); String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, formatter, e != null &amp;&amp; logStackTrace); if (routeStackTrace != null) { msg = msg + "\n" + routeStackTrace; } } if (e != null &amp;&amp; logStackTrace) { logger.log(msg, e, newLogLevel); } else { logger.log(msg, newLogLevel); } } </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>3600</td> 
     <td>-1422650114</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>d3b56df6665b05a71f44b5e27745cc3697ff8213</td> 
     <td>None</td> 
     <td>depending on what kind of error handler we should</td> 
     <td>SATD_ADDED</td> 
     <td>logFailedDelivery(boolean, boolean, boolean, boolean, boolean, Exchange, String, RedeliveryData, Throwable)</td> 
     <td>private void logFailedDelivery(boolean shouldRedeliver, boolean newException, boolean handled, boolean continued, boolean isDeadLetterChannel, Exchange exchange, String message, RedeliveryData data, Throwable e)</td> 
     <td> if (logger == null) { return; } if (!exchange.isRollbackOnly()) { if (newException &amp;&amp; !data.currentRedeliveryPolicy.isLogNewException()) { // do not log new exception return; } // if we should not rollback, then check whether logging is enabled // depending on what kind of error handler we should boolean logExhausted; if (isDeadLetterChannel) { // if DLC then log exhausted should not be default logExhausted = data.currentRedeliveryPolicy.getLogExhaustedMessageHistory() != null &amp;&amp; data.currentRedeliveryPolicy.isLogExhaustedMessageHistory(); } else { // for any other error handler log exhausted should be default logExhausted = data.currentRedeliveryPolicy.getLogExhaustedMessageHistory() == null || data.currentRedeliveryPolicy.isLogExhaustedMessageHistory(); } if (!newException &amp;&amp; handled &amp;&amp; (!data.currentRedeliveryPolicy.isLogHandled() &amp;&amp; !logExhausted)) { // do not log handled (but log exhausted message history can overrule log handled) return; } if (!newException &amp;&amp; continued &amp;&amp; !data.currentRedeliveryPolicy.isLogContinued()) { // do not log handled return; } if (!newException &amp;&amp; shouldRedeliver &amp;&amp; !data.currentRedeliveryPolicy.isLogRetryAttempted()) { // do not log retry attempts return; } if (!newException &amp;&amp; !shouldRedeliver &amp;&amp; !data.currentRedeliveryPolicy.isLogExhausted()) { // do not log exhausted return; } } LoggingLevel newLogLevel; boolean logStackTrace; if (exchange.isRollbackOnly()) { newLogLevel = data.currentRedeliveryPolicy.getRetriesExhaustedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogStackTrace(); } else if (shouldRedeliver) { newLogLevel = data.currentRedeliveryPolicy.getRetryAttemptedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogRetryStackTrace(); } else { newLogLevel = data.currentRedeliveryPolicy.getRetriesExhaustedLogLevel(); logStackTrace = data.currentRedeliveryPolicy.isLogStackTrace(); } if (e == null) { e = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class); } if (newException) { // log at most WARN level if (newLogLevel == LoggingLevel.ERROR) { newLogLevel = LoggingLevel.WARN; } String msg = message; if (msg == null) { msg = "New exception " + ExchangeHelper.logIds(exchange); // special for logging the new exception Throwable cause = e; if (cause != null) { msg = msg + " due: " + cause.getMessage(); } } if (e != null &amp;&amp; logStackTrace) { logger.log(msg, e, newLogLevel); } else { logger.log(msg, newLogLevel); } } else if (exchange.isRollbackOnly()) { String msg = "Rollback " + ExchangeHelper.logIds(exchange); Throwable cause = exchange.getException() != null ? exchange.getException() : exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class); if (cause != null) { msg = msg + " due: " + cause.getMessage(); } // should we include message history if (!shouldRedeliver &amp;&amp; data.currentRedeliveryPolicy.isLogExhaustedMessageHistory()) { String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, exchangeFormatter, false); if (routeStackTrace != null) { msg = msg + "\n" + routeStackTrace; } } if (newLogLevel == LoggingLevel.ERROR) { // log intended rollback on maximum WARN level (no ERROR) logger.log(msg, LoggingLevel.WARN); } else { // otherwise use the desired logging level logger.log(msg, newLogLevel); } } else { String msg = message; // should we include message history if (!shouldRedeliver &amp;&amp; data.currentRedeliveryPolicy.isLogExhaustedMessageHistory()) { String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, exchangeFormatter, e != null &amp;&amp; logStackTrace); if (routeStackTrace != null) { msg = msg + "\n" + routeStackTrace; } } if (e != null &amp;&amp; logStackTrace) { logger.log(msg, e, newLogLevel); } else { logger.log(msg, newLogLevel); } } </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>