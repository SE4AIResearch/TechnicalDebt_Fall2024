<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>3157</td> 
     <td>-1422650422</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>685d5ea6ec5384783d5cb60a0831c0c5cea55858</td> 
     <td>TODO: due to https://github.com/restlet/restlet-framework-java/issues/871 we force sync behavior until that is fixed, then we can switch back to async support</td> 
     <td>process the request asynchronously</td> 
     <td>SATD_REMOVED</td> 
     <td>process(Exchange, AsyncCallback)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback)</td> 
     <td> RestletEndpoint endpoint = (RestletEndpoint) getEndpoint(); final RestletBinding binding = endpoint.getRestletBinding(); Request request; try { String resourceUri = buildUri(endpoint, exchange); request = new Request(endpoint.getRestletMethod(), resourceUri); binding.populateRestletRequestFromExchange(request, exchange); } catch (CamelExchangeException e) { // break out in case of exception exchange.setException(e); callback.done(true); return true; } // process the request asynchronously LOG.debug("Sending request: {} for exchangeId: {}", request, exchange.getExchangeId()); client.handle(request, new Uniform() { @Override public void handle(Request request, Response response) { LOG.debug("Received response: {} for exchangeId: {}", response, exchange.getExchangeId()); try { if (response != null) { Integer respCode = response.getStatus().getCode(); if (respCode &gt; 207 &amp;&amp; throwException) { exchange.setException(populateRestletProducerException(exchange, response, respCode)); } else { binding.populateExchangeFromRestletResponse(exchange, response); } } } catch (Exception e) { exchange.setException(e); } finally { callback.done(false); } } }); // we continue routing async return false; </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>3009</td> 
     <td>-1422650422</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>6a635c0d334fccce5c26ce6a13e96f190f5d95b1</td> 
     <td>None</td> 
     <td>TODO: due to https://github.com/restlet/restlet-framework-java/issues/871 we force sync behavior until that is fixed, then we can switch back to async support</td> 
     <td>SATD_ADDED</td> 
     <td>process(Exchange, AsyncCallback)</td> 
     <td>public boolean process(final Exchange exchange, final AsyncCallback callback)</td> 
     <td> RestletEndpoint endpoint = (RestletEndpoint) getEndpoint(); final RestletBinding binding = endpoint.getRestletBinding(); Request request; try { String resourceUri = buildUri(endpoint, exchange); request = new Request(endpoint.getRestletMethod(), resourceUri); binding.populateRestletRequestFromExchange(request, exchange); } catch (CamelExchangeException e) { // break out in case of exception exchange.setException(e); callback.done(true); return true; } // TODO: due to https://github.com/restlet/restlet-framework-java/issues/871 // we force sync behavior until that is fixed, then we can switch back to async support LOG.debug("Sending request: {} for exchangeId: {}", request, exchange.getExchangeId()); Response response = client.handle(request); LOG.debug("Received response: {} for exchangeId: {}", response, exchange.getExchangeId()); try { if (response != null) { Integer respCode = response.getStatus().getCode(); if (respCode &gt; 207 &amp;&amp; throwException) { exchange.setException(populateRestletProducerException(exchange, response, respCode)); } else { binding.populateExchangeFromRestletResponse(exchange, response); } } } catch (Exception e) { exchange.setException(e); } callback.done(true); return true; // process the request asynchronously /* LOG.debug("Sending request: {} for exchangeId: {}", request, exchange.getExchangeId()); client.handle(request, new Uniform() { @Override public void handle(Request request, Response response) { LOG.debug("Received response: {} for exchangeId: {}", response, exchange.getExchangeId()); try { if (response != null) { Integer respCode = response.getStatus().getCode(); if (respCode &gt; 207 &amp;&amp; throwException) { exchange.setException(populateRestletProducerException(exchange, response, respCode)); } else { binding.populateExchangeFromRestletResponse(exchange, response); } } } catch (Exception e) { exchange.setException(e); } finally { callback.done(false); } } }); // we continue routing async return false;*/ </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>