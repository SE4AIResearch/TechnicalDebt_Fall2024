<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4838</td> <td>1242678090</td><td>GerritCodeReview/gerrit</td><td>Dave Borowitz</td><td>8e289571372266874c84f755cfac21919964162c</td> <td>None</td> <td>TODO(dborowitz): Handle CERTIFICATION_REVOCATION.</td> <td>SATD_ADDED</td> <td>checkWebOfTrust(PGPPublicKey, PublicKeyStore, int, Set<Fingerprint>)</td> <td>private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen)</td> <td>
    if (trusted == null || store == null) {
        // Trust checking not configured.
        return CheckResult.OK;
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return new CheckResult("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.OK;
    } else if (depth >= maxTrustDepth) {
        return new CheckResult("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            CheckResult signerResult = checkTrustSubpacket(sig, depth);
            if (signerResult.isOk()) {
                signerResult = check(signer, store, depth + 1, false, seen);
                if (signerResult.isOk()) {
                    return CheckResult.OK;
                }
            }
            signerResults.add(new CheckResult("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return new CheckResult(problems);
</td> </tr></table></body></html>