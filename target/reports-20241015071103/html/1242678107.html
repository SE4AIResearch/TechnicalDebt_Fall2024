<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4884</td> 
     <td>1242678107</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>459b191c5e2a0628915e5abe28ac7b1e14bd241c</td> 
     <td>Breadth-first search with oldest children first. TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep parallel history together.</td> 
     <td>Depth-first search with newest children first.</td> 
     <td>SATD_REMOVED</td> 
     <td>walkDescendentsImpl(ProjectControl, Set<change.id>
        , ListMultimap 
       <patchsetdata, patchsetdata>
         , List 
        <patchsetdata>
          ) 
        </patchsetdata> 
       </patchsetdata,> 
      </change.id></td> 
     <td>private static List<patchsetdata>
        walkDescendentsImpl(ProjectControl ctl, Set 
       <change.id>
         alreadyEmittedChanges, ListMultimap 
        <patchsetdata, patchsetdata>
          children, List 
         <patchsetdata>
           start) throws OrmException 
         </patchsetdata> 
        </patchsetdata,> 
       </change.id> 
      </patchsetdata></td> 
     <td> if (start.isEmpty()) { return ImmutableList.of(); } Map<change.id, patchset.id>
        maxPatchSetIds = new HashMap&lt;&gt;(); List 
       <patchsetdata>
         allPatchSets = new ArrayList&lt;&gt;(); Deque 
        <patchsetdata>
          pending = new ArrayDeque&lt;&gt;(); pending.addAll(start); while (!pending.isEmpty()) { PatchSetData psd = pending.remove(); if (!isVisible(psd, ctl)) { continue; } if (!alreadyEmittedChanges.contains(psd.id())) { // Don't emit anything for changes that were previously emitted, even // though different patch sets might show up later. However, do // continue walking through them for the purposes of finding indirect // descendants. PatchSet.Id oldMax = maxPatchSetIds.get(psd.id()); if (oldMax == null || psd.psId().get() &gt; oldMax.get()) { maxPatchSetIds.put(psd.id(), psd.psId()); } allPatchSets.add(psd); } // Depth-first search with newest children first. for (PatchSetData child : children.get(psd)) { pending.addFirst(child); } } // If we saw the same change multiple times, prefer the latest patch set. List 
         <patchsetdata>
           result = new ArrayList&lt;&gt;(allPatchSets.size()); for (PatchSetData psd : allPatchSets) { if (checkNotNull(maxPatchSetIds.get(psd.id())).equals(psd.psId())) { result.add(psd); } } return result; 
         </patchsetdata> 
        </patchsetdata> 
       </patchsetdata> 
      </change.id,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4883</td> 
     <td>1242678107</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>17db2b06ec7198b6ba0d5617f6f803a81df89e76</td> 
     <td>Breadth-first search with oldest children first. TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep parallel history together.</td> 
     <td>Breadth-first search with oldest children first. TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep parallel history together.</td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>walkDescendentsImpl(ProjectControl, Set<change.id>
        , ListMultimap 
       <patchsetdata, patchsetdata>
         , List 
        <patchsetdata>
          ) 
        </patchsetdata> 
       </patchsetdata,> 
      </change.id></td> 
     <td>private static List<patchsetdata>
        walkDescendentsImpl(ProjectControl ctl, Set 
       <change.id>
         alreadyEmittedChanges, ListMultimap 
        <patchsetdata, patchsetdata>
          children, List 
         <patchsetdata>
           start) throws OrmException 
         </patchsetdata> 
        </patchsetdata,> 
       </change.id> 
      </patchsetdata></td> 
     <td> if (start.isEmpty()) { return ImmutableList.of(); } Map<change.id, patchset.id>
        maxPatchSetIds = new HashMap&lt;&gt;(); List 
       <patchsetdata>
         allPatchSets = new ArrayList&lt;&gt;(); Deque 
        <patchsetdata>
          pending = new ArrayDeque&lt;&gt;(); pending.addAll(start); while (!pending.isEmpty()) { PatchSetData psd = pending.remove(); if (!isVisible(psd, ctl)) { continue; } if (!alreadyEmittedChanges.contains(psd.id())) { // Don't emit anything for changes that were previously emitted, even // though different patch sets might show up later. However, do // continue walking through them for the purposes of finding indirect // descendants. PatchSet.Id oldMax = maxPatchSetIds.get(psd.id()); if (oldMax == null || psd.psId().get() &gt; oldMax.get()) { maxPatchSetIds.put(psd.id(), psd.psId()); } allPatchSets.add(psd); } // Breadth-first search with oldest children first. // TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep // parallel history together. pending.addAll(Lists.reverse(children.get(psd))); } // If we saw the same change multiple times, prefer the latest patch set. List 
         <patchsetdata>
           result = new ArrayList&lt;&gt;(allPatchSets.size()); for (PatchSetData psd : allPatchSets) { if (checkNotNull(maxPatchSetIds.get(psd.id())).equals(psd.psId())) { result.add(psd); } } return result; 
         </patchsetdata> 
        </patchsetdata> 
       </patchsetdata> 
      </change.id,></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4880</td> 
     <td>1242678107</td>
     <td>GerritCodeReview/gerrit</td>
     <td>David Pursehouse</td>
     <td>39d1a499a74ce3586be1571e7bf9d5ac5269d5ef</td> 
     <td>None</td> 
     <td>Breadth-first search with oldest children first. TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep parallel history together.</td> 
     <td>SATD_ADDED</td> 
     <td>walkDescendentsImpl(ProjectControl, Set<change.id>
       , ListMultimap
       <patchsetdata, patchsetdata>
        , List
        <patchsetdata>
         )
        </patchsetdata>
       </patchsetdata,>
      </change.id></td> 
     <td>private static List<patchsetdata>
        walkDescendentsImpl(ProjectControl ctl, Set
       <change.id>
         alreadyEmittedChanges, ListMultimap
        <patchsetdata, patchsetdata>
          children, List
         <patchsetdata>
           start) throws OrmException
         </patchsetdata>
        </patchsetdata,>
       </change.id>
      </patchsetdata></td> 
     <td> if (start.isEmpty()) { return ImmutableList.of(); } Map<change.id, patchset.id>
        maxPatchSetIds = new HashMap&lt;&gt;(); List
       <patchsetdata>
         allPatchSets = new ArrayList&lt;&gt;(); Deque
        <patchsetdata>
          pending = new ArrayDeque&lt;&gt;(); pending.addAll(start); while (!pending.isEmpty()) { PatchSetData psd = pending.remove(); if (!isVisible(psd, ctl)) { continue; } if (!alreadyEmittedChanges.contains(psd.id())) { // Don't emit anything for changes that were previously emitted, even // though different patch sets might show up later. However, do // continue walking through them for the purposes of finding indirect // descendants. PatchSet.Id oldMax = maxPatchSetIds.get(psd.id()); if (oldMax == null || psd.psId().get() &gt; oldMax.get()) { maxPatchSetIds.put(psd.id(), psd.psId()); } allPatchSets.add(psd); } // Breadth-first search with oldest children first. // TODO(dborowitz): After killing PatchSetAncestors, consider DFS to keep // parallel history together. pending.addAll(Lists.reverse(children.get(psd))); } // If we saw the same change multiple times, prefer the latest patch set. List
         <patchsetdata>
           result = new ArrayList&lt;&gt;(allPatchSets.size()); for (PatchSetData psd : allPatchSets) { if (checkNotNull(maxPatchSetIds.get(psd.id())).equals(psd.psId())) { result.add(psd); } } return result; 
         </patchsetdata>
        </patchsetdata>
       </patchsetdata>
      </change.id,></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>