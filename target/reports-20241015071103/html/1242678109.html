<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4887</td> <td>1242678109</td><td>GerritCodeReview/gerrit</td><td>Dave Borowitz</td><td>c916b9e6a91864024185b820ccede36546805794</td> <td>Serve static resources directly from our JAR. This way we don't
need to unpack them into yet another temporary directory prior to
serving to clients.
</td> <td>This is the path we are accessed by clients within our domain.
</td> <td>SATD_REMOVED</td> <td>makeContext(String, JettyEnv, Config)</td> <td>private ContextHandler makeContext(final String contextPath, final JettyEnv env, final Config cfg)</td> <td>
    final ServletContextHandler app = new ServletContextHandler();
    // This enables the use of sessions in Jetty, feature available
    // for Gerrit plug-ins to enable user-level sessions.
    // 
    app.setSessionHandler(new SessionHandler());
    app.setErrorHandler(new HiddenErrorHandler());
    // This is the path we are accessed by clients within our domain.
    // 
    app.setContextPath(contextPath);
    // HTTP front-end filter to be used as surrogate of Apache HTTP
    // reverse-proxy filtering.
    // It is meant to be used as simpler tiny deployment of custom-made
    // security enforcement (Security tokens, IP-based security filtering, others)
    String filterClassName = cfg.getString("httpd", null, "filterClass");
    if (filterClassName != null) {
        try {
            @SuppressWarnings("unchecked")
            Class<? extends Filter> filterClass = (Class<? extends Filter>) Class.forName(filterClassName);
            Filter filter = env.webInjector.getInstance(filterClass);
            app.addFilter(new FilterHolder(filter), "/*", EnumSet.of(DispatcherType.REQUEST, DispatcherType.ASYNC));
        } catch (Throwable e) {
            String errorMessage = "Unable to instantiate front-end HTTP Filter " + filterClassName;
            log.error(errorMessage, e);
            throw new IllegalArgumentException(errorMessage, e);
        }
    }
    // Perform the same binding as our web.xml would do, but instead
    // of using the listener to create the injector pass the one we
    // already have built.
    // 
    GuiceFilter filter = env.webInjector.getInstance(GuiceFilter.class);
    app.addFilter(new FilterHolder(filter), "/*", EnumSet.of(DispatcherType.REQUEST, DispatcherType.ASYNC));
    app.addEventListener(new GuiceServletContextListener() {

        @Override
        protected Injector getInjector() {
            return env.webInjector;
        }
    });
    // Jetty requires at least one servlet be bound before it will
    // bother running the filter above. Since the filter has all
    // of our URLs except the static resources, the only servlet
    // we need to bind is the default static resource servlet from
    // the Jetty container.
    // 
    final ServletHolder ds = app.addServlet(DefaultServlet.class, "/");
    ds.setInitParameter("dirAllowed", "false");
    ds.setInitParameter("redirectWelcome", "false");
    ds.setInitParameter("useFileMappedBuffer", "false");
    ds.setInitParameter("gzip", "true");
    app.setWelcomeFiles(new String[0]);
    return app;
</td> </tr></table></body></html>