<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>3880</td> 
     <td>-1422649945</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>2b4b9df67da4b84cb69d9dd42ef77155a803679a</td> 
     <td>TODO: favor using mapper readValue if the input is string or input stream</td> 
     <td>if the source value type is readable by the mapper then use its read operation</td> 
     <td>SATD_REMOVED</td> 
     <td>convertTo(Class<t>
       , Exchange, Object, TypeConverterRegistry)
      </t></td> 
     <td>public T convertTo(Class<t>
        type, Exchange exchange, Object value, TypeConverterRegistry registry) throws Exception
      </t></td> 
     <td> // only do this if enabled (disabled by default) if (!init &amp;&amp; exchange != null) { // init to see if this is enabled String text = exchange.getContext().getProperties().get(JacksonConstants.ENABLE_TYPE_CONVERTER); if (text != null) { text = exchange.getContext().resolvePropertyPlaceholders(text); enabled = "true".equalsIgnoreCase(text); } // pojoOnly is enabled by default text = exchange.getContext().getProperties().get(JacksonConstants.TYPE_CONVERTER_TO_POJO); if (text != null) { text = exchange.getContext().resolvePropertyPlaceholders(text); toPojo = "true".equalsIgnoreCase(text); } init = true; } if (!enabled) { return null; } if (!toPojo &amp;&amp; isNotPojoType(type)) { return null; } if (exchange != null) { ObjectMapper mapper = resolveObjectMapper(exchange.getContext().getRegistry()); // favor use write/read operations as they are higher level than the convertValue // if we want to convert to a String or byte[] then use write operation if (String.class.isAssignableFrom(type)) { String out = mapper.writeValueAsString(value); return type.cast(out); } else if (byte[].class.isAssignableFrom(type)) { byte[] out = mapper.writeValueAsBytes(value); return type.cast(out); } else if (mapper.canSerialize(type)) { // if the source value type is readable by the mapper then use its read operation if (String.class.isAssignableFrom(value.getClass())) { return mapper.readValue((String) value, type); } else if (byte[].class.isAssignableFrom(value.getClass())) { return mapper.readValue((byte[]) value, type); } else if (File.class.isAssignableFrom(value.getClass())) { return mapper.readValue((File) value, type); } else if (InputStream.class.isAssignableFrom(value.getClass())) { return mapper.readValue((InputStream) value, type); } else if (Reader.class.isAssignableFrom(value.getClass())) { return mapper.readValue((Reader) value, type); } else { // fallback to generic convert value return mapper.convertValue(value, type); } } } // Just return null to let other fallback converter to do the job return null; </td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>3879</td> 
     <td>-1422649945</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>7009d64091876c3b1f9e36e074f8cc7484cfb434</td> 
     <td>None</td> 
     <td>TODO: favor using mapper readValue if the input is string or input stream</td> 
     <td>SATD_ADDED</td> 
     <td>convertTo(Class<t>
       , Exchange, Object, TypeConverterRegistry)
      </t></td> 
     <td>public T convertTo(Class<t>
        type, Exchange exchange, Object value, TypeConverterRegistry registry) throws Exception
      </t></td> 
     <td> // only do this if enabled if (!init &amp;&amp; exchange != null) { // init to see if this is enabled String text = exchange.getContext().getProperties().get(JacksonConstants.ENABLE_TYPE_CONVERTER); enabled = "true".equalsIgnoreCase(text); // pojo only by default text = exchange.getContext().getProperties().get(JacksonConstants.TYPE_CONVERTER_POJO_ONLY); if (text != null) { pojoOnly = "true".equalsIgnoreCase(text); } init = true; } if (enabled == null || !enabled) { return null; } if (pojoOnly &amp;&amp; isNotPojoType(type)) { return null; } if (exchange != null) { ObjectMapper mapper = resolveObjectMapper(exchange.getContext().getRegistry()); if (String.class.isAssignableFrom(type)) { String out = mapper.writeValueAsString(value); return type.cast(out); } else if (byte[].class.isAssignableFrom(type)) { byte[] out = mapper.writeValueAsBytes(value); return type.cast(out); } else if (mapper.canSerialize(type)) { // TODO: favor using mapper readValue // if the input is string or input stream if (String.class.isAssignableFrom(value.getClass())) { return mapper.readValue((String) value, type); } return mapper.convertValue(value, type); } } // Just return null to let other fallback converter to do the job return null; </td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>