<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1259</td> 
     <td>-1422651412</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>cf11eb8fb4e6ca187b573513e49b58cdc361771b</td> 
     <td>TODO: Disabled for now until we find a better strategy for registering routes in the JMX without altering the route model. The route model should be much the same as without JMX to avoid a gap that causes pain to get working with and without JMX enabled. We have seen to many issues with this already.</td> 
     <td>instrument the route endpoint</td> 
     <td>SATD_REMOVED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap
       <processordefinition, performancecounter>
        (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); // TODO: This only registers counters for the first outputs in the route // all the chidren of the outputs is not registered // we should leverge the Channel for this to ensure we register all processors // in the entire route graph // register all processors for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // add intercept strategy that executes the JMX instrumentation for performance metrics // TODO: We could do as below with an inlined implementation instead of a separate class routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); // instrument the route endpoint final Endpoint endpoint = routeContext.getEndpoint(); // only needed to register on the first output as all rotues will pass through this one ProcessorDefinition out = routeContext.getRoute().getOutputs().get(0); // add an intercept strategy that counts when the route sends to any of its outputs out.addInterceptStrategy(new InterceptStrategy() { public Processor wrapProcessorInInterceptors(ProcessorDefinition processorDefinition, Processor target) throws Exception { if (registeredRoutes.containsKey(endpoint)) { // do not double wrap return target; } InstrumentationProcessor wrapper = new InstrumentationProcessor(null); wrapper.setType(processorDefinition.getShortName()); wrapper.setProcessor(target); // register our wrapper registeredRoutes.put(endpoint, wrapper); return wrapper; } }); 
       </processordefinition,>
      </processordefinition,></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1238</td> 
     <td>-1422651412</td>
     <td>apache/camel</td>
     <td>Willem Ning Jiang</td>
     <td>a4e7f76960b87983d3522afc1a322dd6958f002f</td> 
     <td>None</td> 
     <td>TODO: Disabled for now until we find a better strategy for registering routes in the JMX without altering the route model. The route model should be much the same as without JMX to avoid a gap that causes pain to get working with and without JMX enabled. We have seen to many issues with this already.</td> 
     <td>SATD_ADDED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap
       <processordefinition, performancecounter>
        (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); // register all processors for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // TODO: align this code with DefaultLifecycleStrategy routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); routeContext.setErrorHandlerWrappingStrategy(new DefaultErrorHandlerWrappingStrategy(routeContext)); // Add an InstrumentationProcessor at the beginning of each route and // set up the interceptorMap for onRoutesAdd() method to register the // ManagedRoute MBeans. // TODO: Disabled for now until we find a better strategy for registering routes in the JMX // without altering the route model. The route model should be much the same as without JMX to avoid // a gap that causes pain to get working with and without JMX enabled. We have seen to many issues with this already. /* RouteDefinition routeType = routeContext.getRoute(); if (routeType.getInputs() != null &amp;&amp; !routeType.getInputs().isEmpty()) { if (routeType.getInputs().size() &gt; 1) { LOG.warn("Addding InstrumentationProcessor to first input only."); } Endpoint endpoint = routeType.getInputs().get(0).getEndpoint(); List
        <processordefinition>
          exceptionHandlers = new ArrayList
         <processordefinition>
          (); List
          <processordefinition>
            outputs = new ArrayList
           <processordefinition>
            (); // separate out the exception handers in the outputs for (ProcessorDefinition output : routeType.getOutputs()) { if (output instanceof OnExceptionDefinition) { exceptionHandlers.add(output); } else { outputs.add(output); } } // clearing the outputs routeType.clearOutput(); // add exception handlers as top children routeType.getOutputs().addAll(exceptionHandlers); // add an interceptor to instrument the route InstrumentationProcessor processor = new InstrumentationProcessor(); routeType.intercept(processor); // add the output for (ProcessorDefinition processorType : outputs) { routeType.addOutput(processorType); } interceptorMap.put(endpoint, processor); }*/ 
           </processordefinition>
          </processordefinition>
         </processordefinition>
        </processordefinition>
       </processordefinition,>
      </processordefinition,></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>