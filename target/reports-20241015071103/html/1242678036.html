<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>4721</td> <td>1242678036</td><td>GerritCodeReview/gerrit</td><td>David Pursehouse</td><td>875fc8e8a3367d2507d0f937e13b12d3ff3f6f86</td> <td>None</td> <td>TODO(dborowitz): Implement RefUpdate.toString().</td> <td>SATD_ADDED</td> <td>updateBranch(SubmitStrategy, RefUpdate)</td> <td>private RefUpdate updateBranch(SubmitStrategy strategy, RefUpdate branchUpdate) throws MergeException</td> <td>
    CodeReviewCommit currentTip = mergeTip != null ? mergeTip.getCurrentTip() : null;
    if (Objects.equals(branchTip, currentTip)) {
        logDebug("Branch already at merge tip {}, no update to perform", currentTip.name());
        return null;
    } else if (currentTip == null) {
        logDebug("No merge tip, no update to perform");
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        logDebug("Loading new configuration from {}", RefNames.REFS_CONFIG);
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, currentTip);
        } catch (Exception e) {
            throw new MergeException("Submit would store invalid" + " project configuration " + currentTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(currentTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        RefUpdate.Result result = branchUpdate.update(rw);
        logDebug("Update of {}: {}..{} returned status {}", branchUpdate.getName(), branchUpdate.getOldObjectId(), branchUpdate.getNewObjectId(), result);
        switch(result) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), currentTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    Project p = destProject.getProject();
                    projectCache.evict(p);
                    destProject = projectCache.get(p.getNameKey());
                    repoManager.setProjectDescription(p.getNameKey(), p.getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                String msg;
                if (strategy.retryOnLockFailure()) {
                    mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                    msg = "will retry";
                } else {
                    msg = "will not retry";
                }
                // TODO(dborowitz): Implement RefUpdate.toString().
                throw new IOException(branchUpdate.getResult().name() + ", " + msg + '\n' + branchUpdate);
            default:
                throw new IOException(branchUpdate.getResult().name() + '\n' + branchUpdate);
        }
    } catch (IOException e) {
        throw new MergeException("Cannot update " + branchUpdate.getName(), e);
    }
</td> </tr></table></body></html>