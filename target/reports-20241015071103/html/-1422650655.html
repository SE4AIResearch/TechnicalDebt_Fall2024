<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>3193</td> 
     <td>-1422650655</td> 
     <td>apache/camel</td> 
     <td>Willem Jiang</td> 
     <td>f683b0b7b1933fa492ab4f7a456691d90b17698c</td> 
     <td>Return the producer to the pool so another waiting producer can move forward without waiting on us to complete the exchange</td> 
     <td>Return the producer to the pool so another waiting producer can move forward without waiting on us to complete the exchange</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>sendMessage(Exchange, AsyncCallback, MessageProducerResources)</td> 
     <td>public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception</td> 
     <td> if (isEndpointTransacted()) { exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy())); } Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy()); // TODO just set the correlation id don't get it from the // message String correlationId = null; if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) { correlationId = UUID.randomUUID().toString().replace("-", ""); } else { correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class); } Object responseObject = null; Exchanger<object> messageExchanger = new Exchanger<object>(); SjmsExchangeMessageHelper.setCorrelationId(request, correlationId); try { lock.writeLock().lock(); exchangerMap.put(correlationId, messageExchanger); } finally { lock.writeLock().unlock(); } MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut()); SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination()); consumers.returnObject(consumer); producer.getMessageProducer().send(request); // Return the producer to the pool so another waiting producer // can move forward // without waiting on us to complete the exchange try { getProducers().returnObject(producer); } catch (Exception exception) { // thrown if the pool is full. safe to ignore. } try { responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS); try { lock.writeLock().lock(); exchangerMap.remove(correlationId); } finally { lock.writeLock().unlock(); } } catch (InterruptedException e) { log.debug("Exchanger was interrupted while waiting on response", e); exchange.setException(e); } catch (TimeoutException e) { log.debug("Exchanger timed out while waiting on response", e); exchange.setException(e); } if (exchange.getException() == null) { if (responseObject instanceof Throwable) { exchange.setException((Throwable) responseObject); } else if (responseObject instanceof Message) { Message response = (Message) responseObject; SjmsExchangeMessageHelper.populateExchange(response, exchange, true); } else { exchange.setException(new CamelException("Unknown response type: " + responseObject)); } } callback.done(isSynchronous()); </object></object></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>2975</td> 
     <td>-1422650655</td> 
     <td>apache/camel</td> 
     <td>Babak Vahdat</td> 
     <td>520e55fa81f7aa9faa65960ad36be0af8f3d03d0</td> 
     <td>Return the producer to the pool so another waiting producer can move forward without waiting on us to complete the exchange</td> 
     <td>Return the producer to the pool so another waiting producer can move forward without waiting on us to complete the exchange</td> 
     <td>SATD_CHANGED</td> 
     <td>sendMessage(Exchange, AsyncCallback)</td> 
     <td>public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception</td> 
     <td> if (getProducers() != null) { MessageProducerResources producer = null; try { producer = getProducers().borrowObject(getResponseTimeOut()); } catch (Exception e1) { log.warn("The producer pool is exhausted. Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false."); exchange.setException(new Exception("Producer Resource Pool is exhausted")); } if (producer != null) { if (isEndpointTransacted()) { exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy())); } Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy()); // TODO just set the correlation id don't get it from the // message String correlationId = null; if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) { correlationId = UUID.randomUUID().toString().replace("-", ""); } else { correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class); } Object responseObject = null; Exchanger<object> messageExchanger = new Exchanger<object>(); SjmsExchangeMessageHelper.setCorrelationId(request, correlationId); try { lock.writeLock().lock(); exchangerMap.put(correlationId, messageExchanger); } finally { lock.writeLock().unlock(); } MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut()); SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination()); consumers.returnObject(consumer); producer.getMessageProducer().send(request); // Return the producer to the pool so another waiting producer // can move forward // without waiting on us to complete the exchange try { getProducers().returnObject(producer); } catch (Exception exception) { // thrown if the pool is full. safe to ignore. } try { responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS); try { lock.writeLock().lock(); exchangerMap.remove(correlationId); } finally { lock.writeLock().unlock(); } } catch (InterruptedException e) { log.debug("Exchanger was interrupted while waiting on response", e); exchange.setException(e); } catch (TimeoutException e) { log.debug("Exchanger timed out while waiting on response", e); exchange.setException(e); } if (exchange.getException() == null) { if (responseObject instanceof Throwable) { exchange.setException((Throwable) responseObject); } else if (responseObject instanceof Message) { Message response = (Message) responseObject; SjmsExchangeMessageHelper.populateExchange(response, exchange, true); } else { exchange.setException(new CamelException("Unknown response type: " + responseObject)); } } } callback.done(isSynchronous()); } </object></object></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>2603</td> 
     <td>-1422650655</td>
     <td>apache/camel</td>
     <td>Scott England-Sullivan</td>
     <td>bea026ea1d9ad8e001d83080cf7a6e09b953b610</td> 
     <td>None</td> 
     <td>Return the producer to the pool so another waiting producer can move forward without waiting on us to complete the exchange</td> 
     <td>SATD_ADDED</td> 
     <td>sendMessage(Exchange, AsyncCallback)</td> 
     <td>public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception</td> 
     <td> if (getProducers() != null) { MessageProducerResources producer = null; try { producer = getProducers().borrowObject(getResponseTimeOut()); } catch (Exception e1) { log.warn("The producer pool is exhausted. Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false."); exchange.setException(new Exception("Producer Resource Pool is exhausted")); } if (producer != null) { if (isEndpointTransacted()) { exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy())); } Message request = JmsMessageExchangeHelper.createMessage(exchange, producer.getSession()); // TODO just set the correlation id don't get it from the // message String correlationId = null; if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) { correlationId = UUID.randomUUID().toString().replace("-", ""); } else { correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class); } Object responseObject = null; Exchanger<object> messageExchanger = new Exchanger<object>(); JmsMessageExchangeHelper.setCorrelationId(request, correlationId); try { lock.writeLock().lock(); exchangerMap.put(correlationId, messageExchanger); } finally { lock.writeLock().unlock(); } MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut()); JmsMessageExchangeHelper.setJMSReplyTo(request, consumer.getReplyToDestination()); consumers.returnObject(consumer); producer.getMessageProducer().send(request); // Return the producer to the pool so another waiting producer can move forward // without waiting on us to complete the exchange try { getProducers().returnObject(producer); } catch (Exception exception) { // thrown if the pool is full. safe to ignore. } try { responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS); try { lock.writeLock().lock(); exchangerMap.remove(correlationId); } finally { lock.writeLock().unlock(); } } catch (InterruptedException e) { log.debug("Exchanger was interrupted while waiting on response", e); exchange.setException(e); } catch (TimeoutException e) { log.debug("Exchanger timed out while waiting on response", e); exchange.setException(e); } if (exchange.getException() == null) { if (responseObject instanceof Throwable) { exchange.setException((Throwable) responseObject); } else if (responseObject instanceof Message) { Message response = (Message) responseObject; JmsMessageExchangeHelper.populateExchange(response, exchange, true); } else { exchange.setException(new CamelException("Unknown response type: " + responseObject)); } } } callback.done(isSynchronous()); } </object></object></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>