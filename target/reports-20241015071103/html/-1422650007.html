<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>3789</td> <td>-1422650007</td><td>apache/camel</td><td>Claus Ibsen</td><td>3c782dbf12c7c8e9a8c799e94907562630711ea3</td> <td>None</td> <td>maybe the name was using an optional prefix, and if so then lookup without the prefix</td> <td>SATD_ADDED</td> <td>validateEndpointProperties(String)</td> <td>public EndpointValidationResult validateEndpointProperties(String uri)</td> <td>
    EndpointValidationResult result = new EndpointValidationResult(uri);
    Map<String, String> properties;
    List<Map<String, String>> rows;
    try {
        // parse the uri
        URI u = normalizeUri(uri);
        String scheme = u.getScheme();
        String json = componentJSonSchema(scheme);
        if (json == null) {
            result.addUnknownComponent(scheme);
            return result;
        }
        rows = JSonSchemaHelper.parseJsonSchema("properties", json, true);
        properties = endpointProperties(uri);
    } catch (URISyntaxException e) {
        result.addSyntaxError(e.getMessage());
        return result;
    }
    // validate all the options
    for (Map.Entry<String, String> property : properties.entrySet()) {
        String name = property.getKey();
        String optionalPrefix = getPropertyOptionalPrefix(rows, name);
        String value = property.getValue();
        boolean placeholder = value.startsWith("{{") || value.startsWith("${") || value.startsWith("$simple{");
        boolean lookup = value.startsWith("#") && value.length() > 1;
        Map<String, String> row = getRow(rows, name);
        // maybe the name was using an optional prefix, and if so then lookup without the prefix
        if (row == null && !isEmpty(optionalPrefix)) {
            if (name.startsWith(optionalPrefix)) {
                name = name.substring(optionalPrefix.length());
            }
            row = getRow(rows, name);
        }
        if (row == null) {
            // unknown option
            result.addUnknown(name);
            if (suggestionStrategy != null) {
                String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);
                if (suggestions != null) {
                    result.addUnknownSuggestions(name, suggestions);
                }
            }
        } else {
            // default value
            String defaultValue = getPropertyDefaultValue(rows, name);
            if (defaultValue != null) {
                result.addDefaultValue(name, defaultValue);
            }
            // is required but the value is empty
            boolean required = isPropertyRequired(rows, name);
            if (required && isEmpty(value)) {
                result.addRequired(name);
            }
            // is enum but the value is not within the enum range
            // but we can only check if the value is not a placeholder
            String enums = getPropertyEnum(rows, name);
            if (!placeholder && !lookup && enums != null) {
                String[] choices = enums.split(",");
                boolean found = false;
                for (String s : choices) {
                    if (value.equalsIgnoreCase(s)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    result.addInvalidEnum(name, value);
                    result.addInvalidEnumChoices(name, choices);
                }
            }
            // is reference lookup of bean (not applicable for @UriPath)
            String kind = getPropertyKind(rows, name);
            if (!"path".equals(kind) && isPropertyObject(rows, name)) {
                // must start with # and be at least 2 characters
                if (!value.startsWith("#") || value.length() <= 1) {
                    result.addInvalidReference(name, value);
                }
            }
            // is boolean
            if (!placeholder && !lookup && isPropertyBoolean(rows, name)) {
                // value must be a boolean
                boolean bool = "true".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value);
                if (!bool) {
                    result.addInvalidBoolean(name, value);
                }
            }
            // is integer
            if (!placeholder && !lookup && isPropertyInteger(rows, name)) {
                // value must be an integer
                boolean valid = validateInteger(value);
                if (!valid) {
                    result.addInvalidInteger(name, value);
                }
            }
            // is number
            if (!placeholder && !lookup && isPropertyNumber(rows, name)) {
                // value must be an number
                boolean valid = false;
                try {
                    valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();
                } catch (Exception e) {
                // ignore
                }
                if (!valid) {
                    result.addInvalidNumber(name, value);
                }
            }
        }
    }
    // now check if all required values are there, and that a default value does not exists
    for (Map<String, String> row : rows) {
        String name = row.get("name");
        boolean required = isPropertyRequired(rows, name);
        if (required) {
            String value = properties.get(name);
            if (isEmpty(value)) {
                value = getPropertyDefaultValue(rows, name);
            }
            if (isEmpty(value)) {
                result.addRequired(name);
            }
        }
    }
    return result;
</td> </tr></table></body></html>