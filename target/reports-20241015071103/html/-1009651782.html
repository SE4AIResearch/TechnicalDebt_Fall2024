<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5986</td> <td>-1009651782</td><td>apache/hadoop</td><td>Steve Loughran</td><td>28e6a4e44a3e920dcaf858f9a74a6358226b3a63</td> <td>None</td> <td>Corrupt the log file in various ways for each txn</td> <td>SATD_ADDED</td> <td>testCountValidTransactions()</td> <td>public void testCountValidTransactions() throws IOException</td> <td>
    File testDir = new File(TEST_DIR, "testCountValidTransactions");
    File logFile = new File(testDir, NNStorage.getInProgressEditsFileName(1));
    // Create a log file, and return the offsets at which each
    // transaction starts.
    FSEditLog fsel = null;
    final int NUM_TXNS = 30;
    SortedMap<Long, Long> offsetToTxId = Maps.newTreeMap();
    try {
        fsel = FSImageTestUtil.createStandaloneEditLog(testDir);
        fsel.open();
        assertTrue("should exist: " + logFile, logFile.exists());
        for (int i = 0; i < NUM_TXNS; i++) {
            long trueOffset = getNonTrailerLength(logFile);
            long thisTxId = fsel.getLastWrittenTxId() + 1;
            offsetToTxId.put(trueOffset, thisTxId);
            System.err.println("txid " + thisTxId + " at offset " + trueOffset);
            fsel.logDelete("path" + i, i);
            fsel.logSync();
        }
    } finally {
        if (fsel != null) {
            fsel.close();
        }
    }
    // The file got renamed when the log was closed.
    logFile = testDir.listFiles()[0];
    long validLength = getNonTrailerLength(logFile);
    // Make sure that uncorrupted log has the expected length and number
    // of transactions.
    EditLogValidation validation = FSEditLogLoader.validateEditLog(logFile);
    assertEquals(NUM_TXNS + 2, validation.numTransactions);
    assertEquals(validLength, validation.validLength);
    // Back up the uncorrupted log
    File logFileBak = new File(testDir, logFile.getName() + ".bak");
    Files.copy(logFile, logFileBak);
    // Corrupt the log file in various ways for each txn
    for (Map.Entry<Long, Long> entry : offsetToTxId.entrySet()) {
        long txOffset = entry.getKey();
        long txid = entry.getValue();
        // Restore backup, truncate the file exactly before the txn
        Files.copy(logFileBak, logFile);
        truncateFile(logFile, txOffset);
        validation = FSEditLogLoader.validateEditLog(logFile);
        assertEquals("Failed when truncating to length " + txOffset, txid - 1, validation.numTransactions);
        assertEquals(txOffset, validation.validLength);
        // Restore backup, truncate the file with one byte in the txn,
        // also isn't valid
        Files.copy(logFileBak, logFile);
        truncateFile(logFile, txOffset + 1);
        validation = FSEditLogLoader.validateEditLog(logFile);
        assertEquals("Failed when truncating to length " + (txOffset + 1), txid - 1, validation.numTransactions);
        assertEquals(txOffset, validation.validLength);
        // Restore backup, corrupt the txn opcode
        Files.copy(logFileBak, logFile);
        corruptByteInFile(logFile, txOffset);
        validation = FSEditLogLoader.validateEditLog(logFile);
        assertEquals("Failed when corrupting txn opcode at " + txOffset, txid - 1, validation.numTransactions);
        assertEquals(txOffset, validation.validLength);
        // Restore backup, corrupt a byte a few bytes into the txn
        Files.copy(logFileBak, logFile);
        corruptByteInFile(logFile, txOffset + 5);
        validation = FSEditLogLoader.validateEditLog(logFile);
        assertEquals("Failed when corrupting txn data at " + (txOffset + 5), txid - 1, validation.numTransactions);
        assertEquals(txOffset, validation.validLength);
    }
    // Corrupt the log at every offset to make sure that validation itself
    // never throws an exception, and that the calculated lengths are monotonically
    // increasing
    long prevNumValid = 0;
    for (long offset = 0; offset < validLength; offset++) {
        Files.copy(logFileBak, logFile);
        corruptByteInFile(logFile, offset);
        EditLogValidation val = FSEditLogLoader.validateEditLog(logFile);
        assertTrue(val.numTransactions >= prevNumValid);
        prevNumValid = val.numTransactions;
    }
</td> </tr></table></body></html>