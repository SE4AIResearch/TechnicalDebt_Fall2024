<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4049</td> 
     <td>1242677671</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>263786e2fd4ae7cf385c34d04626abc79e4305d6</td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>FILE_PATH_CHANGED</td> 
     <td>canPerform(Set<accountgroup.id>
        , ProjectCache.Entry, ApprovalCategory.Id, short, boolean) 
      </accountgroup.id></td> 
     <td>public static boolean canPerform(final Set<accountgroup.id>
        myGroups, final ProjectCache.Entry e, final ApprovalCategory.Id actionId, final short requireValue, final boolean assumeOwner) 
      </accountgroup.id></td> 
     <td> if (assumeOwner &amp;&amp; myGroups.contains(e.getProject().getOwnerGroupId())) { // Ownership implies full access. // return true; } int val = Integer.MIN_VALUE; for (final ProjectRight pr : e.getRights()) { if (actionId.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { if (val &lt; 0 &amp;&amp; pr.getMaxValue() &gt; 0) { // If one of the user's groups had denied them access, but // this group grants them access, prefer the grant over // the denial. We have to break the tie somehow and we // prefer being "more open" to being "more closed". // val = pr.getMaxValue(); } else { // Otherwise we use the largest value we can get. // val = Math.max(pr.getMaxValue(), val); } } } if (val == Integer.MIN_VALUE) { for (final ProjectRight pr : Common.getProjectCache().getWildcardRights()) { if (actionId.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { val = Math.max(pr.getMaxValue(), val); } } } return val &gt;= requireValue; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4034</td> 
     <td>1242677671</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>43473176853da388bf3a699d89c33e19e5302eb8</td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>canPerform(Set<accountgroup.id>
        , ProjectCache.Entry, ApprovalCategory.Id, short, boolean) 
      </accountgroup.id></td> 
     <td>public static boolean canPerform(final Set<accountgroup.id>
        myGroups, final ProjectCache.Entry e, final ApprovalCategory.Id actionId, final short requireValue, final boolean assumeOwner) 
      </accountgroup.id></td> 
     <td> if (assumeOwner &amp;&amp; myGroups.contains(e.getProject().getOwnerGroupId())) { // Ownership implies full access. // return true; } int val = Integer.MIN_VALUE; for (final ProjectRight pr : e.getRights()) { if (actionId.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { if (val &lt; 0 &amp;&amp; pr.getMaxValue() &gt; 0) { // If one of the user's groups had denied them access, but // this group grants them access, prefer the grant over // the denial. We have to break the tie somehow and we // prefer being "more open" to being "more closed". // val = pr.getMaxValue(); } else { // Otherwise we use the largest value we can get. // val = Math.max(pr.getMaxValue(), val); } } } if (val == Integer.MIN_VALUE) { for (final ProjectRight pr : Common.getProjectCache().getWildcardRights()) { if (actionId.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { val = Math.max(pr.getMaxValue(), val); } } } return val &gt;= requireValue; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4022</td> 
     <td>1242677671</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>f37939c8e29b1cd903cf29a42081f2f9453d2c63</td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>canRead(Account.Id, Project.NameKey)</td> 
     <td>public static boolean canRead(final Account.Id who, final Project.NameKey projectKey)</td> 
     <td> final ProjectCache.Entry e = Common.getProjectCache().get(projectKey); if (e == null) { // Unexpected, a project disappearing. But claim its not available. // return false; } final Set<accountgroup.id>
        myGroups = Common.getGroupCache().getGroups(who); if (myGroups.contains(e.getProject().getOwnerGroupId())) { // Ownership implies full access. // return true; } int val = Integer.MIN_VALUE; for (final ProjectRight pr : e.getRights()) { if (ApprovalCategory.READ.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { if (val &lt; 0 &amp;&amp; pr.getMaxValue() &gt; 0) { // If one of the user's groups had denied them access, but // this group grants them access, prefer the grant over // the denial. We have to break the tie somehow and we // prefer being "more open" to being "more closed". // val = pr.getMaxValue(); } else { // Otherwise we use the largest value we can get. // val = Math.max(pr.getMaxValue(), val); } } } if (val == Integer.MIN_VALUE) { for (final ProjectRight pr : Common.getProjectCache().getWildcardRights()) { if (ApprovalCategory.READ.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { val = Math.max(pr.getMaxValue(), val); } } } return val &gt; 0; 
      </accountgroup.id></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4005</td> 
     <td>1242677671</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>a49c3c6ecefb809ed461383c32e40ffd9df91889</td> 
     <td>None</td> 
     <td>If one of the user's groups had denied them access, but this group grants them access, prefer the grant over the denial. We have to break the tie somehow and we prefer being \"more open\" to being \"more closed\". </td> 
     <td>SATD_ADDED</td> 
     <td>canRead(Project.NameKey)</td> 
     <td>public static boolean canRead(final Project.NameKey projectKey)</td> 
     <td> final ProjectCache.Entry e = Common.getProjectCache().get(projectKey); if (e == null) { // Unexpected, a project disappearing. But claim its not available. // return false; } final Set<accountgroup.id>
        myGroups = Common.getGroupCache().getGroups(Common.getAccountId()); if (myGroups.contains(e.getProject().getOwnerGroupId())) { // Ownership implies full access. // return true; } int val = Integer.MIN_VALUE; for (final ProjectRight pr : e.getRights()) { if (ApprovalCategory.READ.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { if (val &lt; 0 &amp;&amp; pr.getMaxValue() &gt; 0) { // If one of the user's groups had denied them access, but // this group grants them access, prefer the grant over // the denial. We have to break the tie somehow and we // prefer being "more open" to being "more closed". // val = pr.getMaxValue(); } else { // Otherwise we use the largest value we can get. // val = Math.max(pr.getMaxValue(), val); } } } if (val == Integer.MIN_VALUE) { for (final ProjectRight pr : Common.getProjectCache().getWildcardRights()) { if (ApprovalCategory.READ.equals(pr.getApprovalCategoryId()) &amp;&amp; myGroups.contains(pr.getAccountGroupId())) { val = Math.max(pr.getMaxValue(), val); } } } return val &gt; 0; 
      </accountgroup.id></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>