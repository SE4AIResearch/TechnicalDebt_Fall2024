<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>5985</td> <td>-1009651783</td><td>apache/hadoop</td><td>Steve Loughran</td><td>28e6a4e44a3e920dcaf858f9a74a6358226b3a63</td> <td>None</td> <td>TODO: unfortunately this fails -- should be improved.
See HDFS-2173.</td> <td>SATD_ADDED</td> <td>saveNamespaceWithInjectedFault(Fault)</td> <td>private void saveNamespaceWithInjectedFault(Fault fault) throws Exception</td> <td>
    Configuration conf = getConf();
    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);
    DFSTestUtil.formatNameNode(conf);
    FSNamesystem fsn = new FSNamesystem(conf);
    // Replace the FSImage with a spy
    FSImage originalImage = fsn.dir.fsImage;
    NNStorage storage = originalImage.getStorage();
    NNStorage spyStorage = spy(storage);
    originalImage.storage = spyStorage;
    FSImage spyImage = spy(originalImage);
    fsn.dir.fsImage = spyImage;
    // should we expect the save operation to fail
    boolean shouldFail = false;
    // inject fault
    switch(fault) {
        case SAVE_SECOND_FSIMAGE_RTE:
            // The spy throws a RuntimeException when writing to the second directory
            doAnswer(new FaultySaveImage(true)).when(spyImage).saveFSImage((StorageDirectory) anyObject(), anyLong());
            shouldFail = false;
            break;
        case SAVE_SECOND_FSIMAGE_IOE:
            // The spy throws an IOException when writing to the second directory
            doAnswer(new FaultySaveImage(false)).when(spyImage).saveFSImage((StorageDirectory) anyObject(), anyLong());
            shouldFail = false;
            break;
        case SAVE_ALL_FSIMAGES:
            // The spy throws IOException in all directories
            doThrow(new RuntimeException("Injected")).when(spyImage).saveFSImage((StorageDirectory) anyObject(), anyLong());
            shouldFail = true;
            break;
        case WRITE_STORAGE_ALL:
            // The spy throws an exception before writing any VERSION files
            doThrow(new RuntimeException("Injected")).when(spyStorage).writeAll();
            shouldFail = true;
            break;
        case WRITE_STORAGE_ONE:
            // The spy throws on exception on one particular storage directory
            doAnswer(new FaultySaveImage(true)).when(spyStorage).writeProperties((StorageDirectory) anyObject());
            // TODO: unfortunately this fails -- should be improved.
            // See HDFS-2173.
            shouldFail = true;
            break;
    }
    try {
        doAnEdit(fsn, 1);
        // Save namespace - this may fail, depending on fault injected
        fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
        try {
            fsn.saveNamespace();
            if (shouldFail) {
                fail("Did not fail!");
            }
        } catch (Exception e) {
            if (!shouldFail) {
                throw e;
            } else {
                LOG.info("Test caught expected exception", e);
            }
        }
        fsn.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
        // Should still be able to perform edits
        doAnEdit(fsn, 2);
        // Now shut down and restart the namesystem
        originalImage.close();
        fsn.close();
        fsn = null;
        // Start a new namesystem, which should be able to recover
        // the namespace from the previous incarnation.
        fsn = new FSNamesystem(conf);
        // Make sure the image loaded including our edits.
        checkEditExists(fsn, 1);
        checkEditExists(fsn, 2);
    } finally {
        if (fsn != null) {
            fsn.close();
        }
    }
</td> </tr></table></body></html>