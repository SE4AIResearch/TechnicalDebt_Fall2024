<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4826</td> 
     <td>1242677813</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Dave Borowitz</td> 
     <td>fdbb76233c34c23f446e11f97047ef75c84a4704</td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>compute(Text, Text, List<edit>
        ) 
      </edit></td> 
     <td> static IntraLineDiff compute(Text aText, Text bText, List<edit>
        edits) throws Exception 
      </edit></td> 
     <td> combineLineEdits(edits, aText, bText); for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { CharText a = new CharText(aText, e.getBeginA(), e.getEndA()); CharText b = new CharText(bText, e.getBeginB(), e.getEndB()); CharTextComparator cmp = new CharTextComparator(); List<edit>
        wordEdits = MyersDiff.INSTANCE.diff(cmp, a, b); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (cmp.equals(a, ab + p, a, ab + p)) { p++; } else { break; } } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; cmp.equals(a, ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; cmp.equals(a, ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (cmp.equals(b, bb + p, b, bb + p)) { p++; } else { break; } } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; cmp.equals(b, bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; cmp.equals(b, bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae - 1) != '\n' &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be - 1) != '\n' &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new IntraLineDiff(edits); 
      </edit></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4312</td> 
     <td>1242677813</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn O. Pearce</td> 
     <td>617aa397e332857fd0009d66018c0434aa1517ad</td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>compute(IntraLineDiffKey)</td> 
     <td>private static IntraLineDiff compute(IntraLineDiffKey key) throws Exception</td> 
     <td> List<edit>
        edits = new ArrayList 
       <edit>
         (key.getEdits()); Text aContent = key.getTextA(); Text bContent = key.getTextB(); combineLineEdits(edits, aContent, bContent); for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); CharTextComparator cmp = new CharTextComparator(); List 
        <edit>
          wordEdits = MyersDiff.INSTANCE.diff(cmp, a, b); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (cmp.equals(a, ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; cmp.equals(a, ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; cmp.equals(a, ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (cmp.equals(b, bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; cmp.equals(b, bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; cmp.equals(b, bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new IntraLineDiff(edits); 
        </edit> 
       </edit> 
      </edit></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4308</td> 
     <td>1242677813</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Shawn O. Pearce</td>
     <td>0365b824a22934e78b99bd7e813b976e2b59b0e4</td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>Apply some simple rules to fix up some of the edits. Our logic above, along with our per-character difference tends to produce some crazy stuff. </td> 
     <td>SATD_MOVED_FILE</td> 
     <td>createEntry(IntraLineDiffKey)</td> 
     <td>public IntraLineDiff createEntry(IntraLineDiffKey key) throws Exception</td> 
     <td> List<edit>
        edits = new ArrayList
       <edit>
        (key.getEdits()); Text aContent = key.getTextA(); Text bContent = key.getTextB(); combineLineEdits(edits, aContent, bContent); for (int i = 0; i &lt; edits.size(); i++) { Edit e = edits.get(i); if (e.getType() == Edit.Type.REPLACE) { CharText a = new CharText(aContent, e.getBeginA(), e.getEndA()); CharText b = new CharText(bContent, e.getBeginB(), e.getEndB()); CharTextComparator cmp = new CharTextComparator(); List
        <edit>
          wordEdits = MyersDiff.INSTANCE.diff(cmp, a, b); // Combine edits that are really close together. If they are // just a few characters apart we tend to get better results // by joining them together and taking the whole span. // for (int j = 0; j &lt; wordEdits.size() - 1; ) { Edit c = wordEdits.get(j); Edit n = wordEdits.get(j + 1); if (n.getBeginA() - c.getEndA() &lt;= 5 || n.getBeginB() - c.getEndB() &lt;= 5) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); if (canCoalesce(a, c.getEndA(), n.getBeginA()) &amp;&amp; canCoalesce(b, c.getEndB(), n.getBeginB())) { wordEdits.set(j, new Edit(ab, ae, bb, be)); wordEdits.remove(j + 1); continue; } } j++; } // Apply some simple rules to fix up some of the edits. Our // logic above, along with our per-character difference tends // to produce some crazy stuff. // for (int j = 0; j &lt; wordEdits.size(); j++) { Edit c = wordEdits.get(j); int ab = c.getBeginA(); int ae = c.getEndA(); int bb = c.getBeginB(); int be = c.getEndB(); // Sometimes the diff generator produces an INSERT or DELETE // right up against a REPLACE, but we only find this after // we've also played some shifting games on the prior edit. // If that happened to us, coalesce them together so we can // correct this mess for the user. If we don't we wind up // with silly stuff like "es" -&gt; "es = Addresses". // if (1 &lt; j) { Edit p = wordEdits.get(j - 1); if (p.getEndA() == ab || p.getEndB() == bb) { if (p.getEndA() == ab &amp;&amp; p.getBeginA() &lt; p.getEndA()) { ab = p.getBeginA(); } if (p.getEndB() == bb &amp;&amp; p.getBeginB() &lt; p.getEndB()) { bb = p.getBeginB(); } wordEdits.remove(--j); } } // We sometimes collapsed an edit together in a strange way, // such that the edges of each text is identical. Fix by // by dropping out that incorrectly replaced region. // while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ab, b, bb)) { ab++; bb++; } while (ab &lt; ae &amp;&amp; bb &lt; be &amp;&amp; cmp.equals(a, ae - 1, b, be - 1)) { ae--; be--; } // The leading part of an edit and its trailing part in the same // text might be identical. Slide down that edit and use the tail // rather than the leading bit. If however the edit is only on a // whitespace block try to shift it to the left margin, assuming // that it is an indentation change. // boolean aShift = true; if (ab &lt; ae &amp;&amp; isOnlyWhitespace(a, ab, ae)) { int lf = findLF(wordEdits, j, a, ab); if (lf &lt; ab &amp;&amp; a.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; ae - ab) { if (cmp.equals(a, ab + p, a, ab + p)) p++; else break; } if (p == ae - ab) { ab = nb; ae = nb + p; aShift = false; } } } if (aShift) { while (0 &lt; ab &amp;&amp; ab &lt; ae &amp;&amp; a.charAt(ab - 1) != '\n' &amp;&amp; cmp.equals(a, ab - 1, a, ae - 1)) { ab--; ae--; } if (!a.isLineStart(ab) || !a.contains(ab, ae, '\n')) { while (ab &lt; ae &amp;&amp; ae &lt; a.size() &amp;&amp; cmp.equals(a, ab, a, ae)) { ab++; ae++; if (a.charAt(ae - 1) == '\n') { break; } } } } boolean bShift = true; if (bb &lt; be &amp;&amp; isOnlyWhitespace(b, bb, be)) { int lf = findLF(wordEdits, j, b, bb); if (lf &lt; bb &amp;&amp; b.charAt(lf) == '\n') { int nb = lf + 1; int p = 0; while (p &lt; be - bb) { if (cmp.equals(b, bb + p, b, bb + p)) p++; else break; } if (p == be - bb) { bb = nb; be = nb + p; bShift = false; } } } if (bShift) { while (0 &lt; bb &amp;&amp; bb &lt; be &amp;&amp; b.charAt(bb - 1) != '\n' &amp;&amp; cmp.equals(b, bb - 1, b, be - 1)) { bb--; be--; } if (!b.isLineStart(bb) || !b.contains(bb, be, '\n')) { while (bb &lt; be &amp;&amp; be &lt; b.size() &amp;&amp; cmp.equals(b, bb, b, be)) { bb++; be++; if (b.charAt(be - 1) == '\n') { break; } } } } // If most of a line was modified except the LF was common, make // the LF part of the modification region. This is easier to read. // if (// ab &lt; ae &amp;&amp; // (ab == 0 || a.charAt(ab - 1) == '\n') &amp;&amp; ae &lt; a.size() &amp;&amp; a.charAt(ae) == '\n') { ae++; } if (// bb &lt; be &amp;&amp; // (bb == 0 || b.charAt(bb - 1) == '\n') &amp;&amp; be &lt; b.size() &amp;&amp; b.charAt(be) == '\n') { be++; } wordEdits.set(j, new Edit(ab, ae, bb, be)); } edits.set(i, new ReplaceEdit(e, wordEdits)); } } return new IntraLineDiff(edits); 
        </edit>
       </edit>
      </edit></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>