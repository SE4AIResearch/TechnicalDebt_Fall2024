<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>2729</td> 
     <td>-1422651330</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>b75ee93040939314c9ece1aba4086d1ef54d13be</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>deliverToFailureProcessor(Processor, boolean, Exchange, RedeliveryData, AsyncCallback)</td> 
     <td>protected boolean deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback)</td> 
     <td> boolean sync = true; Exception caught = exchange.getException(); // we did not success with the redelivery so now we let the failure processor handle it // clear exception as we let the failure processor handle it exchange.setException(null); // always handle if dead letter channel final boolean shouldHandle = isDeadLetterChannel || shouldHandled(exchange, data); final boolean shouldContinue = shouldContinue(exchange, data); // regard both handled or continued as being handled boolean handled = false; if (shouldHandle || shouldContinue) { // its handled then remove traces of redelivery attempted exchange.getIn().removeHeader(Exchange.REDELIVERED); exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER); exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER); exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED); // and remove traces of rollback only and uow exhausted markers exchange.removeProperty(Exchange.ROLLBACK_ONLY); exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED); handled = true; } else { // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); } // is the a failure processor to process the Exchange if (processor != null) { // prepare original IN body if it should be moved instead of current body if (data.useOriginalInMessage) { log.trace("Using the original IN message instead of current"); Message original = exchange.getUnitOfWork().getOriginalInMessage(); exchange.setIn(original); if (exchange.hasOut()) { log.trace("Removing the out message to avoid some uncertain behavior"); exchange.setOut(null); } } // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); log.trace("Failure processor {} is processing Exchange: {}", processor, exchange); // store the last to endpoint as the failure endpoint exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)); // and store the route id so we know in which route we failed if (exchange.getUnitOfWork().getRouteContext() != null) { exchange.setProperty(Exchange.FAILURE_ROUTE_ID, exchange.getUnitOfWork().getRouteContext().getRoute().getId()); } // the failure processor could also be asynchronous AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor); sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() { public void done(boolean sync) { log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange); try { prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue); // fire event as we had a failure processor to handle it, which there is a event for boolean deadLetterChannel = processor == data.deadLetterProcessor &amp;&amp; data.deadLetterProcessor != null; EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel); } finally { // if the fault was handled asynchronously, this should be reflected in the callback as well data.sync &amp;= sync; callback.done(data.sync); } } }); } else { try { // no processor but we need to prepare after failure as well prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue); } finally { // callback we are done callback.done(data.sync); } } // create log message String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange); msg = msg + ". Exhausted after delivery attempt: " + data.redeliveryCounter + " caught: " + caught; if (processor != null) { msg = msg + ". Processed by failure processor: " + processor; } // log that we failed delivery as we are exhausted logFailedDelivery(false, handled, false, exchange, msg, data, null); return sync; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1907</td> 
     <td>-1422651330</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>0c7e310843e71158469cf783c4b91ed1125d16f3</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>deliverToFailureProcessor(Processor, Exchange, RedeliveryData, AsyncCallback)</td> 
     <td>protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback)</td> 
     <td> boolean sync = true; Exception caught = exchange.getException(); // we did not success with the redelivery so now we let the failure processor handle it // clear exception as we let the failure processor handle it exchange.setException(null); boolean handled = false; // regard both handled or continued as being handled if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) { // its handled then remove traces of redelivery attempted exchange.getIn().removeHeader(Exchange.REDELIVERED); exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER); handled = true; } else { // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); } // is the a failure processor to process the Exchange if (processor != null) { // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); // prepare original IN body if it should be moved instead of current body if (data.useOriginalInMessage) { if (log.isTraceEnabled()) { log.trace("Using the original IN message instead of current"); } Message original = exchange.getUnitOfWork().getOriginalInMessage(); exchange.setIn(original); } if (log.isTraceEnabled()) { log.trace("Failure processor " + processor + " is processing Exchange: " + exchange); } // store the last to endpoint as the failure endpoint exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)); // the failure processor could also be asynchronous AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor); sync = afp.process(exchange, new AsyncCallback() { public void done(boolean sync) { if (log.isTraceEnabled()) { log.trace("Failure processor done: " + processor + " processing Exchange: " + exchange); } try { prepareExchangeAfterFailure(exchange, data); // fire event as we had a failure processor to handle it boolean deadLetterChannel = processor == data.deadLetterProcessor &amp;&amp; data.deadLetterProcessor != null; EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel); } finally { // if the fault was handled asynchronously, this should be reflected in the callback as well data.sync &amp;= sync; callback.done(data.sync); } } }); } else { try { // no processor but we need to prepare after failure as well prepareExchangeAfterFailure(exchange, data); } finally { // indicate we are done synchronously data.sync = true; callback.done(data.sync); } } // create log message String msg = "Failed delivery for exchangeId: " + exchange.getExchangeId(); msg = msg + ". Exhausted after delivery attempt: " + data.redeliveryCounter + " caught: " + caught; if (processor != null) { msg = msg + ". Processed by failure processor: " + processor; } // log that we failed delivery as we are exhausted logFailedDelivery(false, handled, false, exchange, msg, data, null); return sync; </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1424</td> 
     <td>-1422651330</td> 
     <td>apache/camel</td> 
     <td>Willem Ning Jiang</td> 
     <td>73569852bf41c8d5a6bd7efca7d64593c0e41926</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>deliverToFailureProcessor(Processor, Exchange, RedeliveryData)</td> 
     <td>protected void deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data)</td> 
     <td> // we did not success with the redelivery so now we let the failure processor handle it // clear exception as we let the failure processor handle it exchange.setException(null); // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); if (processor != null) { // prepare original IN body if it should be moved instead of current body if (data.useOriginalInBody) { if (log.isTraceEnabled()) { log.trace("Using the original IN body instead of the current IN body"); } Object original = exchange.getUnitOfWork().getOriginalInBody(); exchange.getIn().setBody(original); } if (log.isTraceEnabled()) { log.trace("Failure processor " + processor + " is processing Exchange: " + exchange); } try { processor.process(exchange); } catch (Exception e) { exchange.setException(e); } log.trace("Failure processor done"); String msg = "Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Processed by failure processor: " + processor; logFailedDelivery(false, exchange, msg, data, null); } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1420</td> 
     <td>-1422651330</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>b06a3d3587a3c17853d06008137b8aa1baacf095</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>deliverToFailureProcessor(Processor, Exchange, RedeliveryData, boolean)</td> 
     <td>protected void deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, boolean isDeadLetter)</td> 
     <td> // we did not success with the redelivery so now we let the failure processor handle it // clear exception as we let the failure processor handle it exchange.setException(null); // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); if (processor != null) { // prepare original IN body if it should be moved instead of current body if (data.useOriginalInBody) { if (log.isTraceEnabled()) { log.trace("Using the original IN body instead of the current IN body"); } Object original = exchange.getUnitOfWork().getOriginalInBody(); exchange.getIn().setBody(original); } if (log.isTraceEnabled()) { log.trace("Failure processor " + processor + " is processing Exchange: " + exchange); } try { processor.process(exchange); } catch (Exception e) { exchange.setException(e); } log.trace("Failure processor done"); String msg = "Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Processed by failure processor: " + processor; logFailedDelivery(false, exchange, msg, data, null); } </td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>1418</td> 
     <td>-1422651330</td> 
     <td>apache/camel</td> 
     <td>Claus Ibsen</td> 
     <td>b2bee1a966adb03063c9e6e3e22bfd5ebf2ae52c</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>deliverToFailureProcessor(Processor, Exchange, RedeliveryData)</td> 
     <td>protected void deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data)</td> 
     <td> // we did not success with the redelivery so now we let the failure processor handle it ExchangeHelper.setFailureHandled(exchange); // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); if (processor != null) { // prepare original IN body if it should be moved instead of current body if (data.useOriginalInBody) { if (log.isTraceEnabled()) { log.trace("Using the original IN body instead of the current IN body"); } Object original = exchange.getUnitOfWork().getOriginalInBody(); exchange.getIn().setBody(original); } if (log.isTraceEnabled()) { log.trace("Failure processor " + processor + " is processing Exchange: " + exchange); } try { processor.process(exchange); } catch (Exception e) { exchange.setException(e); } log.trace("Failure processor done"); String msg = "Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Processed by failure processor: " + processor; logFailedDelivery(false, exchange, msg, data, null); } </td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>1405</td> 
     <td>-1422651330</td>
     <td>apache/camel</td>
     <td>William Tam</td>
     <td>7aa107f96e03eed7f231a5799019de46296df91f</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>prepare original IN body if it should be moved instead of current body</td> 
     <td>SATD_MOVED_FILE</td> 
     <td>deliverToFailureProcessor(Exchange, RedeliveryData)</td> 
     <td>protected void deliverToFailureProcessor(final Exchange exchange, final RedeliveryData data)</td> 
     <td> // we did not success with the redelivery so now we let the failure processor handle it ExchangeHelper.setFailureHandled(exchange); // must decrement the redelivery counter as we didn't process the redelivery but is // handling by the failure handler. So we must -1 to not let the counter be out-of-sync decrementRedeliveryCounter(exchange); // reset cached streams so they can be read again MessageHelper.resetStreamCache(exchange.getIn()); if (data.failureProcessor != null) { // prepare original IN body if it should be moved instead of current body if (data.useOriginalInBody) { if (log.isTraceEnabled()) { log.trace("Using the original IN body in the DedLetterQueue instead of the current IN body"); } Object original = exchange.getUnitOfWork().getOriginalInBody(); exchange.getIn().setBody(original); } if (log.isTraceEnabled()) { log.trace("Failure processor " + data.failureProcessor + " is processing Exchange: " + exchange); } try { data.failureProcessor.process(exchange); } catch (Exception e) { exchange.setException(e); } log.trace("Failure processor done"); String msg = "Failed delivery for exchangeId: " + exchange.getExchangeId() + ". Processed by failure processor: " + data.failureProcessor; logFailedDelivery(false, exchange, msg, data, null); } </td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>