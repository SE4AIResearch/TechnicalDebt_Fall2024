<html>
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body>
  <h1>SATD</h1>
  <table>
   <tbody>
    <tr>
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr>
    <tr>
     <td>1268</td> 
     <td>-1422651396</td>
     <td>apache/camel</td>
     <td>Gert Vanthienen</td>
     <td>0d6538dcd810e0df76238c3fb6fe9caf9a047321</td> 
     <td>add intercept strategy that executes the JMX instrumentation for performance metrics TODO: We could do as below with an inlined implementation instead of a separate class</td> 
     <td>add intercept strategy that executes the JMX instrumentation for performance metrics</td> 
     <td>SATD_REMOVED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap
       <processordefinition, performancecounter>
        (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); // TODO: This only registers counters for the first outputs in the route // all the chidren of the outputs is not registered // we should leverge the Channel for this to ensure we register all processors // in the entire route graph // register all processors for (ProcessorDefinition processor : route.getOutputs()) { // skip processors that should not be registered if (!registerProcessor(processor)) { continue; } ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // add intercept strategy that executes the JMX instrumentation for performance metrics routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); // instrument the route endpoint final Endpoint endpoint = routeContext.getEndpoint(); // only needed to register on the first output as all rotues will pass through this one ProcessorDefinition out = routeContext.getRoute().getOutputs().get(0); // add an intercept strategy that counts when the route sends to any of its outputs out.addInterceptStrategy(new InterceptStrategy() { public Processor wrapProcessorInInterceptors(ProcessorDefinition processorDefinition, Processor target) throws Exception { if (registeredRoutes.containsKey(endpoint)) { // do not double wrap return target; } InstrumentationProcessor wrapper = new InstrumentationProcessor(null); wrapper.setType(processorDefinition.getShortName()); wrapper.setProcessor(target); // register our wrapper registeredRoutes.put(endpoint, wrapper); return wrapper; } }); 
       </processordefinition,>
      </processordefinition,></td> 
    </tr>
   </tbody>
   <tbody>
    <tr>
     <td>1267</td> 
     <td>-1422651396</td>
     <td>apache/camel</td>
     <td>Claus Ibsen</td>
     <td>cf11eb8fb4e6ca187b573513e49b58cdc361771b</td> 
     <td>None</td> 
     <td>add intercept strategy that executes the JMX instrumentation for performance metrics TODO: We could do as below with an inlined implementation instead of a separate class</td> 
     <td>SATD_ADDED</td> 
     <td>onRouteContextCreate(RouteContext)</td> 
     <td>public void onRouteContextCreate(RouteContext routeContext)</td> 
     <td> // the agent hasn't been started if (!initialized) { return; } // Create a map (ProcessorType -&gt; PerformanceCounter) // to be passed to InstrumentationInterceptStrategy. Map<processordefinition, performancecounter>
        registeredCounters = new HashMap
       <processordefinition, performancecounter>
        (); // Each processor in a route will have its own performance counter // The performance counter are MBeans that we register with MBeanServer. // These performance counter will be embedded // to InstrumentationProcessor and wrap the appropriate processor // by InstrumentationInterceptStrategy. RouteDefinition route = routeContext.getRoute(); // TODO: This only registers counters for the first outputs in the route // all the chidren of the outputs is not registered // we should leverge the Channel for this to ensure we register all processors // in the entire route graph // register all processors for (ProcessorDefinition processor : route.getOutputs()) { ObjectName name = null; try { // get the mbean name name = getNamingStrategy().getObjectName(routeContext, processor); // register mbean wrapped in the performance counter mbean PerformanceCounter pc = new PerformanceCounter(); agent.register(pc, name); // add to map now that it has been registered registeredCounters.put(processor, pc); } catch (MalformedObjectNameException e) { LOG.warn("Could not create MBean name: " + name, e); } catch (JMException e) { LOG.warn("Could not register PerformanceCounter MBean: " + name, e); } } // add intercept strategy that executes the JMX instrumentation for performance metrics // TODO: We could do as below with an inlined implementation instead of a separate class routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(registeredCounters)); // instrument the route endpoint final Endpoint endpoint = routeContext.getEndpoint(); // only needed to register on the first output as all rotues will pass through this one ProcessorDefinition out = routeContext.getRoute().getOutputs().get(0); // add an intercept strategy that counts when the route sends to any of its outputs out.addInterceptStrategy(new InterceptStrategy() { public Processor wrapProcessorInInterceptors(ProcessorDefinition processorDefinition, Processor target) throws Exception { if (registeredRoutes.containsKey(endpoint)) { // do not double wrap return target; } InstrumentationProcessor wrapper = new InstrumentationProcessor(null); wrapper.setType(processorDefinition.getShortName()); wrapper.setProcessor(target); // register our wrapper registeredRoutes.put(endpoint, wrapper); return wrapper; } }); 
       </processordefinition,>
      </processordefinition,></td> 
    </tr>
   </tbody>
  </table>
 </body>
</html>