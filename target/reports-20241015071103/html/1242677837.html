<html> 
 <head> 
  <style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style> 
 </head> 
 <body> 
  <h1>SATD</h1> 
  <table> 
   <tbody> 
    <tr> 
     <th>satd id</th> 
     <th>satd instance id</th> 
     <th>project</th> 
     <th>committer name </th> 
     <th> Commit Hash</th> 
     <th>old comment</th> 
     <th>New Comment</th> 
     <th>resolution</th> 
     <th>Method Signature</th> 
     <th>Method Declaration</th> 
     <th>Method Body</th> 
    </tr> 
    <tr> 
     <td>4747</td> 
     <td>1242677837</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Saša Živkov</td> 
     <td>a4e0250cbdf9344035bcf9168b59e8e3d52ddbb1</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>automerge(Repository, RevWalk, RevCommit, ThreeWayMergeStrategy, boolean)</td> 
     <td>public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy, boolean save) throws IOException</td> 
     <td> String hash = b.name(); String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2); Ref ref = repo.getRef(refName); if (ref != null &amp;&amp; ref.getObjectId() != null) { return rw.parseTree(ref.getObjectId()); } ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true); final ObjectInserter ins = repo.newObjectInserter(); try { DirCache dc = DirCache.newInCore(); m.setDirCache(dc); m.setObjectInserter(new ObjectInserter.Filter() { @Override protected ObjectInserter delegate() { return ins; } @Override public void flush() { } @Override public void release() { } }); boolean couldMerge; try { couldMerge = m.merge(b.getParents()); } catch (IOException e) { // It is not safe to continue further down in this method as throwing // an exception most likely means that the merge tree was not created // and m.getMergeResults() is empty. This would mean that all paths are // unmerged and Gerrit UI would show all paths in the patch list. log.warn("Error attempting automerge " + refName, e); return null; } ObjectId treeId; if (couldMerge) { treeId = m.getResultTreeId(); } else { RevCommit ours = b.getParent(0); RevCommit theirs = b.getParent(1); rw.parseBody(ours); rw.parseBody(theirs); String oursMsg = ours.getShortMessage(); String theirsMsg = theirs.getShortMessage(); String oursName = String.format("HEAD (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60))); String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60))); MergeFormatter fmt = new MergeFormatter(); Map<string, mergeresult<? extends sequence>
        &gt; r = m.getMergeResults(); Map 
       <string, objectid>
         resolved = new HashMap&lt;&gt;(); for (Map.Entry 
        <string, mergeresult<? extends sequence>
          &gt; entry : r.entrySet()) { MergeResult<!--? extends Sequence--> p = entry.getValue(); TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024); try { fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8"); buf.close(); InputStream in = buf.openInputStream(); try { resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in)); } finally { in.close(); } } finally { buf.destroy(); } } DirCacheBuilder builder = dc.builder(); int cnt = dc.getEntryCount(); for (int i = 0; i &lt; cnt; ) { DirCacheEntry entry = dc.getEntry(i); if (entry.getStage() == 0) { builder.add(entry); i++; continue; } int next = dc.nextEntry(i); String path = entry.getPathString(); DirCacheEntry res = new DirCacheEntry(path); if (resolved.containsKey(path)) { // For a file with content merge conflict that we produced a result // above on, collapse the file down to a single stage 0 with just // the blob content, and a randomly selected mode (the lowest stage, // which should be the merge base, or ours). res.setFileMode(entry.getFileMode()); res.setObjectId(resolved.get(path)); } else if (next == i + 1) { // If there is exactly one stage present, shouldn't be a conflict... res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else if (next == i + 2) { // Two stages suggests a delete/modify conflict. Pick the higher // stage as the automatic result. entry = dc.getEntry(i + 1); res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else { // 3 stage conflict, no resolve above // Punt on the 3-stage conflict and show the base, for now. res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } builder.add(res); i = next; } builder.finish(); treeId = dc.writeTree(ins); } ins.flush(); if (save) { RefUpdate update = repo.updateRef(refName); update.setNewObjectId(treeId); update.disableRefLog(); update.forceUpdate(); } return rw.lookupTree(treeId); } finally { ins.release(); } 
        </string,> 
       </string,> 
      </string,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4669</td> 
     <td>1242677837</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>David Pursehouse</td> 
     <td>df63f1aae5ff966a46a0b3382d5f1606411fd0f7</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>automerge(Repository, RevWalk, RevCommit, ThreeWayMergeStrategy, boolean)</td> 
     <td>public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy, boolean save) throws IOException</td> 
     <td> String hash = b.name(); String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2); Ref ref = repo.getRef(refName); if (ref != null &amp;&amp; ref.getObjectId() != null) { return rw.parseTree(ref.getObjectId()); } ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true); final ObjectInserter ins = repo.newObjectInserter(); try { DirCache dc = DirCache.newInCore(); m.setDirCache(dc); m.setObjectInserter(new ObjectInserter.Filter() { @Override protected ObjectInserter delegate() { return ins; } @Override public void flush() { } @Override public void release() { } }); boolean couldMerge; try { couldMerge = m.merge(b.getParents()); } catch (IOException e) { // It is not safe to continue further down in this method as throwing // an exception most likely means that the merge tree was not created // and m.getMergeResults() is empty. This would mean that all paths are // unmerged and Gerrit UI would show all paths in the patch list. log.warn("Error attempting automerge " + refName, e); return null; } ObjectId treeId; if (couldMerge) { treeId = m.getResultTreeId(); } else { RevCommit ours = b.getParent(0); RevCommit theirs = b.getParent(1); rw.parseBody(ours); rw.parseBody(theirs); String oursMsg = ours.getShortMessage(); String theirsMsg = theirs.getShortMessage(); String oursName = String.format("HEAD (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60))); String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60))); MergeFormatter fmt = new MergeFormatter(); Map<string, mergeresult<? extends sequence>
        &gt; r = m.getMergeResults(); Map 
       <string, objectid>
         resolved = new HashMap&lt;&gt;(); for (Map.Entry 
        <string, mergeresult<? extends sequence>
          &gt; entry : r.entrySet()) { MergeResult<!--? extends Sequence--> p = entry.getValue(); TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024); try { fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8"); buf.close(); InputStream in = buf.openInputStream(); try { resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in)); } finally { in.close(); } } finally { buf.destroy(); } } DirCacheBuilder builder = dc.builder(); int cnt = dc.getEntryCount(); for (int i = 0; i &lt; cnt; ) { DirCacheEntry entry = dc.getEntry(i); if (entry.getStage() == 0) { builder.add(entry); i++; continue; } int next = dc.nextEntry(i); String path = entry.getPathString(); DirCacheEntry res = new DirCacheEntry(path); if (resolved.containsKey(path)) { // For a file with content merge conflict that we produced a result // above on, collapse the file down to a single stage 0 with just // the blob content, and a randomly selected mode (the lowest stage, // which should be the merge base, or ours). res.setFileMode(entry.getFileMode()); res.setObjectId(resolved.get(path)); } else if (next == i + 1) { // If there is exactly one stage present, shouldn't be a conflict... res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else if (next == i + 2) { // Two stages suggests a delete/modify conflict. Pick the higher // stage as the automatic result. entry = dc.getEntry(i + 1); res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else { // 3 stage conflict, no resolve above // Punt on the 3-stage conflict and show the base, for now. res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } builder.add(res); i = next; } builder.finish(); treeId = dc.writeTree(ins); } ins.flush(); if (save) { RefUpdate update = repo.updateRef(refName); update.setNewObjectId(treeId); update.disableRefLog(); update.forceUpdate(); } return rw.lookupTree(treeId); } finally { ins.release(); } 
        </string,> 
       </string,> 
      </string,></td> 
    </tr> 
   </tbody> 
   <tbody> 
    <tr> 
     <td>4594</td> 
     <td>1242677837</td> 
     <td>GerritCodeReview/gerrit</td> 
     <td>Shawn Pearce</td> 
     <td>67e8304ae7e76fdc77c0f0653aee3c58d59ac106</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>CLASS_OR_METHOD_CHANGED</td> 
     <td>automerge(Repository, RevWalk, RevCommit, boolean)</td> 
     <td>public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, boolean save) throws IOException</td> 
     <td> String hash = b.name(); String refName = GitRepositoryManager.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2); Ref ref = repo.getRef(refName); if (ref != null &amp;&amp; ref.getObjectId() != null) { return rw.parseTree(ref.getObjectId()); } ObjectId treeId; ResolveMerger m = (ResolveMerger) MergeStrategy.RESOLVE.newMerger(repo, true); final ObjectInserter ins = repo.newObjectInserter(); try { DirCache dc = DirCache.newInCore(); m.setDirCache(dc); m.setObjectInserter(new ObjectInserter.Filter() { @Override protected ObjectInserter delegate() { return ins; } @Override public void flush() { } @Override public void release() { } }); boolean couldMerge = false; try { couldMerge = m.merge(b.getParents()); } catch (IOException e) { // It is not safe to continue further down in this method as throwing // an exception most likely means that the merge tree was not created // and m.getMergeResults() is empty. This would mean that all paths are // unmerged and Gerrit UI would show all paths in the patch list. return null; } if (couldMerge) { treeId = m.getResultTreeId(); } else { RevCommit ours = b.getParent(0); RevCommit theirs = b.getParent(1); rw.parseBody(ours); rw.parseBody(theirs); String oursMsg = ours.getShortMessage(); String theirsMsg = theirs.getShortMessage(); String oursName = String.format("HEAD (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60))); String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60))); MergeFormatter fmt = new MergeFormatter(); Map<string, mergeresult<? extends sequence>
        &gt; r = m.getMergeResults(); Map 
       <string, objectid>
         resolved = new HashMap 
        <string, objectid>
          (); for (String path : r.keySet()) { MergeResult<!--? extends Sequence--> p = r.get(path); TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024); try { fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8"); buf.close(); InputStream in = buf.openInputStream(); try { resolved.put(path, ins.insert(Constants.OBJ_BLOB, buf.length(), in)); } finally { in.close(); } } finally { buf.destroy(); } } DirCacheBuilder builder = dc.builder(); int cnt = dc.getEntryCount(); for (int i = 0; i &lt; cnt; ) { DirCacheEntry entry = dc.getEntry(i); if (entry.getStage() == 0) { builder.add(entry); i++; continue; } int next = dc.nextEntry(i); String path = entry.getPathString(); DirCacheEntry res = new DirCacheEntry(path); if (resolved.containsKey(path)) { // For a file with content merge conflict that we produced a result // above on, collapse the file down to a single stage 0 with just // the blob content, and a randomly selected mode (the lowest stage, // which should be the merge base, or ours). res.setFileMode(entry.getFileMode()); res.setObjectId(resolved.get(path)); } else if (next == i + 1) { // If there is exactly one stage present, shouldn't be a conflict... res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else if (next == i + 2) { // Two stages suggests a delete/modify conflict. Pick the higher // stage as the automatic result. entry = dc.getEntry(i + 1); res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else { // 3 stage conflict, no resolve above // Punt on the 3-stage conflict and show the base, for now. res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } builder.add(res); i = next; } builder.finish(); treeId = dc.writeTree(ins); } ins.flush(); } finally { ins.release(); } if (save) { RefUpdate update = repo.updateRef(refName); update.setNewObjectId(treeId); update.disableRefLog(); update.forceUpdate(); } return rw.parseTree(treeId); 
        </string,> 
       </string,> 
      </string,></td> 
    </tr> 
   </tbody> 
   <tbody>
    <tr>
     <td>4349</td> 
     <td>1242677837</td>
     <td>GerritCodeReview/gerrit</td>
     <td>Edwin Kempin</td>
     <td>6fd52badf224e91dd23b6a859d62334672b70803</td> 
     <td>None</td> 
     <td>For a file with content merge conflict that we produced a result above on, collapse the file down to a single stage 0 with just the blob content, and a randomly selected mode (the lowest stage, which should be the merge base, or ours).</td> 
     <td>SATD_ADDED</td> 
     <td>automerge(Repository, RevWalk, RevCommit)</td> 
     <td>private static RevObject automerge(Repository repo, RevWalk rw, RevCommit b) throws IOException</td> 
     <td> String hash = b.name(); String refName = GitRepositoryManager.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2); Ref ref = repo.getRef(refName); if (ref != null &amp;&amp; ref.getObjectId() != null) { return rw.parseTree(ref.getObjectId()); } ObjectId treeId; ResolveMerger m = (ResolveMerger) MergeStrategy.RESOLVE.newMerger(repo, true); ObjectInserter ins = m.getObjectInserter(); try { DirCache dc = DirCache.newInCore(); m.setDirCache(dc); if (m.merge(b.getParents())) { treeId = m.getResultTreeId(); } else { RevCommit ours = b.getParent(0); RevCommit theirs = b.getParent(1); rw.parseBody(ours); rw.parseBody(theirs); String oursMsg = ours.getShortMessage(); String theirsMsg = theirs.getShortMessage(); String oursName = String.format("HEAD (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60))); String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60))); MergeFormatter fmt = new MergeFormatter(); Map<string, mergeresult<? extends sequence>
       &gt; r = m.getMergeResults(); Map
       <string, objectid>
         resolved = new HashMap
        <string, objectid>
         (); for (String path : r.keySet()) { MergeResult<!--? extends Sequence--> p = r.get(path); TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024); try { fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8"); buf.close(); InputStream in = buf.openInputStream(); try { resolved.put(path, ins.insert(Constants.OBJ_BLOB, buf.length(), in)); } finally { in.close(); } } finally { buf.destroy(); } } DirCacheBuilder builder = dc.builder(); int cnt = dc.getEntryCount(); for (int i = 0; i &lt; cnt; ) { DirCacheEntry entry = dc.getEntry(i); if (entry.getStage() == 0) { builder.add(entry); i++; continue; } int next = dc.nextEntry(i); String path = entry.getPathString(); DirCacheEntry res = new DirCacheEntry(path); if (resolved.containsKey(path)) { // For a file with content merge conflict that we produced a result // above on, collapse the file down to a single stage 0 with just // the blob content, and a randomly selected mode (the lowest stage, // which should be the merge base, or ours). res.setFileMode(entry.getFileMode()); res.setObjectId(resolved.get(path)); } else if (next == i + 1) { // If there is exactly one stage present, shouldn't be a conflict... res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else if (next == i + 2) { // Two stages suggests a delete/modify conflict. Pick the higher // stage as the automatic result. entry = dc.getEntry(i + 1); res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } else { // 3 stage conflict, no resolve above // Punt on the 3-stage conflict and show the base, for now. res.setFileMode(entry.getFileMode()); res.setObjectId(entry.getObjectId()); } builder.add(res); i = next; } builder.finish(); treeId = dc.writeTree(ins); } ins.flush(); } finally { ins.release(); } RefUpdate update = repo.updateRef(refName); update.setNewObjectId(treeId); update.disableRefLog(); update.forceUpdate(); return rw.parseTree(treeId); 
        </string,>
       </string,>
      </string,></td> 
    </tr>
   </tbody>
  </table>  
 </body>
</html>