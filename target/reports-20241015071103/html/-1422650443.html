<html><head>
<style> table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}th {
  background: lightblue;
}</style>
</head> <body><h1>SATD</h1><table><tr><th>satd id</th> <th>satd instance id</th>  <th>project</th> <th>committer name </th> <th> Commit Hash</th> <th>old comment</th> <th>New Comment</th> <th>resolution</th> <th>Method Signature</th> <th>Method Declaration</th> <th>Method Body</th> </tr><tr><td>2965</td> <td>-1422650443</td><td>apache/camel</td><td>Claus Ibsen</td><td>dabc2dbaa006741eacc2e4a7aa389c3975ff8823</td> <td>None</td> <td>TODO why do we need a byte array input stream? --> streaming not possible?</td> <td>SATD_ADDED</td> <td>unmarshal(Exchange, InputStream)</td> <td>public Object unmarshal(Exchange exchange, InputStream encryptedStream) throws Exception</td> <td>
    if (encryptedStream == null) {
        return null;
    }
    InputStream in;
    try {
        byte[] encryptedData = IOUtils.toByteArray(encryptedStream);
        // TODO why do we need a byte array input stream? --> streaming not possible?
        InputStream byteStream = new ByteArrayInputStream(encryptedData);
        in = PGPUtil.getDecoderStream(byteStream);
    } finally {
        IOUtils.closeQuietly(encryptedStream);
    }
    PGPObjectFactory pgpFactory = new PGPObjectFactory(in);
    Object o = pgpFactory.nextObject();
    // the first object might be a PGP marker packet
    PGPEncryptedDataList enc;
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpFactory.nextObject();
    }
    IOHelper.close(in);
    PGPPublicKeyEncryptedData pbe = null;
    PGPPrivateKey key = null;
    // find encrypted data for which a private key exists in the secret key ring
    for (int i = 0; i < enc.size() && key == null; i++) {
        pbe = (PGPPublicKeyEncryptedData) enc.get(i);
        key = PGPDataFormatUtil.findPrivateKeyWithKeyId(exchange.getContext(), findKeyFileName(exchange), findEncryptionKeyRing(exchange), pbe.getKeyID(), findKeyPassword(exchange), getPassphraseAccessor(), getProvider());
    }
    if (key == null) {
        throw new PGPException("Provided input is encrypted with unknown pair of keys.");
    }
    InputStream encData = pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(getProvider()).build(key));
    pgpFactory = new PGPObjectFactory(encData);
    PGPCompressedData comData = (PGPCompressedData) pgpFactory.nextObject();
    pgpFactory = new PGPObjectFactory(comData.getDataStream());
    Object object = pgpFactory.nextObject();
    PGPOnePassSignature signature;
    if (object instanceof PGPOnePassSignatureList) {
        signature = getSignature(exchange, (PGPOnePassSignatureList) object);
        object = pgpFactory.nextObject();
    } else {
        signature = null;
    }
    PGPLiteralData ld = (PGPLiteralData) object;
    InputStream litData = ld.getInputStream();
    // TODO we should enable streaming here with CashedOutputStream!!
    byte[] answer;
    try {
        answer = Streams.readAll(litData);
    } finally {
        IOHelper.close(litData, encData, in);
    }
    if (signature != null) {
        signature.update(answer);
        PGPSignatureList sigList = (PGPSignatureList) pgpFactory.nextObject();
        if (!signature.verify(getSignatureWithKeyId(signature.getKeyID(), sigList))) {
            throw new SignatureException("Cannot verify PGP signature");
        }
    }
    return answer;
</td> </tr></table></body></html>